{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Getting_Started/Changes.html","title":"Changes","text":""},{"location":"Getting_Started/DesignGuide.html","title":"Design Guide","text":""},{"location":"Getting_Started/DesignGuide.html#overall-layout","title":"Overall Layout","text":"<p>The ideal approach is to have program components that are standardized, easily transferred to different machines, flexible enough to be customized and modified, and re-usable so that core components can be readily re-used amongst multiple machines and allow for future updates.  </p> There is no one single \u201cright way\u201d to write code <p>There are however many best practices and different design approaches for writing software, the key item is consistency, when all programmers in a group follow the same approach to writing code, code is more readable, re-usable, and robust.  Software development has not changed much since its inception.  Software development tools have gotten a lot better and easier to use but base concepts such as Object-Oriented Programming have not changed since its creation in the 1960\u2019s.  The problem is many of these ideas and tools passed the PLC world by until now, now the PLC world is catching up. Cabinet designers and mechanical designers are very familiar with revision control.  Checking parts of drawings out, editing them and checking back in is common practice. These processes originated in the programming world, and they were so successful, drawing packages have implemented them.  PLC Software development tools now have these same capabilities (often free of charge) that the rest of the programming world has had for decades.  Take advantage of these tools.  The aim of this document is to present a few different ways how things can be done.  It is up to the individual companies/teams to decide which ideas (if any) they like and will implement.  PLC software development is no different to any other software development and it should be treated as such.  All the tools available to the software development world are also available for PLC software development.  When code is written in a consistent documented manner it will be easier to read, easier to modify, easier to re-use and easier to update.  This saves money. </p>"},{"location":"Getting_Started/DesignGuide.html#plan-the-code","title":"Plan the code","text":"<p>Very few physical things are built by trial and error, not unless there is lots of material to destroy and time to rebuild.  So why does it happen with software?  No one would ever say to the mechanical department, \u201cHey we've had some steel here for an hour someone should start building the frame.  At least put the feet on the frame, we know the machine will need feet, that can be done right now, you weld those feet on to that beam\u201d.   Everything is first planned, then built, after that, it mostly fits together and there is very little re-work.  No plan? Then in the beginning lots of things get built, it looks like progress is fantastic as things are being completed, but when it\u2019s time to bring them together, they don't fit and they must be re-built and re-worked and all that perceived progress is gone, lots of time and material is wasted re-doing things.  Code is no different, the more complete the plan the less re-work later.  </p>"},{"location":"Getting_Started/DesignGuide.html#layers-and-interfaces","title":"Layers and interfaces","text":"<p>Everything, absolutely everything is accomplished via smaller components that work together.  Break down any problem into small manageable complete pieces. Components interact with each other in layers via interfaces.  Banking and bank machines are a perfect example.  There are three layers.  Customer, Bank Machine, and the Bank\u2019s Account Database.  The three talk to each other via interfaces.  An interface is the simply the common connection at the boundary between two components.  Where each component can say, \u201cMy responsibility ends at the interface\u201d or \u201cYou don\u2019t get to see anything past the interface\u201d.  The interface between the bank machine and the customer consists of a bankcard and a pin.  To take money out, a customer puts the card into the machine and enters a pin. The bank machine\u2019s interface to the bank is a secure network connection.  Via the network connection the bank machine provides the account number, pin and how much money has been requested.  The bank verifies the account, pin, and availability of funds.  If funds are available, the bank tells the bank machine to go ahead and release the money.  The bank machine counts the money, presents the money, confirms the user has taken the money and tells the bank to update the balance.  Any bankcard and pin, any bank machine, any bank, it all works. Pesos, Dollars, Euro it does not matter, the interfaces are clear, well defined, and everything interchangeable.   </p>"},{"location":"Getting_Started/DesignGuide.html#interfaces-allow-for-exchange","title":"Interfaces allow for Exchange","text":"<p>A key component of Interfaces is that they allow a component to be exchanged without affecting the other side.  Take for example a car.  The interface for using a car is the steering wheel, gas pedal, and brake pedal.  Every licensed operator can use this interface, what goes on past that, does not matter, and should not concern the user.  A diesel car can be exchanged for a gasoline or electric car, and it does not matter any, any operator can drive the car.  When the interface is different, such as manual gearbox with a clutch, then not every operator can use, only operators that understand the extra interface can use the car.  </p> <p>The same works in machines, developing controls or modules with interfaces allows components to be exchanged without affecting other parts of the machine.  Easier exchange of modules allows for more options with lower engineering costs and less risk.  </p> <p>Code should always be written in such a way that there is a defined interface to separate the inside of a piece of code from the outside.  Interfaces should be as similar as possible.  This makes it easier to change things later.  If the interface to the car was to directly adjust the carburetor's fuel/air mix, then switching to an electric car is going to be significantly more work as the interface between the engines is drastically different.  </p>"},{"location":"Getting_Started/DesignGuide.html#machine-built-from-layers-and-interfaces","title":"Machine Built from Layers and Interfaces","text":"<p>A machine can be programmed in single block of code.  It will be a nightmare to maintain, making adjustments will break existing functions, and virtually none of the code would be re-usable.  Every machine built in this manner starts from scratch.  Programming, as with any problem, is best solved by breaking it down into manageable pieces.  Dividing a problem into layers allows for abstraction (interchangeable parts), and breaking components up into various pieces makes it easier for multiple programmers to handle simultaneously.   Smaller components are more likely to be re-used.  Three levels appear to be about right number.  Machine, Equipment Module, Component.  The machine coordinates multiple Equipment Modules.  Equipment Modules coordinate multiple Components, and Components are made up of a series of base components where each performs a single specific function.</p> <p> </p> Code Hierarchy"},{"location":"Getting_Started/DesignGuide.html#abstraction","title":"Abstraction","text":"<p>One of the key reasons for having layers is abstraction.  This is the idea of \"I don't need to know how\" or \"I don't want to know how X works I just need it to go\".  For the car, \"I push on the gas pedal for the car to go\".  I do not care how it goes; my job is to deliver the pizza not to figure out how to burn fuel to turn the wheels. This is abstraction; nothing past the interface concerns me if it does what the interface says it will.  Give me a car and I will deliver the pizza.  It is up to the people building and maintaining the car to ensure that when the gas pedal is pressed, the car will go.  For the machine to \u201cdo something\u201d, it will issue commands to the Equipment Modules in whatever order is required for the machine to operate.  The machine also responds to the status of the Equipment Modules, if an equipment module has a problem, the machine will determine what all other Equipment Modules must do.  The machine only must deal with Equipment Modules.  The machine does not care which or how many Components the Equipment Modules have.   Equipment Modules can be exchanged for other Equipment Modules and the machine can deal with this easily.</p> <p>Abstraction can make things very efficient.  If all Equipment Modules have the same interface, IE they accept the same commands and return the same status, then equipment modules become interchangeable.  For example, A company has built two Unwind Equipment Modules, one using Servo Motors and one using DC motors, provided both Unwind Equipment Modules use the same interface, one can be replaced with the other without any changes to the programming of the machine.  The machine programmer can focus on coordinating the modules to make everything run, rather than wasting time figuring out how to get a module to perform its function.  </p> <p>Equipment Modules work with Components in the same way.  The Equipment Modules coordinate the Components to perform a machine function. The Equipment Module issues commands to the Components and monitors the status of the Components to perform the function requested by the Machine.  </p> <p> </p> Communication Between Layers <p>Interfaces between layers should be as standardized as possible.  For example, all axis\u2019 should have the same commands and status.  It would make no sense to have some axis to use the command <code>Reset()</code> to clear faults and another axis to use the function <code>ClearError()</code>.  It is far faster and simpler to build an Equipment Module if the Components have similar commands and status and it is faster and simpler to build the Machine if Equipment Modules have similar interfaces.</p>"},{"location":"Getting_Started/DesignGuide.html#implementing-interfaces","title":"Implementing Interfaces","text":"<p>There are many ways to implement interfaces, things like Variables, Methods, and Properties, but there is no single right way.  All roads lead to Rome.  The most important item is consistency.  All roads might lead to Rome, but planes, trains and cars do not mix.  Code should be written with the expectation that someone else (a user) will take the completed component and implement it.  The \u201cuser\u201d never has to look inside a component to have to get it to work.  If a user must look inside a block to figure out how to use it, the user will generally throw the block out and write a new one.  This new block now must be tested and debugged, a huge waste of time and money. Command Structures, Status Structures, Error Messages and Variable Naming should all be consistent between levels/modules.  Exceptions to the standard, or blocks of code that behave differently require more time to implement, have more errors, take more time to debug/commission, are less likely to be re-used, and at the end of the day cost more money. </p>"},{"location":"Getting_Started/DesignGuide.html#getting-started-machine-vs-equipment-module-vs-component","title":"Getting Started - Machine vs Equipment Module vs Component","text":""},{"location":"Getting_Started/DesignGuide.html#where-does-one-module-end-and-another-begin","title":"Where does one module end and another begin?","text":"<p>Determining what each level will do takes some time and must be well thought out.  This is the core design, think it through, time spent here saves time later.  </p> <p>What happens when the layers are not well defined, or the interface is not clear?</p> <p>Back to the Bank Machine example, there is an easy way to build a bank machine.  Take a box of money, embed it in concrete and put a bunch of unlocked combination locks next to it. Give the serial numbers and combinations of the locks to the bank.  To use the \u201cbank box\u201d.  The user goes to the \u201cbank box\u201d and phones the bank.  The user gives the bank their account number, pin, the serial number of the combination lock currently on the \u201cbank box\u201d, and how much money they want to withdraw.  The bank looks up how much money is in the box; how much money is in the account and says OK here is the combination to that lock.  Take your money, then take a new lock, and put it on the box.  The bank then subtracts the amount of money the user told them from their account balance and updates how much money is left in the box.  When the bank finally gets around to putting more money in the \u201cBank Box\u201d the balance will almost certainly be wrong.  At which point the \u201cBank Box Company\u201d says, \u201cIt\u2019s not my fault the user took out more money than they said they did, they didn't use it as described in the terms and conditions\"  When the components or layers are not properly defined and the responsibility of tasks is not correctly assigned, the phrase: \u201cX works fine, they didn\u2019t use X correctly\u201d is commonly heard.  If this is happening, either it is not clear how to use the interface, or the user of the component is performing tasks that the component should do itself. In the \u201cBank Box\u201d machine example the user and the bank are doing the \"Bank Box\u2019s\u201d tasks.   </p>"},{"location":"Getting_Started/DesignGuide.html#figuring-out-which-block-is-responsible-for-what-is-important","title":"Figuring out which block is responsible for what is important.","text":"<p>The problem \u201cyou are not supposed to take out more money than you said you would\u201d is easy to avoid when the bank box is responsible for dispensing the money and keeping track how much money is in the box.  After a bit of examination, anything happening inside the box should be the boxes responsibility.  The user should never be able to \"see inside\".  The Bank should not have to keep track of how much money remains in the box before approving the withdrawal.  The bank is worried about how much money is in the bank, not the box.  If the user needs to look inside the component to use the component, the interface is incomplete.  If someone needs to know how much money is in the box, the box should keep track of this and provide this value in the interface.  If the user needs to provide external logic/functionality to get the block to do what it is supposed to, the functionally is incomplete and tasks need to be re-assigned. </p>"},{"location":"Getting_Started/DesignGuide.html#what-should-each-layer-do","title":"What should each layer do?","text":""},{"location":"Getting_Started/DesignGuide.html#base-components-components","title":"Base Components / Components","text":"<p>Components are individual devices that perform a task, but they do perform a \u201cMachine function\u201d.  For example, a solenoid can move forward and back, and axis can spin and stop at a position, but these things are not a machine function.  An Equipment Module will implement Components such as Axis and Solenoids together with sensors, and other devices to perform a machine function such as a \u201cBack Gauge\u201d or \u201cUnwinder\u201d \u201cUnloader or \u201cFiller\u201d </p> <p>Components must be usable by any Equipment Module.  EG The Axis Component.  The Equipment Module function \u201cMove Back Gauge\u201d is implemented by commanding an \u201cAxis Component\u201d to go to a specific position.  The Axis Component itself has no idea that it is controlling a Back Gauge or a Spindle or a Tension Roller, it simply has commands like \u201cgo to position X\u201d The Equipment Module defines that this Axis Component is driving a Back Gauge. </p> <p>Only Components talk to Hardware. Why? Abstraction.  If only the Components talk to hardware, hardware can be replaced/exchanged without having to re-write the Equipment Module.  If a DC motor Component has the same interface and functions as a Servo motor Component, then inside the Equipment Module one can be swapped for the other without making any coding changes to the Equipment Module.  The Equipment Module\u2019s only concern is the command \u201cGo to position X\u201d results in the Position X being reached. Servo may be faster and more precise, but so long as it goes to position X, the Equipment Module doesn\u2019t care about the \u201cHow\u201d.  </p>"},{"location":"Getting_Started/DesignGuide.html#equipment-module-level","title":"Equipment Module Level","text":"<p>Equipment Modules, this is the important one, but it is also usually a more obvious one.  The machine will be set up mechanically into individual modules.  It is important to get the Equipment Module level right.   If the Equipment Module is too low level, it is like driving the car by adjusting the airflow and fuel injection.  The Machine level is doing things best done by the Equipment Module. Too high of a level and the Equipment Modules is doing too much work that the Machine should be doing. The car is doing everything including the navigation.  One key to getting Equipment Modules correct is; If this module is removed from the machine, which components need to be included to dry cycle it?  Can this module perform its function without other components?  Can it be removed or replaced?  An equipment module should perform a specific but complete function.  An Equipment Module should not talk directly to hardware.  It might need a sensors value and status, but a Component should be scaling the sensors value and monitoring the sensor to determine if the value is in an error range.   A system can have as many Equipment Modules as it needs. Equipment modules might be simple, or they might be complex.  </p>"},{"location":"Getting_Started/DesignGuide.html#machine-level","title":"Machine Level","text":"<p>Determining the scope of the machine level is straightforward, it is the top layer, and it is what drives all other components.  When a machine is provided with materials, it can complete its entire function. The machine however is not just the Main Program.  The machine will have to talk to an operator.  The Human Machine Interface (HMI) or Operator Interface is often a GUI (Graphical User Interface), but it does not need to be.  The Operator interface could be a push button and a light.  Eg to start, turn the key, wait for the green light then press the green button.  To stop it push the red button.  The main program may contain other programs to do other administrative tasks.  For example, there may be a program to exchange data with the Operator Interface / HMI.  There might be programs that connect to databases or IOT programs logging information etc.  The machine level program as far as this document is concerned is dedicated to running the machine.  The machine level block accepts commands, sequences the Equipment Modules, and reacts to alarms/errors of the Equipment modules. </p>"},{"location":"Getting_Started/DesignGuide.html#module-separation","title":"Module Separation","text":"<p>As stated, the programmer at each level is concerned with their level and only their level only, that is why the interfaces exist, they give a clear definition of where responsibility ends.  A module communicates only with one layer above and only with one layer below.  For example, the Equipment Module, the equipment module receives commands from the Machine Layer via it's inputs/method calls.  The Equipment Module then communicates to the Components which operate their hardware.  The Machine has no business communicating directly with a Component. This abstraction allows Components to be replaceable without requiring the machine to be re-written. Eg Replacing a Servo drive with a DC Motor in the Unwind. The Equipment Module simply says \u201cComponent\u201d run at this speed. The machine is none the wiser.     </p>"},{"location":"Getting_Started/DesignGuide.html#error-responseerror-propagation","title":"Error response/Error Propagation","text":"<p>Part of the separation of modules is the error handling. Compartmentalizing functions also means the errors can be compartmentalized.  Errors have different meanings at different levels, each level gives the error context.  \"Axis 5 lag distance fault\" is meaningless at the Machine Level.  The Machine wants to know, \u201cWas this error severe enough to stop the entire machine?\u201d and the operator wants to know \u201chow do I get back in operation\u201d.  When a Component has an error, it reports its specific error.  The Equipment Module sees the Component error and determines what it means for the Equipment Module and reports an Equipment Module Error.  The Machine sees the Equipment Module error and finally determines if the entire machine must be stopped or not.  Axis 5? Lag distance fault?  The back gauge is not in position.  Do not allow machining of the part to start, the part isn\u2019t in the right place.  </p> <p> </p> Error Propagation and Reaction <p>The complete sequence of error reporting and reaction is as follows:</p> <ol> <li>Components reports error to the Equipment Module</li> <li>Equipment Module determines the appropriate reaction for its other Components</li> <li>Equipment Module issued commands to the Components</li> <li>Equipment Module Reports the Equipment Modules Error to the Machine.</li> <li>Machine determines appropriate reaction for the other Equipment Modules</li> <li>Machine issues commands to all Equipment Modules</li> <li>Equipment Modules process the commands</li> <li>Equipment Modules issue commands to the Components</li> </ol> <p>For example, a Machine has an Equipment Module that is an X-Y table.  Within the equipment module are two Axis Components, X and Y.  The Component for the X-axis reports a lag distance fault.  The Equipment Module sees this lag fault on the X-axis, determines that the Y-axis should be stopped immediately; it stops the Y-Axis and reports to the machine that the X-Y table is no longer operational due to a problem with the X-Axis.  The machine sees that the X-Y Table is no longer functional and, in this case, determines that without the X-Y table nothing should operate.  The Machine commands all Equipment Modules to stop and cannot be re-started until the X-Y Table Error is fixed, and the operator is informed the entire systems stopped due to the X-Y Table. </p>"},{"location":"Getting_Started/DesignGuide.html#error-logging-vs-alarm-display","title":"Error Logging vs Alarm Display","text":"<p>Everything should be logged, but not everything should be displayed.  Each Module must log all its errors and timestamp it.  Logs are for Service and the Development Engineers; Alarms are how the machine tells the operator what needs to be done to run. Alarms must be clear and relevant, with the most urgent displayed first.  The operator will generally not be looking at the screen when the alarm was raised.  When the operator arrives at the machine it must be readily apparent where the problem lies and what to do.  Like everything, there are several ways to handle this.  This is an important topic some of the first things written in the Components will be the error/fault reporting.</p> <p>Following the error propagation sequence a root cause error at a component will generate 3 messages, one at the component, one at the equipment module, and one at the machine level. There are some options for handling this.  </p> <ol> <li> <p>Each module reports its own error and via ID numbering schemes it can be determined all 3 errors are associated and either the HMI or the PLC ties makes the association to tie them together.</p> </li> <li> <p>The lowest level module generating the error reports it, higher levels add information to the same alarm. </p> </li> <li> <p>Only the machine layer reports the errors.  The Machine layer knows \u201cis told\u201d via either configuration or programming of every possible message from the equipment modules and Components and manages them. This is often the \u201cold school\u201d way of doing things, every module/device provides a list of all possible errors and the machine and global error numbers are assigned. </p> </li> <li> <p>Component faults are captured by the equipment module and only the equipment module provides the alarm up to the machine.    </p> </li> </ol> <p>A traditional alarm handler looks through all the devices\u2019 errors and determines what to report.  With the core idea being modularity and interchangeability of components, this ends up being a duplication of effort.  Every module within the machine has already had to recognize and react to the alarm, now a full second set of logic must look thorough all the faults on all modules and determine what messages to display.  It can generally be surmised that the Component faults are the root cause but that may not be the case, if a safety system is tripped many components will fault and it can all happen in a single PLC cycle. Did the safety drop the power or did the power drop cause the safety system to trip?  Properly timestamping and raising the fault/error/alarm directly makes sequencing easy. </p> <p>Another option is alarms \u201cdrill down\u201d when looking at the machine layer, equipment module errors are displayed, when looking at an equipment module, errors from the local components are displayed.  X-Y table has an error, drill down to the X-Y table and the X axis jammed.  To see the X axis jammed, the operator will have to look at the X-Y table equipment module.  As Operators become more familiar with the machine, they will learn that the X axis lag distance fault means a jam they need to go fix.  The operator doesn\u2019t want to have to click on everything to see the root cause.  </p> <p>For modularity, it is very easy to have every device write to the list in the order things happen.  The problem is if there is text associated with each alarm.  This text must be translated; this means list of text must be exported/imported.  If each device has its own list, then a bunch of different lists need to be sent for translation.   This is not a significant problem, text for the messages can be stored in files or databases, but it must be managed.  If the text is handled by the HMI, then it will need to be provided with these files or databases so that it can perform the text lookup. </p>"},{"location":"Getting_Started/DesignGuide.html#errorfault-categorizationclassification","title":"Error/Fault Categorization/Classification","text":"<p>Regardless of the alarm handling methodology employed for modules are going to have unique faults and need to be readily identifiable and probably lots of them. Developing an error reaction to every single fault is not practical.  Fault Categorization/Levels can help with this.  To react to a fault, the severity of the fault is important, not the specific error message. Is the fault bad enough that this module must stop?  Do other components also need to stop?  Setting up Levels for faults greatly reduces the programming/implementation effort and ensures consistency between Modules. Note levels of the faults can also indicate how the fault should be reacted to.  EG Critical/Abort the Machine or Equipment Module must be stopped immediately. Cycle Stop faults allow the equipment module to \"finish\" but they cannot be restarted.  There seems to be no definitive standard on alarm categories and classes.  ISA 18.2 does cover alarms but for plant alarms with things like Category 1 is severe, risk of loss of entire plant or environmental contamination outside the facility a little beyond our scope.  Some systems implement 4 categories some recommend more.  </p> <p>The TwinCAT Event Logger logs 5 \"PC event types\" natively.   </p> <ol> <li>Verbose </li> <li>Info </li> <li>Warning</li> <li>Error</li> <li>Critical </li> </ol> <p>These categories could be used to determine the severity of the alarm or to differentiate between debugging/logging and errors and what the reaction should be.  Eg Critical means the module has aborted and cannot receive new commands.  </p> <p>Other systems use error categories that determine the course of action the machine should take. </p> <ol> <li>Critical/Immediate Stop/Abort the Module/Component cannot/does not function  </li> <li>Severe/Cycle Stop The Module should be stopped and not commanded again. </li> <li>Idle / machine functions hold preventing a next part to be started </li> <li>Hold/local condition.  The machine can function but is low on a material </li> <li>Suspend/External.  This Module/Machine is stopped waiting on other Modules/Machines from running.  </li> <li>Warning  Machine/Module operates but the user requires information about a condition that could lead to a higher category fault </li> <li>Info </li> </ol> <p>A traditional variation on the theme is to allocate X bits to each module for each level where each bit represents an error.  This makes some things easy, no bits set, no error but this only really works well up to 64 bits after that OR'ing multiple LWORDS gets complicated.  32 bits can be used to either represent 32 errors, or used as a UDINT, which can now represent 4.2 billion errors and via module ID's a scheme of errors can be configured to cover nearly every possibility.  One advantage of this methodology is that all errors can be displayed simultaneously any error that is active is reported.  If Error ID\u2019s are used, one possibility is the module only reports the first or highest priority error often this is the only one that matters.  A second option is the module could log to each error to an error handle as they appear even multiple errors in the same cycle.   The third option is that the Module contains a list of sufficient length to report all currently active errors. </p> <p>Regardless of the scheme is chosen, be consistent and clear the modules need to log their errors and keep track of their active errors so the alarm handler can report/acknowledge the alarms accordingly. </p> <p>Having levels/categories can make the equipment module and machine level programming significantly easier.  If category/level 1 faults mean the module will no longer work, then it's simple at the machine layer to say, for any level 1 error from this equipment module stop the entire machine.  Level one error from this module?  Finish the cycle and don\u2019t start a new one.    </p>"},{"location":"Getting_Started/DesignGuide.html#layout","title":"Layout","text":"<p>Once it is known what everything must do, how to implement it?</p> <p> </p> Module Hierarchy <p>Items at each level must talk to one level up and one level down.  All blocks, regardless of what they are communicate via an interface.</p>"},{"location":"Getting_Started/DesignGuide.html#interfaces","title":"Interfaces","text":"<p>As indicated before an interface is simply a defined way of two things interacting with each other.  For code, that means how a piece of code A talks to with another piece of code B.  A well-defined interface allows B to be replaced by C without requiring any changes to A.  Back to the earlier car example, the diesel car can be replaced by electric car and the Intern is still able to go pick up lunch.  Telling the Intern to take the skid steer  and go get lunch is a recipe for disaster.  This vehicle\u2019s interface is drastically different and requires specialized training.</p> <p>How do interfaces apply to PLC Code?  All functions, function blocks, and add-on instructions have an interface. The input, output, and in/out variables define the interface.  In TwinCAT 3 function blocks also have the capability of implementing Methods and Properties.  Methods and Properties have been a staple of nearly major programming languages since the 1970\u2019s.  Methods are functions/subroutines for the Function Block called by the user.  Methods are things that the Function Block can \u201cdo\u201d.  Method names should always be verbs. Properties are characteristics of the block, i.e. what the block \u201cis\u201d or \u201chas\u201d and should always be nouns.  Back to the car example, methods would be Accelerate, Decelerate, Turn Left, and Turn Right.  Properties would be things like Color, VIN Number and Number of seats.  For the Bank Machine, Properties would be things like \u201cCashInBox\u201d, and methods would be \u201cCallBank\u201d and \u201cDispenseCash\u201d.   </p> <p>For blocks to be interchangeable, they must use the same interface.  When building an interface, it needs to be determined what functionality must be provided and what data will be available.  Which methods and properties each block must support, and which variables will be passed in and out.  This process is a discussion, the user of the block and the builder of the block together need to determine what the interface will be.  There will be changes as deficiencies are found.    </p> <p>Point to Point axis Components should be interchangeable.  The ability to swap a stepper for a servo or a DC motor without changing the equipment module code is highly desirable. The same for the ability to swap one servo drive type/manufacturer for another.  Different hardware will do things in different ways.  The reset sequence for a stepper motor is very different from the reset sequence for a fieldbus connected servo motor.  The Equipment Module that asks for a reset, does not care about \u201chow\u201d the reset is done, it just wants a reset done.  Having separate Components that are interchangeable but \u201cperform the same function\u201d allows lower cost machine variation.  Some customers may be willing to pay for high performance servo axis and some customers would prefer lower cost stepper motors. The easier it is to swap Components the lower the engineering cost for modifications.  For example, a simple Point to Point axis block could have the following interfaces: </p> <p>Option 1: Methods, Properties, Inputs, Outputs and Var_In_Out</p> Method Property Input Output InOut (cyclic) Reset Position (mm) Enable Error Axis  Reference Move(Pos,Vel) Position (inch) Error ID Stop Busy Ready <p>The interface defines the rules for the Axis block.  The \u201cuser\u201d of the block reads the interface and knows what an axis can do, the person who builds the Axis block reads the interface and knows what features/functions to provide. If all different versions of axis blocks use the same interface, then anyone who knows how to use one axis block knows how to use all axis blocks regardless of whether it is a Linear, Servo, Stepper or Hydraulic axis.  Same interface, same usage, directly exchangeable.</p> <p>It is up to the company/programming team to define rules for creating interfaces.  Should all inputs and outputs should be handled by Methods and Properties, or via Input and Output variables or both? It is just as easy to write <code>Axis1.Reset := TRUE;</code> as it is to say <code>Axis1.Reset();</code>  The same for outputs, <code>Axis1.Error</code> or <code>Axis1.GetError()</code>. Position could easily be an output, instead of a property.</p> <p>Here are 4 more options for the PointToPoint Axis Block interface.  Each has its own advantages and disadvantages.  Choosing a consistent interface layout will key.  Options 3 and 5 below have special advantage in that they can be declared as a type \u201cInterface\u201d which is described in the next section. </p> <p>Option 2: Inputs and Outputs Only</p> Input Output Enable Position Inch Reset Position mm Move Error Move Position Error ID Move Velocity Busy Stop Ready <p>This is the traditional approach for function blocks</p> <p>Option 3: Methods and Properties Only</p> Method Property Reset Position Inch Move (Pos,Vel) Position mm Stop Error Enable Error ID Disable Busy Ready <p>Option 4: Inputs and Outputs with Command and Parameters</p> Input Output CMD Position Inch P1 Position mm P2 Error Abort Error ID Reset Busy Start Ready CMD Done <p>This Interface requires a documentation for what each CMD number is what the Parameters P1 and P2 represent for different commands.  For example, CMD = 1 could be a Move command  where P1 is position and P2 is Velocity.  CMD = 2 could be stop where P2 is the deceleration. </p> <p>Option 5: Methods and Properties with Commands and Parameters</p> Method Property Reset Position Inch CMD(P1,P2) Position mm Abort Error Error ID Busy Ready CMD Done <p>Just like Option 4, Option 5 would need documentation about what each command is and what the parameters do for each Command. </p>"},{"location":"Getting_Started/DesignGuide.html#interface-data-type","title":"Interface Data Type","text":"<p>For TwinCAT 3 there is an interface data type. Interfaces defined by a data type are much more rigid.  When a defined data type interface is implemented, all Methods and Properties MUST be included.  The code will not compile if a block implementing an interface does not do it fully.  All blocks implementing an interface data type will be interchangeable the compiler forces this.  This significantly improves the reusability and consistency of the code. </p> <p>Variable Inputs, Variable Outputs and Var_In/Outs are not included in the Interface data type, and therefore the compiler does not force the programmer to use the same variable names.  External documentation is required if programmers are to use the same variable names.  Someone must document what the interfaces are to be (this can be done directly in the code) and the rules must then be enforced when documented interfaces are not being followed.  \u201cYou didn\u2019t follow the interface.\u201d  \u201cYou changed the name of the Execute variable to Go.\u201d  \u201cGo back, look at the documentation and fix it\u201d.  When an Interface Data type is used, the code simply will not compile if the names of the properties and methods do not match to the declared interface.  Again, there is no right/wrong choice here, what is important is that all interfaces are designed in a consistent way.  Implementing some blocks with data type defined interfaces and others via variables, reduces readability, reduces re-usability, increases confusion, which ultimately requires more time/money than having a consistent system.  Two formats may be appropriate, Blocks using inputs and outputs for the interfaces must follow a specific set of rules, as new blocks must be property and method only and follow another set of rules.  Programming convention documents are not big documents, 3-5 pages is generally plenty. </p> <p>A second huge advantage of using a Type Declared Interface is the ability to \u201ccode against the interface\u201d.  When \u201ccoding against an interface\u201d the programmer can declare an instance of the interface and write all code using that interface only.  This is extremely advantageous when Interfaces have been defined but no code has been built.  The Equipment Module programmer can write all the code for a component before the Component is even started.  The interface says it has a reset command and when it is complete it will be done or have an error.  Eventually a Component that implements the interface will be completed.  When it is ready to us it, simply assign the instance of the block to an instance of the block.  Now all commands to the interface are issued to the actual block.  </p> <p> </p> I_Axis Interface <p>With such an interface, there can several axis blocks built for handling different hardware provided all axis blocks implement this interface, any axis block can be replaced with any other axis block and the higher-level program requires no changes.  Want to change a Stepper to a Servo?  Change one assignment statement or add an IF condition.</p>"},{"location":"Getting_Started/DesignGuide.html#extending-components","title":"Extending Components","text":"<p>One \u201csimple\u201d option to handle the challenge of interchangeable components is to build one block that can do \u201ceverything\u201d.  For the axis block example, a single block can be built that has various options.  The options would then indicate what hardware the block is to be connected to and what features it has.  It could have options for steppers, options for different servos and options for different functions. </p> <p>Great everything is in one block that can do \u201ceverything\u201d.  The problem is this block is never finished.  It is continually being updated and its interface is continually changing and there\u2019s so many options no one understands it.  For Example, A new very low-cost version of stepper motor was sold as an option for an existing machine.  It requires a digital output to enable it, and a digital output to reset it.  \u201cCheap Digital Stepper\u201d option is now added to the block, the block is given 2 more output variables, and the \u201cAxis Type\u201d which is likely an enumeration is extended for the new Cheap Digital Stepper type.  This block will require a lot of documentation.  When an instance of this block is created, it has every variable of every possible axis type included.  This causes confusion.  The same for if functionality is to be added.  \u201cWhy are these inputs and outputs not linked, oh those are only there in the case Axis X was a cheap stepper motor we used one time 6 years ago\u201d.   When a new type of Cam Table is developed, this functionality must be added into the \u201cdo everything\u201d axis block.  Now all blocks even ones that do not use the new cam table function will have to contain large cam tables.  If no one is taking care of ensuring this block is in a library there will end up being several partial complete versions of the block.  One version might allow stepper control but not the new cam table.  One might allow for a new cam table but not for a servo on fieldbus X.  </p> <p>The result is no one uses the \u201cdoes everything\u201d block because it\u2019s too complicated. </p>"},{"location":"Getting_Started/DesignGuide.html#start-small-and-extend-to-add-features","title":"Start Small and Extend to Add Features","text":"<p>Many blocks start with very high goals.  For this project a new Servo block will be built, it will be able to do point to point motion, flying shear functionality, and handle multiple cam table switching.  Every Axis in every project will use this block and all axis will have all possibilities. </p> <p>In reality, maybe 2 of the axis in a project will need Cam Table switching.  Someone is going to take a significant amount of time building this block.  Most axis will likely only need basic point to point motion, but this all this functionality needs to be programmed, tested, and debugged before anyone can use it. </p> <p>A better solution: Build a basic block for point-to-point motion.  This block has one function, point to point.  This block is great for any Equipment Module that needs point to point motion and doesn\u2019t require any information about a master axis.  This block is quick to build, test and debug and covers the basics, enable the axis reset the axis and move point to point, simple to build, simple to use. </p> <p>Axis that requires synchronization will also need point to point motion.  The point-to-point block can be extended.  The extended block contains everything the original has, it has an axis reference and point to point motion, components that have already been tested and work.  For synchronization it needs the master axis information.  When the block is extended a master axis reference is added, and basic camming/gearing can be added.  If an error is found is ever found in the point-to-point block, fixing it in the point-to-point block automatically fixes it in the extended Synchronization block.  If a \u201cShortest way\u201d option is added to the point-to-point block, it automatically appears in the Synchronization block.  The programmer of the extended block can focus on the extension knowing the rest already works.   </p> <p>This idea of small blocks and extension, results in the most code re-use.  The base axis from one project is now \u201cin demand\u201d for the next project because the block has been significantly tested and does not include things that are not necessary.  For point to point, it is perfect.  When the complexity is necessary, the Extended block is used.  However, when the complexity is not required the simple base block can be used without the \u201cclutter\u201d of unused functionality.  </p> <p>If the basic block was chosen, and later it\u2019s determined the extended block is necessary, no problem, switch the basic block for the extended version.  The Extended block still contains the basic block and all the existing code that used the basic block still works for the extended version. </p> <p>This is inheritance and this is probably the single most powerful feature available in TwinCAT 3.   Extending blocks is always available, even if Interface Data types are not used.  Blocks in libraries can also be extended.   The extended block cannot break the base block, it can only add to it and only the new functionality requires testing and debugging.  In the event the new block needs to change how a basic function works, the methods can be extended or overridden.  If the new block has new hardware and the reset must be different?  No problem, override the base block\u2019s Reset method to include the code for handling the new hardware.  </p>"},{"location":"Getting_Started/DesignGuide.html#define-the-functionality","title":"Define the Functionality","text":"<p>Now it is known which Equipment Modules and Components will exist and what the interfaces will look like, time to start writing code. </p> <p>Not so fast! Before writing a single line of code, either on paper or in a spreadsheet determine what functions the Machine each Equipment Module must be able to do in each mode of operation and what happens in the case of an error level of error of each Module.   Modules always has more than one mode of operation, it is going to require a manual mode for jogging axis after a jam, it may have a clearing mode to clear out partially completed products, and it will very likely have a dry cycle mode for operating without product.  Everyone (management) is always concerned about Automatic/Producing mode; this is theoretically, where the machine makes money.  This mode is important, but it is generally \"easy\" because everything is running.  All the other modes, functions, and features take time to build, and they need to be planned in at start.  Adding core functions later without planning has the most risk of \u201cbreaking\u201d components already completed. Create a Document/Spreadsheet that does the following: </p> <ol> <li>Defines all modes of operation of the machine and each equipment module.  It is common that different equipment modules will be in different operation modes at different times.  Putting a single equipment module into manual while the machine is in production is fairly standard. </li> <li>Determines what each Module must do in each mode </li> <li>Contains a list of what Errors can occur each Module (this list will be added to as construction progresses) </li> </ol> <p>Creating a table for each Equipment and Component and laying out the functionality in each mode does two things. </p> <ol> <li>It provides a complete scope of work of how many functions really must be implemented </li> <li>It clarifies the operation of the entire machine.</li> </ol> <p>If the machine is built without a full plan, after the machine produces the first product comes the statement, \"Great that works. Now during product change over before we load a new material, these two axis\u2019 have to decouple and this one has to stop in order to release tension here.\"  Whoa, wait, what?!?  If I had known that I would have done all this slightly differently to accommodate that. Patching in unplanned functionality later typically causes the most unintended consequences.  After patching in the new function, the next problem report is, \"Uh, somehow while running the machine the operator started the load process, that decoupled the axes, released the tension, the film wrapped around the dancer and bent the arm, we need a new part machine will be down for a week\".  </p> <p>Laying out the functionality for each Module takes time, it may take a couple of days or a week or more depending on the complexity of the machine.  However, when completed the project timeline will be more accurate, it will save days/weeks of effort at the end of the project when time is most precious.  The phrase \"If we knew that, we would have done this instead\" is a huge problem before run off.  Now comes the debate, re-do a major component, which will prevent the machine from running until it is completed, or try to somehow shoehorn in the extra functionality. Usually, the shoehorn method is employed until it's finally determined that the block must be re-built, and even more time is lost. </p> <p>Producing mode is important but the customer only complains when the machine is not producing.  The end user paid for production mode, every minute the machine is not in production mode is costing money, getting the machine back into production quickly is where the money is.  </p> <p>There will be a sequence to start up the machine and there will be different functionality in different modes of operation.  Commissioning, Maintenance, unsticking things after a jam, there's a lot of functionality needed that is not \"automatic production\".  No problem, build a Mode handling and a state machine to help ensure functions from Manual mode are not accidentally triggered in Automatic mode.  There are now two options, come up with your own Mode and State sequencing system, or follow a standard.  For those who build/have their own Mode/State handling system, that is perfectly acceptable.  Doing it your own way comes with the task of building/debugging your system, documenting your mode/state handling system, and teaching your system to other programmers, service people, and the end user.  Having the ability to say this machine conforms to ISA TR88.00.02 makes things a lot simpler. The TR88.00.02 Implementation guide from OMAC describes the implementation of TR88 very well. </p>"},{"location":"Getting_Started/DesignGuide.html#style-guide","title":"Style Guide","text":"<p>The style guide for the SPT framework follows the rules setup in the static analysis.  </p>"},{"location":"Getting_Started/DesignGuide.html#naming-conventions-prefixes","title":"Naming Conventions - Prefixes","text":""},{"location":"Getting_Started/DesignGuide.html#instance-variables","title":"Instance Variables","text":"<p>Only instances of pointers and interfaces use a prefix in the SPT Style guide. </p> Type Prefix Example Pointer p <code>pTest : POINTER TO INT;</code> Interface ip <code>ipComponent : I_ComponentBase;</code>"},{"location":"Getting_Started/DesignGuide.html#datatypes","title":"Datatypes","text":"Type Prefix Example Function Block FB_ <code>FUNCTION_BLOCK FB_BasicAxis EXTENDS FB_CyclicFB IMPLEMENTS I_BasicAxis</code> Function F_ <code>FUNCTION F_CreateAllEventsInClass</code> Interface I_ <code>I_BaseFB</code> Structure ST_ <code>TYPE ST_ComponentBase_HMI :</code> Enumeration E_ <code>TYPE E_AlarmResponse :</code> Union U_ <code>Union U_WordToBit :</code> Alias T_ <code>TYPE T_Message : STRING[50];</code><code>END_TYPE</code>"},{"location":"Getting_Started/DesignGuide.html#naming-conventions-variable-names","title":"Naming Conventions - Variable Names","text":"<ul> <li>Pascal Case <ul> <li>All starting words are capitalized except where p or ip are used as prefixes</li> <li>Each new compound word is capitallized</li> </ul> </li> <li>NO Hungarian notation!!!</li> <li>Use whole words instead of acronyms or shortned words when possible</li> </ul> Example <p>The variable <code>LPotSw</code> means nothing to a new set of eyes. Whereas the variable <code>PositiveOvertravelSwitch_Left</code> does mean something to a new set of eyes.</p>"},{"location":"Getting_Started/DesignGuide.html#local-variables-as-properties","title":"Local Variables as properties","text":"<p>Where local variables are to be used outside of a function block, we create the variable name in the function block with an underscore prefix.  Then the name of the property get/set is the variable name without the underscore.</p> <p>Example:</p> <p></p> <p></p> <p></p> <p></p>"},{"location":"Getting_Started/Getting_Started.html","title":"What is PackML?","text":"<p>According to the OMAC website - PackML is an automation standard developed by the OMAC and adopted by ISA as TR88.00.02 that makes it easier to transfer and retrieve consistent machine data. The primary goals of PackML are to encourage a common \u201clook and feel\u201d across a plant floor, and to enable and encourage industry innovation.</p> <p>What are the building blocks of PackML?</p> <p> </p> Module Hierarchy"},{"location":"Getting_Started/Getting_Started.html#machine-module-equipment-modules-and-components","title":"Machine Module, Equipment Modules, and Components","text":"<p>A manufacturing line will consist of multiple machines; for our purposes, a machine is defined by the presence of a single PLC. Each machine is made up of 0 or more equipment modules. Most machines will contain several equipment modules, but it is important to understand that a machine does not have to have any equipment modules. An equipment module is typically recognized by a single process of a machine. This could be some sort of de-stacker or infeed, a bag filler, or a palletizing system. Each equipment module is made up of components. These components are typically the hardware that work together as a single piece of equipment on the machine. For example, the cylinders, valves, and heating elements required to seal a bag, or the servo motors and actuators within a section of a distribution conveyor.</p>"},{"location":"Getting_Started/Getting_Started.html#what-are-the-modes-defined-by-packml","title":"What are the Modes defined by PackML?","text":"<p>The PackML standard defines 4 modes, but also allows for the user to define their own. The defined modes are Invalid, Production, Maintenance, and Manual. A complete machine can be developed with only the use of the Production Mode. However, the other modes can be used to best describe the group of possible states. It could be that a Manual Mode does not include the Suspended and Held paths, and the Maintenance Mode includes the Held path but not the Suspended path. These choices are completely left to the developer and how they choose to design the machine. There are a total of 32 possible modes, these can be used for a variety of scenarios such as a test mode that has a defined Complete command to leave the Execute state after a test is completed, or a warmup mode could be created to keep the machine in the Execute state until it\u2019s ready.</p>"},{"location":"Getting_Started/Getting_Started.html#what-is-the-packml-state-machine","title":"What is the PackML state machine?","text":"<p>PackML defines modes of operation and the possible states within each mode. A complete machine can be developed using only the production mode. The states are grouped into areas defined by their functionality. Typically, a machine will power on and go through the Aborting state to Aborted, these same states can be used for fault handling. Understanding the diagram and the areas is important. When a machine is in Execute there are four possible paths. A Suspend command will be issued when an upstream or downstream dependency is not met. This could be the previous Equipment module has run out of material or possibly faulted. The other 3 paths are Hold, Abort, and Stop. The Hold and Stop commands are issued by the operator, while the Abort command is given by the code. There are two types of states, Acting and Wait. The \u2018ing\u2019 states are the Acting states. Aborting, Clearing, Stopping, Holding, etc. These states are entered because a command was given to do so. An Estop might cause an Abort command to be issued that will place the state machine into Aborting, or when the operator presses the Start button the command will be given for the state machine to move to the Starting state. Each of these acting states is followed by a StateComplete that is determined by the code and then transitions to a Wait state such as Stopped, Idle or Held. The Execute state is the exception to this as it is defined as an Acting state, but uses the StateComplete of the Starting state to enter and requires a command to leave.</p> <p> </p> PackML States <p>Changing modes can only be done in certain states. Stopped, Aborted, Completed, and Held. If a mode change is required the machine must be in one of the states, and the mode that is being requested must also have this state. And while the states available within a mode can be defined there are a minimum set of required states that every mode must support. Aborted, Stopped, Idle, and Execute. Of these states only Aborted and Stopped allow for a mode change.</p> <p> </p> PackML Command and Status"},{"location":"Getting_Started/Getting_Started.html#command-and-status-down-and-up","title":"Command and Status, down and up","text":"<p>The Machine Module will be the commander of all its Equipment Modules, and it will also respond as needed when an Equipment Module reports an error. During normal operation the code in the Machine Module will send a state change command to each of the Equipment Modules, and they will report back to the Machine Module once the requested state has been reached. When a fault occurs the equipment module will handle the fault according to how it is programmed to do so. Typically, this would involve commanding itself into the Aborted state. The Machine Module will detect this state change and respond accordingly. It could be that other Equipment Modules need to be Suspended while waiting for the faulted module to be cleared, or it could be that some modules need to also fault or suspend due to dependencies on the module that originated the fault. By using the Machine Module as the commander and coordinator of the events the design of the machine code can be very flexible.</p>"},{"location":"Getting_Started/Getting_Started.html#what-is-the-spt-framework","title":"What is the SPT Framework?","text":"<p>The SPT framework utilizes the PackML libraries in order to allow for a defined set of states in which the control code can be organized. A key element of developing machine control is ensuring that the correct commands are given at the proper time and coordinated with the other parts of the machine. It is also important to ensure that commands are not given at an incorrect time.</p>"},{"location":"Getting_Started/Getting_Started.html#libraries","title":"Libraries","text":"<p>The functionality of PackML state machine requires the Tc3_PackML_V2 library. The SPT Framework is built on top of this library to aid in rapid code development. The 4 SPT libraries are SPT Base Types, SPT Components, SPT Event Logger, and SPT Utilities. The SPT Base Types library contains the core of the SPT Framework, the function blocks contained within will be extended to allow the machine code to interact with the PackML state machine. The SPT Components library holds some prewritten components for various sensors and actuators, including servos. The SPT Utilities library contains small pieces of code that are often repeated in the development of larger projects; for example: Analog Scaling, Data Buffers, and Comparators. Lastly the SPT Event Logger is a wrapper around the Tc3_EventLogger that is tailored to be used within the SPT Framework.</p>"},{"location":"Getting_Started/Getting_Started.html#cyclic-logic-vs-single-method-calls","title":"Cyclic Logic vs Single Method Calls","text":"<p>The framework uses Methods to call specific pieces of the code, such M_ExtendCylider or M_ResetAxis. These methods can be called once as needed, or multiple times until the requested command has completed or faulted. Additionally, the framework uses methods to call commands during specific states. For example, any code that needs to be executed while a Module is in the Resetting state can be placed in the Resetting method and it will be called at the proper time. The framework also makes use of Cyclic method calls to update the parts of the code that are responsible for monitoring changes, such as alarms, faults, and state changes made by other methods. These also provide a way to cyclically call and update all of the Modules and Components that have been registered to a higher-level module.</p>"},{"location":"Getting_Started/Getting_Started.html#does-a-component-need-an-em","title":"Does a Component need an EM?","text":"<p>So far, the hierarchy has been explained as Machine Module, Equipment Module, and Component. A Machine is made up of one or more pieces of Equipment, and Equipment is made up of Components. But it could be that a Machine itself has a component, such as a stack light, that indicates the overall status of the machine. Therefore, it is important to be aware that an Equipment module is not always required, and a Machine Module can have a direct connection to a Component.</p>"},{"location":"Getting_Started/Getting_Started.html#what-is-a-submodule","title":"What is a Submodule?","text":"<p>The PackML standard defines only Machine, Equipment, and Component. However there has occasionally been a need or a request to organize machines with multiple levels of Equipment Modules. To accommodate this the SPT Framework uses the term Submodule instead of Equipment Module. This allows for some flexibility in the layout of the architecture so that a Machine can have one or more Submodule (and 0 or more Components), and then a Submodule can also have one or more Submodules and 0 or more Components. In theory there is no end to the number levels that can be obtained with this architecture. However, the use of more than 3 levels (MM, EM, and Component) is highly discouraged and should only be used when having a Submodule of a Submodule truly is the best option.</p>"},{"location":"Getting_Started/Getting_Started.html#inheriting-the-base-classes","title":"Inheriting the base classes","text":"<p>When creating a Module or Component they must inherit the functionality of the base classes in the SPT Framework libraries. FB_PackML_BaseModule will be inherited by the Machine Module and all submodules. FB_ComponentBase will be inherited by all components. This will allow all of the modules and components to have everything they need to interact with the PackML state machine and the SPT Framework.</p>"},{"location":"Getting_Started/Getting_Started.html#registering-an-em-or-component-with-its-higher-level-module","title":"Registering an EM or Component with its higher-level Module","text":"<p>In order for the Cyclic updates to happen properly, a SubModule or Component must be registered with its higher-level Machine Module, or Submodule. The Variable name of each, that is declared must be passed into an array that will initialize it with the module.</p>"},{"location":"Getting_Started/Getting_Started.html#creating-the-array-of-interfaces-for-submodules-and-components","title":"Creating the array of interfaces for submodules and components","text":"<p>Registering Modules and Components is done using an array of interfaces. Within each Machine and Submodule there will exist the declaration of the SubModules and Components of that Module. Each of these instance variables will be used as the initial value of an index within the array. For example, this Machine Module contains three Equipment Modules referred to as SubModules in the code.</p> <pre><code>FUNCTION_BLOCK FB_Machine EXTENDS FB_PackML_BaseModule\n// Sub Modules\nPullWheels : FB_PullWheel;\nSealer : FB_Sealer;\nUnwind : FB_Unwind;\n//Initial List of SubModules\nipSubModules_Init : ARRAY[1..Parameters_PackML_Base.MAX_NO_OF_SUBMODULES] OF I_PackML_BaseModule := [PullWheels, Sealer, Unwind];\n</code></pre> <p>The three modules (PullWheels, Sealer, and Unwind) are all function blocks that extend the FB_PackML_BaseModule which Implements the I_PackML_BaseModule; therefore, they can be passed into the array of I_PackML_BaseModule as initial values. Understanding how this works internally is not important, what is important is remembering to place each instance variable name in the array initialization. When creating components, the same process is used, the only difference is that the components Extend FB_ComponentBase which Implements I_ComponentBase and the array is of type I_ComponentBase.</p> <pre><code>FUNCTION_BLOCK FB_PullWheel EXTENDS FB_PackML_BaseModule\nLeftPullWheel : FB_Component_BasicSlaveAxis := (Name := 'Left');\nipComponents_Init : ARRAY[1..Parameters_PackML_Base.MAX_NO_OF_COMPONENTS] OF I_ComponentBase := [LeftPullWheel];\n</code></pre>"},{"location":"Getting_Started/Getting_Started.html#overriding-methods-of-the-base-class","title":"Overriding methods of the base class","text":"<p>The SPT Framework contains a complete set of function blocks to run the state machine. FB_PackML_BaseModule has a method for each of the PackML states. Each of these methods has the code needed progress the state machine. When adding a new Equipment module that will extend FB_PackML_BaseModule, call the same methods with their unique code and call the method in the base using SUPER^.Method() or SUPER^.Resetting within your Resetting method. The use of SUPER will call the method of the base class and run the code that exists there. The typical implementation would call SUPER at the end of the method in the EM. If a method is not needed by an Equipment Module, then there is no need for the EM to call that method. At the Machine module level unless you need to override the method, DON\u2019T. Just let the CyclicLogic method handle it. Additionally, while it is common to override the CyclicLogic method when inheriting from a library in the base class, it is not required to do so. If you do not override the CyclicLogic method the underlying code for the method will be executed.</p>"},{"location":"Getting_Started/Getting_Started.html#when-to-call-statecomplete-vs-supermethod","title":"When to call StateComplete() vs Super^.Method()","text":"<p>The Acting states are exited when the StateComplete method is called. This is done in base class for you when you call SUPER^.Method(). It could be that you wish to call the StateComplete method from the EM, and that can also be done. The waiting states are exited when a change state command is given, for example ipModule.ChangeState(Tc3_PackML_V2.E_PMLCommand.ePMLCommand_Stop) or ChangeState(E_PMLCommand.ePMLCommand_Unsuspend)</p>"},{"location":"Getting_Started/Getting_Started.html#initializing","title":"Initializing","text":"<p>Each Machine and Equipment module has a CyclicLogic method, and that method should call the method of the base class using Super^.CyclicLogic(). An Initialize method is also required. The first lines of code in the CyclicLogic method are to call to the Initialize method if it has not completed.</p> <pre><code>METHOD PUBLIC Cyclic Logic\n</code></pre> <pre><code>IF NOT _InitComplete THEN\n    _InitComplete := Initialize();\n    RETURN;\nEND_IF\n</code></pre> <p>The Initialize method is used to register the submodules and components to the internals of the framework. A CASE statement is used to ensure that everything happens in the proper order.</p> <pre><code>METHOD PROTECTED Initialize\n</code></pre> <pre><code>Initialize := FALSE;\nCASE DescendantSequenceState OF\n    0:\n        // Define the interfaces to the different subunits (Must take place before SUPER^.initialize call)\n        FOR i := 1 TO SPT_BaseTypes.Parameters_PackML_Base.MAX_NO_OF_SUBMODULES DO\n            ipSubModules[i] := ipSubModules_Init[i];\n        END_FOR\n\n        FOR i := 1 TO SPT_BaseTypes.Parameters_PackML_Base.MAX_NO_OF_COMPONENTS DO\n            ipComponents[i] := ipComponents_Init[i];\n        END_FOR\n\n        _LogModeChanges         := FALSE;\n        _LogStateChanges        := FALSE;\n        DescendantSequenceState := DescendantSequenceState + 10;\n</code></pre> <p>The SUPER^.Initialize method must also be called as the last step of the CASE statement.</p> <pre><code>    30:\n        //Call the Super\n        IF SUPER^.Initialize() THEN\n            DescendantSequenceState := DescendantSequenceState + 10;\n        END_IF\n    40:\n        Initialize := TRUE;\nEND_CASE\n</code></pre>"},{"location":"Getting_Started/Getting_Started.html#what-is-a-control-source","title":"What is a Control Source","text":"<p>A control source is used to provide a connection from outside of the PLC code to the State Machine. This could be through physical buttons, an HMI, or an OPC connection to another machine. The base library (SPT Base Types) contains an instance of FB_ControlSource. This function block can be overridden as needed. The most important part for implementation is to provide code for the Cyclic Logic method. The Cyclic Logic method contains 3 major parts.</p> <ol> <li>The R_TRIG that captures the incoming command.</li> <li>The monitoring of the permissives that will allow or prevent a state change based on the current or other machine conditions.</li> <li>The monitoring of the commands and permissives to call the ChangeState method with the proper state.</li> </ol>"},{"location":"Getting_Started/Getting_Started.html#registering-the-control-source-with-the-machine-module","title":"Registering the Control Source with the Machine Module","text":"<p>The Initialization method of the Main POU needs to register a control source with the Machine Module.  In the below example ControlSource_HMI is the instance name of the control source function block, and VFFSDemo is the instance name of the Machine Module function block.</p> <p><pre><code>    ControlSource_HMI : FB_ControlSource;\n    VFFSDemo          : FB_Machine := (Name := 'VFFS Demo');\n</code></pre> <pre><code>    IF NOT ControlSource_HMI.Registered THEN\n        VFFSDemo.RegisterExternalController(ControlSource_HMI);\n    END_IF\n</code></pre></p>"},{"location":"Getting_Started/Getting_Started.html#testing-the-code-and-the-state-machine","title":"Testing the code and the state machine","text":"<p>At this point it should be possible to Activate Configuration, Restart TwinCAT in Run Mode, and test the code for proper functionality.</p> <p>Once the PLC is running you can login and check a few online values. Within MAIN, expand the declaration of your FB_Machine and check the values of the following variables: <pre><code>_CurrentMode        ePMLUnitMode_Production\n_CurrentState       ePMLState_Aborted\nNumberOfSubModules  //This value should be equal to the number of Submodules declared within your instance of FB_Machine. If not then check the declaration of the ipSubModules_Init ARRAY\nNumberOfComponents  //This value should be equal to the number of Components declared within your instance of FB_Machine. If not then check the declaration of the ipComponents_Init ARRAY\nInitComplete        TRUE\n</code></pre> Once those values have been confirmed you can use your Control Source the test the state machine.</p>"},{"location":"Getting_Started/Getting_Started.html#adding-parameters-recipe-values","title":"Adding Parameters / Recipe Values","text":"<p>Parameters and Recipe values can be declared and passed to SubModules or Components through the use of Properties. Starting with a local variable of a Component that is read adn written by a Property, the Component can then use the local variable name as if it was the actual value. When a SubModule creates an instance of the Component the SubModule is then responsible for setting the value of the Property in the Component. </p>"},{"location":"Getting_Started/Getting_Started.html#adding-more-equipment-modules-submodules","title":"Adding more Equipment Modules (SubModules)","text":"<pre><code>Create a new function block that Extends FB_PackML_BaseModule\nAdd the Local variables and Properties needed for parameters\nAdd the Methods needed for the Acting and Waiting states\nAdd the Cyclic Logic method if needed\nAdd the Initialize Method\nWithin the EM declare any Components and add them to the  ipComponents_Init ARRAY\nWithin MAIN, declare an instance of the new EM and add it to the ipSubModules_Init ARRAY\n</code></pre>"},{"location":"Getting_Started/Getting_Started.html#creating-components","title":"Creating Components","text":"<pre><code>Create a new function block that Extends FB_ComponentBase\nAdd the Local variables and Properties needed for parameters\nAdd methods as required to perform the function of the component\nAdd the Cyclic Logic method if needed\nAdd and events or alarm logic\nAdd the Component to a SubModule, register it, and implement it within the SubModule, including ant parameters that need to be passed to it.\n</code></pre>"},{"location":"Getting_Started/PackML%20Overview.html","title":"PackML Overview","text":""},{"location":"Getting_Started/PackML%20Overview.html#what-is-packml","title":"What is PackML?","text":"<p>According to the OMAC website - PackML is an automation standard developed by the OMAC and adopted by ISA as TR88.00.02 that makes it easier to transfer and retrieve consistent machine data. The primary goals of PackML are to encourage a common \u201clook and feel\u201d across a plant floor, and to enable and encourage industry innovation.</p>"},{"location":"Getting_Started/PackML%20Overview.html#what-are-the-building-blocks-of-packml","title":"What are the building blocks of PackML?","text":"Module Hierarchy"},{"location":"Getting_Started/PackML%20Overview.html#machine-module-equipment-modules-and-components","title":"Machine Module, Equipment Modules, and Components","text":"<p>A manufacturing line will consist of multiple machines; for our purposes, a machine is defined by the presence of a single PLC. Each machine is made up of 0 or more equipment modules. Most machines will contain several equipment modules, but it is important to understand that a machine does not have to have any equipment modules. An equipment module is typically recognized by a single process of a machine. This could be some sort of de-stacker or infeed, a bag filler, or a palletizing system. Each equipment module is made up of components. These components are typically the hardware that work together as a single piece of equipment on the machine. For example, the cylinders, valves, and heating elements required to seal a bag, or the servo motors and actuators within a section of a distribution conveyor.</p>"},{"location":"Getting_Started/PackML%20Overview.html#what-are-the-modes-defined-by-packml","title":"What are the Modes defined by PackML?","text":"<p>The PackML standard defines 4 modes, but also allows for the user to define their own. The defined modes are Invalid, Production, Maintenance, and Manual. A complete machine can be developed with only the use of the Production Mode. However, the other modes can be used to best describe the group of possible states. It could be that a Manual Mode does not include the Suspended and Held paths, and the Maintenance Mode includes the Held path but not the Suspended path. These choices are completely left to the developer and how they choose to design the machine. There are a total of 32 possible modes, these can be used for a variety of scenarios such as a test mode that has a defined Complete command to leave the Execute state after a test is completed, or a warmup mode could be created to keep the machine in the Execute state until it\u2019s ready.</p>"},{"location":"Getting_Started/PackML%20Overview.html#what-is-the-packml-state-machine","title":"What is the PackML state machine?","text":"<p>PackML defines modes of operation and the possible states within each mode. A complete machine can be developed using only the production mode. The states are grouped into areas defined by their functionality. Typically, a machine will power on and go through the Aborting state to Aborted, these same states can be used for fault handling. Understanding the diagram and the areas is important. When a machine is in Execute there are four possible paths. A Suspend command will be issued when an upstream or downstream dependency is not met. This could be the previous Equipment module has run out of material or possibly faulted. The other 3 paths are Hold, Abort, and Stop. The Hold and Stop commands are issued by the operator, while the Abort command is given by the code. There are two types of states, Acting and Wait. The \u2018ing\u2019 states are the Acting states. Aborting, Clearing, Stopping, Holding, etc. These states are entered because a command was given to do so. An Estop might cause an Abort command to be issued that will place the state machine into Aborting, or when the operator presses the Start button the command will be given for the state machine to move to the Starting state. Each of these acting states is followed by a StateComplete that is determined by the code and then transitions to a Wait state such as Stopped, Idle or Held. The Execute state is the exception to this as it is defined as an Acting state, but uses the StateComplete of the Starting state to enter and requires a command to leave.</p> PackML V3PackML V2 <p></p> <p></p> <p>Changing modes can only be done in certain states. Stopped, Aborted, Completed, and Held. If a mode change is required the machine must be in one of the states, and the mode that is being requested must also have this state. And while the states available within a mode can be defined there are a minimum set of required states that every mode must support. Aborted, Stopped, Idle, and Execute. Of these states only Aborted and Stopped allow for a mode change.</p>"},{"location":"Getting_Started/PackML%20Overview.html#deciding-which-states-are-needed","title":"Deciding which states are needed","text":"<p>It is not required that all states be called from the machine module or submodule. For example, if a submodule has no work to perform in the Clearing state, then there is no need to call that method. When designing the architecture of the code it will be important to define which states are required for each submodule. Once the states have been decided and the functionality that will exist in each state defined then the methods can be added to override the methods of the base class.</p>"},{"location":"Getting_Started/PackML%20Overview.html#custom-modes","title":"Custom Modes","text":"<p>A common argument on why not to use TR88.00.02 is often stated, there\u2019s too much there\u2019s too many states and I don\u2019t need all of them.  There are too many states, too many tags and either I have a lot of other modes, or only one mode of operation.  A feature of TR88.00.02 that is often overlooked is custom modes.  There\u2019s a minimum set of tags, and a minimum set of states.  This is intended by the standard to make the system as lightweight as possible. </p> <p>My layout starts like this and lets see what we can remove </p> <p> </p> PackML Full State Machine <p>To determine what modes are necessary we can start asking questions </p> <p>Is \u201cComplete\u201d required? Is there a situation where I have multiple items in process need to run out before stopping? No this machine operates on one \u201citem\u201d at a time, its either empty or has one.  OK get rid of completing and complete they make no sense </p> <p>Do I need suspend?  Does the machine have sensors to determine if it is starved from upstream or blocked downstream? No Can the machine stay in Execute when empty?   Yes Suspend is not necessary, the machine can sit in execute or be stopped Remove Suspending/Suspended/Unsuspending </p> <p>Do I need Held?  Is there anything the operator must do to keep the machine in execute?  IE if the operator does not refill something the machine will run out and stop? No there is nothing to be re-filled/replaced/removed while in operation.  No held is required, the machine can always sit in execute  If there are things to be refilled/replaced, then Held would be required as the machine cannot stay in Execute if the operator has not performed a task. </p> <p>We\u2019re getting down to a pretty small state machine now, basically down to as many states as manual has.   </p> <p> </p> PackML Limited State Machine <p>There\u2019s still some work to be done </p> <p>Is Aborting required?  Are there any things I need to \u201cramp down\u201d or can I simply shut everything off?  If so, aborting isn\u2019t needed go to abort shut everything off </p> <p>Is Stopping required?  If I don\u2019t need aborting I most likely don\u2019t needs stopping, again is there a specific sequence that takes some time to complete? If not, stopping can be removed </p> <p>Is Resetting required?  Do certain devices have to start up in a certain sequence?  Can I simply \u201cenable them\u201d in Idle and leave them enabled? If I can </p> <p>Clearing?  Is there a sequence that has to happen in clearing or can I sit in Stopped and perform the clear? </p> <p>If this is all that\u2019s necessary we\u2019re down to the minimum set of states </p> <p> </p> PackML Minimum State Machine <p>States and 4 commands between states is the smallest allowed machine configuration this would be ideal for an inspection system </p> <p>If the machine is a vison inspection system nothing more is needed.  Turn the machine on and it\u2019s in aborted.  Clear any faults on the screen and its in stopped. Reset to go to idle and enable the motor for the belt  Start to get to execute and run the belt.  Nothing more is required. </p> <p>The machine sits in Execute waiting for parts/pieces to arrive, when they arrive, they are processed.  No parts, no problem sits in execute.  More states are not necessary, but fewer states is problematic.  It is important to differentiate between a requested stop and an error/unrequested stop.  It is also desirable to have an Idle state with components enabled but no motion.  Abort and Stop mean different things to the line controller.  On an Abort, the line controller may need to abort machines up/downstream but on a stop it may simply put them into stop or suspend. </p> <p>Even though there are only 4 states a second mode other that producing may be required.  For example, there\u2019s a calibration mode, where a series of self tests are completed.  Accidentally receiving parts in this calibration mode could be very problematic and almost certainly result in a false calibration.   Sure in Execute an \u201cif calibrate, stop motor\u201d is possible, but the whole idea of states and modes is to ensure there is no accidental way to perform a function from one mode that must not happen in another mode.  Switching to a calibration mode, helps to ensure different code is called and sequences for the calibration function cannot occur during production and production cannot occur during calibration.  </p> <p>A labelling machine likely needs at least one more state, Held.  Labels/Ink are not infinite and often require refilling from an operator.  As indicated earlier, stop and particularly abort mean different things to the line controller.  A labeller that is without label cannot be in execute but it also does not require to enter stopped state, a held state should be used here.  The machine is \u201cheld\u201d when it is out of labels, but when refilled can immediately restart operation without running through resetting.  A suspend may still not be required as if no products show up no labels are place.  </p> <p>If machine should offer a low power state that if no products are arriving or an output buffer is full, then a suspend state is beneficial the machine can enter/exit suspending without operator intervention. </p> <p>Add as many states/modes as necessary to fulfil all machine functions but states can be eliminated when they are not necessary. </p>"},{"location":"Getting_Started/PackML%20Overview.html#custom-modes_1","title":"Custom modes","text":"<p>For sub devices, such as equipment modules it may be desirable to make even smaller state machines.  The minimum state set is for machine modes at the top layer.  Below that, TR88.00.02 has no influence.  It makes sense to use modes and states with equipment modules but an even smaller subset of states can be used. </p> <p>For example Aborted, Idle, Execute, and Completed might be enough.  If faulted, Clear to get to Idle, to perform a function Start and Execute, when the function is finished go to Completed, to trigger another sequence Reset to get back to Idle.</p> <p>Why can\u2019t I simply have Idle, Execute and Aborted?  Prior to the 2022 version of the standard this was problematic.   Execute automatically completes and issues a state change, if Completed doesn\u2019t exist, it goes right back to Idle.  Sounds like it does exactly what I want, however:   When you command Start, you are in Idle, and when you check again you are in Idle.  Now the question is, is the device in Idle because it performed the function or is it in Idle because Execute has not started yet?  In TR88.00.02-2022 this was addressed getting out of Execute can now be accomplished with the command Complete.  This now gives the full handshake necessary.  Command Start, wait for Execute, command Complete, wait for Idle, and then command Start again.  Aborted, Execute and Idle will function without any other handshakes required, switching the command from Start to Complete and the state changes from Idle to Execute completes the handshake.  State Idle with command Complete means the last cycle finished.</p> <p> </p> PackML Command and Status"},{"location":"Getting_Started/PackML%20Overview.html#command-and-status-down-and-up","title":"Command and Status, down and up","text":"<p>The Machine Module will be the commander of all its Equipment Modules, and it will also respond as needed when an Equipment Module reports an error. During normal operation the code in the Machine Module will send a state change command to each of the Equipment Modules, and they will report back to the Machine Module once the requested state has been reached. When a fault occurs the equipment module will handle the fault according to how it is programmed to do so. Typically, this would involve commanding itself into the Aborted state. The Machine Module will detect this state change and respond accordingly. It could be that other Equipment Modules need to be Suspended while waiting for the faulted module to be cleared, or it could be that some modules need to also fault or suspend due to dependencies on the module that originated the fault. By using the Machine Module as the commander and coordinator of the events the design of the machine code can be very flexible.</p>"},{"location":"Getting_Started/SPT%20Event%20Logger.html","title":"SPT Event Logger","text":""},{"location":"Getting_Started/SPT%20Event%20Logger.html#event-logger","title":"Event Logger","text":"<p>The event logger is large topic that is comprised of many pieces. The documentation covers many situations that are not necessary to start using the event logger. The SPT Framework library provides code that can help manage alarms and messages within a project. </p> <p> </p> Events can be messages or alarms"},{"location":"Getting_Started/SPT%20Event%20Logger.html#tracelog","title":"TraceLog","text":""},{"location":"Getting_Started/SPT%20Event%20Logger.html#fb_tracelog","title":"FB_TraceLog","text":"<p>Uses FB_TcMessage from the Tc3_EventLogger library and adds further information including a time stamp, and the location (MM, EM, Component) where the message was created. There is already an instance of FB_TraceLog within FB_BaseFB; therefore, no additional instances are needed. Any function block that has a CyclicLogic method will also have a Trace method.</p> <p>The logged messages are best used for debugging purposes. For example, at the end of the CASE statement in the Initialize method.  </p> <p>Be careful that the Trace method is only called once, otherwise the message will be logged every cycle.</p> <pre><code>    50:\n        THIS^.Trace('Init Complete');  \n        Initialize := TRUE;  \nEND_CASE\n</code></pre> <p> </p> Logged Trace Message"},{"location":"Getting_Started/SPT%20Event%20Logger.html#tmc-editor","title":"TMC Editor","text":"<p>Event Classes are groups of events (possibly for a theme e.g. SubMoulde or Component). Create Events using the TMC Editor in the Type System. The specific text of each event created within the TMC Editor can be customized; however, only one instance of an event can be active at a given time. For messages this is not an issue, but for alarms that will be raised and cleared it is important to note that only one alarm can be active at a time. For multiple alarms, each will need an entry within the TMC Editor.</p> <p>The VFFS Demo project uses and Event Class for each Module, Submodule, and Component. </p> Machine Module Events Submodule Events Component Events <p>Each of the above examples have a few standard events along with custom events that are specific to the module. It is important to note that the first event in each, the 'InitReferenceEvent' is used to initialize the event class. This event is used by the CreateEvents method of the modules and is required by the SPT Framework.</p>"},{"location":"Getting_Started/SPT%20Event%20Logger.html#alarms","title":"Alarms","text":"<p>It is important to understand that while all alarms must be raised, their status must be checked in order for them to prevent any given functionality. Therefore, a raised alarm that requires no confirmation can also be used to log information. However, if the alarm is not cleared, then it will lock that Event Class and not allow any other alarms to be raised for it.</p> <p> </p> Alarms can be Raised and Cleared <p> </p> Alarms can also require Confirmation"},{"location":"Getting_Started/SPT%20Event%20Logger.html#f_createalleventsinclass","title":"F_CreateAllEventsInClass","text":"<p>Initializes all instances of FB_TcAlarm within Alarms  </p> <p>Called from the CreateEvents method of MM, EMs, and Components as needed.  </p> <p>Accepts:  </p> <ul> <li>an ARRAY if FB_TcAlarm</li> <li>the Name of the MM or EM to be added to the Alarm text</li> <li>the Name of the data type from the TMC Module Class</li> <li>InitReferenceEvent *This one is required*</li> </ul> <p><pre><code>F_CreateAllEventsInClass(Alarms     := MachineAlarms,\n                         ClassSize  := SIZEOF(TC_Events.VFFSDemo),\n                         pInitEvent := ADR(TC_EVENTS.VFFSDemo.InitReferenceEvent),\n                         Prefix     := Name);\n\nSUPER^.CreateEvents();\n</code></pre> Note: It is important to call the CreateEvents method of the base class in order to also create those events. </p>"},{"location":"Getting_Started/SPT%20Event%20Logger.html#f_getmaxseverityraised","title":"F_GetMaxSeverityRaised","text":"<p>Returns the highest severity level of any events currently raised within Alarms  </p> <p>For EMs (Submodules) called from CyclicLogic method For MM called from SubModuleMonitor method  </p> <p>Accepts  </p> <ul> <li>an ARRAY if FB_TcAlarm the same array as F_CreateAllEventsInClass</li> </ul> <p><pre><code>_CurrentAlarmSeverity := F_GetMaxSeverityRaised(Alarms := UnwindAlarms, CurrentSeverity := _CurrentAlarmSeverity);\n</code></pre> </p>"},{"location":"Getting_Started/SPT%20Event%20Logger.html#f_raisealarmwithstringparameters","title":"F_RaiseAlarmWithStringParameters","text":"<p>Raises event associated with Alarm and passes String_n as arguments for contextual information.  </p> <p>Called from any method that needs to raise an alarm  </p> <p>Accepts  </p> <ul> <li>an instance of FB_TcAlarm passed in as a VAR_IN_OUT to the method</li> <li>the Name of the data type from the TMC Module Class</li> <li>2 strings for further details</li> </ul> <pre><code>F_RaiseAlarmWithStringParameters(Alarm    := Alarm,\n                                 String_1 := Name,\n                                 String_2 := String_1,\n                                 String_3 := String_2);\n</code></pre> <p> </p> Dig into the source     Messages are logged events that are not alarms. They are used to provide status information to the user. They can be used to log the start and end of a state, or to log the start and end of a transition.      Using Tc3_EventLogger.lib, an instance of the FB_TcMessage can be used to send messages to the event logger.     Declare an instance of FB_TcMessage     <pre><code>fbInfoMsg       : FB_TcMessage; \n</code></pre>      Call the CreateEx method to create the message. The first parameter is the event name, the second parameter is an interface to the source information. The source information is optional and can be left as 0.     <pre><code>IF Init then\n    Init := FALSE;\n    fbInfoMsg.CreateEx(TC_EVENTS.MyTestEventClass.MyInfoMessage, 0); \nEND_IF\n</code></pre>      Finally, call the Send method to send the message to the event logger. The parameter is a time stamp, 0 will use the current time.     <pre><code>If SendMsg then\n    SendMsg := FALSE;\n    fbInfoMsg.Send(0);\nEND_IF\n</code></pre> Raise/Clear Alarms <p>     The alarms are similar to messages, but they are used to indicate a problem that needs to be addressed. The alarm will be raised when the problem occurs, and then cleared/confirmed by the operator when the problem is resolved.      Declare an Instance of FB_TcAlarm;     <pre><code>fbError     : FB_TcAlarm;\nfbCritical  : FB_TcAlarm; \n</code></pre>      Call the CreateEx method to create the alarm message. The first parameter is the event name, the 2nd parameter is used to set the alarm as needing to be cleared by the operator. The last parameter is an interface to the source information. The source information is optional and can be left as 0.     <pre><code>IF Init THEN\n    Init := FALSE; \n    fbError.CreateEx(TC_EVENTS.MyTestEventClass.MyErrorMessage,FALSE, 0);\n    fbCritical.CreateEx(TC_EVENTS.MyTestEventClass.MyCriticalMessage,TRUE, 0);\nEND_IF\n</code></pre>"},{"location":"Getting_Started/SPT%20Framework.html","title":"What is the SPT Framework?","text":"<p>The SPT framework utilizes the PackML libraries in order to allow for a defined set of states in which the control code can be organized. A key element of developing machine control is ensuring that the correct commands are given at the proper time and coordinated with the other parts of the machine. It is also important to ensure that commands are not given at an incorrect time.</p>"},{"location":"Getting_Started/SPT%20Framework.html#libraries","title":"Libraries","text":"<p>The functionality of PackML state machine requires the Tc3_PackML_V2 library. The SPT Framework is built on top of this library to aid in rapid code development. The 4 SPT libraries are SPT Base Types, SPT Components, SPT Event Logger, and SPT Utilities. The SPT Base Types library contains the core of the SPT Framework, the function blocks contained within will be extended to allow the machine code to interact with the PackML state machine. The SPT Components library holds some prewritten components for various sensors and actuators, including servos. The SPT Utilities library contains small pieces of code that are often repeated in the development of larger projects; for example: Analog Scaling, Data Buffers, and Comparators. Lastly the SPT Event Logger is a wrapper around the Tc3_EventLogger that is tailored to be used within the SPT Framework.</p>"},{"location":"Getting_Started/SPT%20Framework.html#cyclic-logic-vs-single-method-calls","title":"Cyclic Logic vs Single Method Calls","text":"<p>The framework uses Methods to call specific pieces of the code, such M_ExtendCylider or M_ResetAxis. These methods can be called once as needed, or multiple times until the requested command has completed or faulted. Additionally, the framework uses methods to call commands during specific states. For example, any code that needs to be executed while a Module is in the Resetting state can be placed in the Resetting method and it will be called at the proper time. The framework also makes use of Cyclic method calls to update the parts of the code that are responsible for monitoring changes, such as alarms, faults, and state changes made by other methods. These also provide a way to cyclically call and update all of the Modules and Components that have been registered to a higher-level module.</p>"},{"location":"Getting_Started/SPT%20Framework.html#does-a-component-need-an-em","title":"Does a Component need an EM?","text":"<p>So far, the hierarchy has been explained as Machine Module, Equipment Module, and Component. A Machine is made up of one or more pieces of Equipment, and Equipment is made up of Components. But it could be that a Machine itself has a component, such as a stack light, that indicates the overall status of the machine. Therefore, it is important to be aware that an Equipment module is not always required, and a Machine Module can have a direct connection to a Component.</p>"},{"location":"Getting_Started/SPT%20Framework.html#what-is-a-submodule","title":"What is a Submodule?","text":"<p>The PackML standard defines only Machine, Equipment, and Component. However there has occasionally been a need or a request to organize machines with multiple levels of Equipment Modules. To accommodate this the SPT Framework uses the term Submodule instead of Equipment Module. This allows for some flexibility in the layout of the architecture so that a Machine can have one or more Submodule (and 0 or more Components), and then a Submodule can also have one or more Submodules and 0 or more Components. In theory there is no end to the number levels that can be obtained with this architecture. However, the use of more than 3 levels (MM, EM, and Component) is highly discouraged and should only be used when having a Submodule of a Submodule truly is the best option.</p>"},{"location":"Getting_Started/SPT%20Framework.html#inheriting-the-base-classes","title":"Inheriting the base classes","text":"<p>When creating a Module or Component they must inherit the functionality of the base classes in the SPT Framework libraries. FB_PackML_BaseModule will be inherited by the Machine Module and all submodules. FB_ComponentBase will be inherited by all components. This will allow all of the modules and components to have everything they need to interact with the PackML state machine and the SPT Framework.</p>"},{"location":"Getting_Started/SPT%20Framework.html#registering-an-em-or-component-with-its-higher-level-module","title":"Registering an EM or Component with its higher-level Module","text":"<p>In order for the Cyclic updates to happen properly, a SubModule or Component must be registered with its higher-level Machine Module, or Submodule. The Variable name of each, that is declared must be passed into an array that will initialize it with the module.</p>"},{"location":"Getting_Started/SPT%20Framework.html#creating-the-array-of-interfaces-for-submodules-and-components","title":"Creating the array of interfaces for submodules and components","text":"<p>Registering Modules and Components is done using their interfaces. Within each Machine and Submodule there will exist the declaration of the SubModules and Components of that Module. Each of these instance variables will be passed into the methods for RegisterModule or RegisterComponent. For example, this Machine Module contains three Equipment Modules referred to as SubModules in the code.</p> <pre><code>FUNCTION_BLOCK FB_Machine EXTENDS FB_PackML_BaseModule\n// Sub Modules\nPullWheels  : FB_PullWheel;\nSealer      : FB_Sealer;\nUnwind      : FB_Unwind;\n</code></pre> <p>The three modules (PullWheels, Sealer, and Unwind) are all function blocks that extend the FB_PackML_BaseModule which Implements the I_PackML_BaseModule; therefore, they can be passed into the method RegisterSubmodule. Understanding how this works internally is not important, what is important is remembering to register each instance variable using the appropriate method. When creating components, the same process is used, the only difference is that the components Extend FB_ComponentBase which Implements I_ComponentBase and the method is RegisterComponent.</p> <pre><code>FUNCTION_BLOCK FB_PullWheel EXTENDS FB_PackML_BaseModule\nLeftPullWheel : FB_Component_BasicSlaveAxis := (Name := 'Left');\n</code></pre>"},{"location":"Getting_Started/SPT%20Framework.html#overriding-methods-of-the-base-class","title":"Overriding methods of the base class","text":"<p>The SPT Framework contains a complete set of function blocks to run the state machine. FB_PackML_BaseModule has a method for each of the PackML states. Each of these methods has the code needed progress the state machine. When adding a new Equipment module that will extend FB_PackML_BaseModule, call the same methods with their unique code and call the method in the base using SUPER^.Method() or SUPER^.Resetting within your Resetting method. The use of SUPER will call the method of the base class and run the code that exists there. The typical implementation would call SUPER at the end of the method in the EM. If a method is not needed by an Equipment Module, then there is no need for the EM to call that method. At the Machine module level unless you need to override the method, DON\u2019T. Just let the CyclicLogic method handle it. Additionally, while it is common to override the CyclicLogic method when inheriting from a library in the base class, it is not required to do so. If you do not override the CyclicLogic method the underlying code for the method will be executed.</p>"},{"location":"Getting_Started/SPT%20Framework.html#when-to-call-statecomplete-vs-supermethod","title":"When to call StateComplete() vs Super^.Method()","text":"<p>The Acting states are exited when the StateComplete method is called. This is done in base class for you when you call SUPER^.Method(). It could be that you wish to call the StateComplete method from the EM, and that can also be done. The waiting states are exited when a change state command is given, for example:  </p> SPT V4SPT V3 <pre><code>ipModule.ChangeState(Tc3_PackML_V3.E_PMLCommand.Stop) \nor\nChangeState(E_PMLCommand.Unsuspend)\n</code></pre> <pre><code>ipModule.ChangeState(Tc3_PackML_V2.E_PMLCommand.ePMLCommand_Stop)\nor\nChangeState(E_PMLCommand.ePMLCommand_Unsuspend)\n</code></pre> <p>If you are not sure, don't call StateComplete(). Call Super^.Method() after your code and let the base class handle it.</p>"},{"location":"Getting_Started/SPT%20Framework.html#initializing","title":"Initializing","text":"<p>Each Machine and Equipment module has a CyclicLogic method, and that method should call the method of the base class using Super^.CyclicLogic(). An Initialize method is also required. The first lines of code in the CyclicLogic method are to call to the Initialize method if it has not completed.</p> <pre><code>METHOD PUBLIC Cyclic Logic\n</code></pre> <pre><code>IF NOT _InitComplete THEN\n    _InitComplete := Initialize();\n    RETURN;\nEND_IF\n</code></pre> <p>The Initialize method is used to register the submodules and components to the internals of the framework. A CASE statement is used to ensure that everything happens in the proper order.</p> SPT V3.2.3 or laterSPT V3.2.2 or earlier <pre><code>METHOD PROTECTED Initialize\n</code></pre> <pre><code>Initialize := FALSE;\nCASE DescendantSequenceState OF\n    0:\n        //Register each Submodule with the Machine Module\n        RegisterSubModule(PullWheels);\n        RegisterSubModule(Sealer);\n        RegisterSubModule(Unwind);\n\n        _LogModeChanges         := FALSE;\n        _LogStateChanges        := FALSE;\n        DescendantSequenceState := DescendantSequenceState + 10;\n\n    10: //Continue with the initialization code   \n</code></pre> <pre><code>METHOD PROTECTED Initialize\n</code></pre> <pre><code>Initialize := FALSE;\nCASE DescendantSequenceState OF\n    0:\n        // Define the interfaces to the different subunits (Must take place before SUPER^.initialize call)\n        FOR i := 1 TO SPT_BaseTypes.Parameters_PackML_Base.MAX_NO_OF_SUBMODULES DO\n            ipSubModules[i] := ipSubModules_Init[i];\n        END_FOR\n\n        FOR i := 1 TO SPT_BaseTypes.Parameters_PackML_Base.MAX_NO_OF_COMPONENTS DO\n            ipComponents[i] := ipComponents_Init[i];\n        END_FOR\n\n        _LogModeChanges         := FALSE;\n        _LogStateChanges        := FALSE;\n        DescendantSequenceState := DescendantSequenceState + 10;\n\n    10: //Continue with the initialization code \n</code></pre> <p>The SUPER^.Initialize method must also be called as the last step of the CASE statement.</p> <pre><code>    30:\n        //Call the Super\n        IF SUPER^.Initialize() THEN\n            DescendantSequenceState := DescendantSequenceState + 10;\n        END_IF\n    40:\n        Initialize := TRUE;\nEND_CASE\n</code></pre>"},{"location":"Getting_Started/SPT%20Framework.html#what-is-a-control-source","title":"What is a Control Source","text":"<p>A control source is used to provide a connection from outside of the PLC code to the State Machine. This could be through physical buttons, an HMI, or an OPC connection to another machine. The base library (SPT Base Types) contains an instance of FB_ControlSource. This function block can be overridden as needed. The most important part for implementation is to provide code for the Cyclic Logic method. The Cyclic Logic method contains 3 major parts.</p> <ol> <li>The R_TRIG that captures the incoming command.</li> <li>The monitoring of the permissives that will allow or prevent a state change based on the current or other machine conditions.</li> <li>The monitoring of the commands and permissives to call the ChangeState method with the proper state.</li> </ol>"},{"location":"Getting_Started/SPT%20Framework.html#registering-the-control-source-with-the-machine-module","title":"Registering the Control Source with the Machine Module","text":"<p>The Initialization method of the Main POU needs to register a control source with the Machine Module.  In the below example ControlSource_HMI is the instance name of the control source function block, and VFFSDemo is the instance name of the Machine Module function block.</p> <p><pre><code>    ControlSource_HMI : FB_ControlSource;\n    VFFSDemo          : FB_Machine := (Name := 'VFFS Demo');\n</code></pre> <pre><code>    IF NOT ControlSource_HMI.Registered THEN\n        VFFSDemo.RegisterExternalController(ControlSource_HMI);\n    END_IF\n</code></pre></p>"},{"location":"Getting_Started/SPT%20Framework.html#testing-the-code-and-the-state-machine","title":"Testing the code and the state machine","text":"<p>At this point it should be possible to Activate Configuration, Restart TwinCAT in Run Mode, and test the code for proper functionality.</p> <p>Once the PLC is running you can login and check a few online values. Within MAIN, expand the declaration of your FB_Machine and check the values of the following variables:</p> SPT V4SPT V3 <p><pre><code>VFFSDemo : FB_Machine := (Name := 'VFFS Demo');\n</code></pre> <pre><code>_CurrentMode        Production\n_CurrentState       Aborted\nNumberOfSubModules  //This value should be equal to the number of Submodules declared within your instance of FB_Machine. If not then check the declaration of the ipSubModules_Init ARRAY\nNumberOfComponents  //This value should be equal to the number of Components declared within your instance of FB_Machine. If not then check the declaration of the ipComponents_Init ARRAY\nInitComplete        TRUE\n</code></pre></p> <p><pre><code>VFFSDemo : FB_Machine := (Name := 'VFFS Demo');\n</code></pre> <pre><code>_CurrentMode        ePMLUnitMode_Production\n_CurrentState       ePMLState_Aborted\nNumberOfSubModules  //This value should be equal to the number of Submodules declared within your instance of FB_Machine. If not then check the declaration of the ipSubModules_Init ARRAY\nNumberOfComponents  //This value should be equal to the number of Components declared within your instance of FB_Machine. If not then check the declaration of the ipComponents_Init ARRAY\nInitComplete        TRUE\n</code></pre></p> <p>Once those values have been confirmed you can use your Control Source the test the state machine.</p>"},{"location":"Getting_Started/SPT%20Framework.html#adding-parameters-recipe-values","title":"Adding Parameters / Recipe Values","text":"<p>Parameters and Recipe values can be declared and passed to SubModules or Components through the use of Properties. Starting with a local variable of a Component that is read adn written by a Property, the Component can then use the local variable name as if it was the actual value. When a SubModule creates an instance of the Component the SubModule is then responsible for setting the value of the Property in the Component. </p>"},{"location":"Getting_Started/SPT%20Framework.html#adding-more-equipment-modules-submodules","title":"Adding more Equipment Modules (SubModules)","text":"<pre><code>Create a new function block that Extends FB_PackML_BaseModule\nAdd the Local variables and Properties needed for parameters\nAdd the Methods needed for the Acting and Waiting states\nAdd the Cyclic Logic method if needed\nAdd the Initialize Method\nWithin the EM declare any Components and use the RegisterComponents method within the EMs Initialize method\nWithin MAIN, declare an instance of the new EM and use the RegisterSubModule method to register it with the Machine Module\n</code></pre>"},{"location":"Getting_Started/SPT%20Framework.html#creating-components","title":"Creating Components","text":"<pre><code>Create a new function block that Extends FB_ComponentBase\nAdd the Local variables and Properties needed for parameters\nAdd methods as required to perform the function of the component\nAdd the Cyclic Logic method if needed\nAdd and events or alarm logic\nAdd the Component to a SubModule, register it, and implement it within the SubModule, including ant parameters that need to be passed to it.\n</code></pre>"},{"location":"Getting_Started/SPT%20Framework.html#additional-control-sources","title":"Additional Control Sources","text":"<p>Coming Soon...</p>"},{"location":"Getting_Started/V4Release.html","title":"V4 Release Notes","text":"<p>With the release of PackML V3 for TwinCAT 3.1.4026, the SPT Libraries have moved to V4.0 to support the new PackML standard.  </p> <p>The full V4 Release notes are available, and samples are available in the SPT V4 Samples repository.  </p> <p>Before installing the V4 libraries please see the documentation section about Pinning libraries in your V3 projects.  </p> <p>Note</p> <p>V3 libraries will be maintained with bug fixes for the foreseeable future, but new features will only be added to the V4 libraries.</p>"},{"location":"Getting_Started/Videos.html","title":"Video Tutorials","text":"<p>These Videos cover the creation, intent, choices and usage of the SPT Libraries: </p> <p>What is the SPT Framework</p> <p>Object-Oriented Programming</p> <p>Source Control</p> <p>Installation of the Libraries</p> <p>Building New Components part 1 Component Base</p> <p>Building New Components part 2 Cyclic Methods</p> <p>Extending Components</p> <p>Component Commands</p> <p>An Introduction to Tracing</p> <p>These videos are a continuing work in progress and will be released as they become available.</p> <p>Plase check back often as new content will be added to the list above.</p> <p>Library Licensing</p> <p>This sample is created by Beckhoff Automation LLC., and is provided as-is under the MIT license.</p>"},{"location":"Getting_Started/setup.html","title":"Setup","text":"<p>These libraries go hand-in-hand with the VFFS Demo PLC.</p> <p>This sample is created by Beckhoff Automation LLC., and is provided as-is under the MIT license.</p>"},{"location":"Getting_Started/setup.html#how-to-get-support","title":"How to get support","text":"<p>For SPT framework support, raise an issue here.</p> <p>For general TwinCAT and Beckhoff Product support, please contact your local Beckhoff Support.</p>"},{"location":"Getting_Started/setup.html#adding-this-repo-as-a-twincat-plc-library-repository","title":"Adding this repo as a TwinCAT PLC Library Repository","text":"<p>1) Clone this repository to your PC</p> <p>2) Open the Library Repository</p> <p></p> <p>3) Click Edit Locations...</p> <p></p> <p>1) Click Add...</p> <p></p> <p>1) Browse to the folder where you cloned this repository and give the PLC Library Repository a name (e.g. SPT Libraries).  NOTE The location MUST point to the \\Library Repository folder under the repo root!</p> <p></p> <p>1) Future updates to the SPT libraries will automatically propagate into TwinCAT XAE by fetching this repo.</p>"},{"location":"References/PackML.html","title":"TR88.00.02 Implementation Pack ML","text":""},{"location":"References/PackML.html#what-is-pack-mltr880002","title":"What is Pack ML/TR88.00.02?","text":"<p>TR88.00.02 is an implmentation guide/techchnical report for implmenting ANSI/ISA 88 for discrete machine control.  For full factory control ISA 95 (Enterprise Control System Integration), ISA 88 (Batch Control) and TR88.00.02 work together to define data communication from the MES/ERP layer all the way down to machine control of individual machines on factory floor.  While TR88.00.02/Pack ML was originally created to solve machine/line integration problem for the Packaging Industry, the integration problem is not unique to the Packaging Industry, many industries that integrate multiple machines together benefit from implementing ISA S88/TR88.00.02.  It must be noted that the Pack ML system can be modified to accomodate the Weihnstephan Model. Which is generally a more \"rigourous\" interface for specific machinery types. </p>"},{"location":"References/PackML.html#who-decides-what-goes-into-pack-mltr880002","title":"Who decides what goes into Pack ML/TR88.00.02","text":"<p>ANSI/ISA 88 is a standard governing Batch Control that was first published in 1995.  S88 as it is commonly known has been widely adopted for process/batch control.  S88 is great for processes that don't stop, or where time between batches may be days/weeks/months.  S88 is not designed for \"Discrete Machine Control\". (machines that start and stop)  ISA TR88.00.02 is governed by the ISA but maintained by the standards organization OMAC https://www.OMAC.org.   Volunteers of OMAC member organizations/companies form committies every 5 years to update the TR88.00.02 report according to according ISA guidelines.  These commities consist of Automation Suppliers, Machine Builders, and End Users.  Regardless of the machine builder or automation supplier, machines implmenting Pack ML follow the same sequences with the same terminology and identical interface eliminating reprogramming to get machines to coordinate/communicate. Machines not following any standard must often have their code adjusted, and reprogrammed in order to get them to communicate to each other or a higher level controller.  </p> <p>Although Pack ML was originally created to solve a problem for the packaging industry, machine/line integration and lack of consistency is not unique to the Packaging Industry.  Since its inception Pack ML/TR88.00.02 ML has been adopted in a wide variety of industries.  It is also important to note that Pack ML state model can be modified to follow the Weihnstephan standard.  </p> <p>Pack ML has been around for a long time, but is regularly updated to address weaknesses and take advantage of technological advancement.  Version 2.2 of Pack ML was released in 1996 and implmented 10 states.  In 2005 it was updated to Version 3.0 which implented the current 17 states.  In 2008 it was adopted by the ISA standards organization as TR88.00.02.  Since that time working groups comprized of volunteers from OMAC member compaines/organization have worked together to update the standard twice since then.  In 2015 a major update was made to allow for structured variables and eliminate a ton of variable names with _ restrictions.  TR88.00.02-2015 in 2020-2022 Was once again updated to add even more data types and enhance operation of the state machine. </p>"},{"location":"References/PackML.html#getting-started-with-tr880002pack-ml","title":"Getting Started with TR88.00.02/Pack ML","text":"<p>Before Implementing TR88.00.02 the OMAC Implementation guide should be consulted and the standard itself should be consulted.  THe implmentation guide is available free of charge here on the OMAC website https://www.omac.org/packml it describes the intention and implmentation of Pack ML very well and is \"Automation Supplier/Vendor\" independent.  The standard itself is available from the ISA https://www.isa.org/products/isa-tr88-00-02-2022-machine-and-unit-states-an-imp.  If your organization wishes to have a say in the standard, not just implement, the OMAC organizaiton is open to any machine builder, automation supplier, or end user of any industry. </p> <p>Important to note is that TR88.00.02 defines ONLY the top layer of the machine.  It is common to take existing machines and implement a gateway/translation layer between the existing control and the standard TR88.00.02 interface. Brownfield implementation is a significant benefit to end users wishing to update/coordinate existing machines.  </p> <p>A common misconception is that Pack ML is big and has a lot of states and overhead that are not necessary and going to make the machine \"slower\".  The standard allows for configuration, and a minimum set of States, and Tags.  </p> <p>The full state model looks like this: </p> <p></p> <p>However the minimum State Module can be as simple as this  </p> <p>Depending what the machine is doing will determine what states it really needs, states that are not defined/implmented are skipped.  </p> <p>There are a lot of tags that can be implemented but there are very few that must be integrated.  There are 5 mandatory control tags/variables to switch states/modes, 4 mandatory status variables/tags to confirm states/modes and 3 mandatory administration tags for stop reasons, and number produced and number defective.   A grand 14 variables and 4 mandatory states a Pack ML implmentation can be extremely lightweight. Even implementing a gateway to translate      </p>"},{"location":"References/PackML.html#possiblities","title":"Possiblities","text":"<p>There are 31 modes of operation available, 3 have fixed names Producing, Maintenance and Manual.  This leaves 28 other modes, that can be defined as necessary. For example Dry Run, Cleaning, Single Cycle or whatever else is necessary. Each mode can have have as many or as few states as required. </p> <p>Many machine builders and technology providers have learned that the top level does not need to be the only part of the machine implmenting Pack ML.  Just as multiple machines implementing Pack ML can be quickly connected together, so can modules within a machine.  This is often refered to as Make2Pack but Make2Pack has never been ratified as a standard.  Regardless of offical standardization, implementing Pack ML into Modules within the machine is very advantagous.  If it has already been built once for the top level, why not simply re-use it for Modules within a machine.  THe major advantage when implmenting TR88.00.02 at lower layers is the \"standard\" no longer applies.  The state machine can be stripped down even further.  Certain advantages remain, such as timing how long each module has been in which mode.  This can be very handy if task timing is required.  </p> <p>State machine for a very basic device  </p> <p>This sequence ensures the bare minimum number of commands/transitions so that no extra handshakes are necessary.  Command clear to clear/reset and get to idle from aborted, Start changes to execute, when status confirms the device is in Execute the completed command can be issued to return to idle when finished.  If complete did not exist, it would never be known if the system is in idle because the \"start\" has not yet been executed, or if the system has already been though execute and is back to idle.  Why do this? Surely I can build something simpler, and that's true, but the state model also includes timing of each state, which means without adding anything we know how long the device was in Execute performing its function.  The timing is automatically updated in the admin tags, and a bunch of diagnostics are now available \"for free\" and the commands to change states and trigger the sequence are already known. </p>"},{"location":"References/PackML.html#project-planning-using-states-and-modes","title":"Project Planning using States and Modes","text":"<p>It will be defined in depth further on in the documentation, however the specification of the machine and workload can be better estimated using TR88.00.02.  By defining all devices/modules and all machine modes of operation, the funciton of each Module/Device in each mode and state can be defined and the amount of effort can be estimated.  Definining all the modes first ensures all funcitons of all devices are clear.  For example, knowing the machine will have a cleaning mode where certain devices will be controlled in a different way than every other mode, ensures those features are planned at the start, there is no surprise just as the machine is nearing completion.  \"Great everything works, now on this machine there's a cleaning mode and we have to open all these devices and run in a limited set of operations with some guarding open\" this \"small\" feature suddenly has a drastic impact on coding effort and can even effect what has already been implmented.  All devices need to be programmed to accomodate this completely new operation. This can have a significant effect particularly on areas like safety.  Knowing the full scope of work at the beginning reduces the number of \"surprises\".  </p>"},{"location":"References/PackML.html#deciding-which-states-are-needed","title":"Deciding which states are needed","text":"<p>It is not required that all states be called from the machine module or submodule. For example, if a submodule has no work to perform in the Clearing state, then there is no need to call that method. When designing the architecture of the code it will be important to define which states are required for each submodule. Once the states have been decided and the functionality that will exist in each state defined then the methods can be added to override the methods of the base class.</p>"},{"location":"References/PackML.html#custom-modes","title":"Custom Modes","text":"<p>A common argument on why not to use TR88.00.02 is often stated, there\u2019s too much there\u2019s too many states and I don\u2019t need all of them.  There are too many states, too many tags and either I have a lot of other modes, or only one mode of operation.  A feature of TR88.00.02 that is often overlooked is custom modes.  There\u2019s a minimum set of tags, and a minimum set of states.  This is intended by the standard to make the system as lightweight as possible. </p> <p>My layout starts like this and lets see what we can remove </p> <p> </p> PackML Full State Machine <p>To determine what modes are necessary we can start asking questions </p> <p>Is \u201cComplete\u201d required? Is there a situation where I have multiple items in process need to run out before stopping? No this machine operates on one \u201citem\u201d at a time, its either empty or has one.  OK get rid of completing and complete they make no sense </p> <p>Do I need suspend?  Does the machine have sensors to determine if it is starved from upstream or blocked downstream? No Can the machine stay in Execute when empty?   Yes Suspend is not necessary, the machine can sit in execute or be stopped Remove Suspending/Suspended/Unsuspending </p> <p>Do I need Held?  Is there anything the operator must do to keep the machine in execute?  IE if the operator does not refill something the machine will run out and stop? No there is nothing to be re-filled/replaced/removed while in operation.  No held is required, the machine can always sit in execute  If there are things to be refilled/replaced, then Held would be required as the machine cannot stay in Execute if the operator has not performed a task. </p> <p>We\u2019re getting down to a pretty small state machine now, basically down to as many states as manual has.   </p> <p> </p> PackML Limited State Machine <p>There\u2019s still some work to be done </p> <p>Is Aborting required?  Are there any things I need to \u201cramp down\u201d or can I simply shut everything off?  If so, aborting isn\u2019t needed go to abort shut everything off </p> <p>Is Stopping required?  If I don\u2019t need aborting I most likely don\u2019t needs stopping, again is there a specific sequence that takes some time to complete? If not, stopping can be removed </p> <p>Is Resetting required?  Do certain devices have to start up in a certain sequence?  Can I simply \u201cenable them\u201d in Idle and leave them enabled? If I can </p> <p>Clearing?  Is there a sequence that has to happen in clearing or can I sit in Stopped and perform the clear? </p> <p>If this is all that\u2019s necessary we\u2019re down to the minimum set of states </p> <p> </p> PackML Minimum State Machine <p>States and 4 commands between states is the smallest allowed machine configuration this would be ideal for an inspection system </p> <p>If the machine is a vison inspection system nothing more is needed.  Turn the machine on and it\u2019s in aborted.  Clear any faults on the screen and its in stopped. Reset to go to idle and enable the motor for the belt  Start to get to execute and run the belt.  Nothing more is required. </p> <p>The machine sits in Execute waiting for parts/pieces to arrive, when they arrive, they are processed.  No parts, no problem sits in execute.  More states are not necessary, but fewer states is problematic.  It is important to differentiate between a requested stop and an error/unrequested stop.  It is also desirable to have an Idle state with components enabled but no motion.  Abort and Stop mean different things to the line controller.  On an Abort, the line controller may need to abort machines up/downstream but on a stop it may simply put them into stop or suspend. </p> <p>Even though there are only 4 states a second mode other that producing may be required.  For example, there\u2019s a calibration mode, where a series of self tests are completed.  Accidentally receiving parts in this calibration mode could be very problematic and almost certainly result in a false calibration.   Sure in Execute an \u201cif calibrate, stop motor\u201d is possible, but the whole idea of states and modes is to ensure there is no accidental way to perform a function from one mode that must not happen in another mode.  Switching to a calibration mode, helps to ensure different code is called and sequences for the calibration function cannot occur during production and production cannot occur during calibration.  </p> <p>A labelling machine likely needs at least one more state, Held.  Labels/Ink are not infinite and often require refilling from an operator.  As indicated earlier, stop and particularly abort mean different things to the line controller.  A labeller that is without label cannot be in execute but it also does not require to enter stopped state, a held state should be used here.  The machine is \u201cheld\u201d when it is out of labels, but when refilled can immediately restart operation without running through resetting.  A suspend may still not be required as if no products show up no labels are place.  </p> <p>If machine should offer a low power state that if no products are arriving or an output buffer is full, then a suspend state is beneficial the machine can enter/exit suspending without operator intervention. </p> <p>Add as many states/modes as necessary to fulfil all machine functions but states can be eliminated when they are not necessary.  1.1.1   Internal modes  For sub devices, such as equipment modules and components it may be desirable to make even smaller state modes.  The minimum state set is for machine modes at the top layer.  Below that, TR88.00.02 has no influence.  It makes sense to use modes and states with equipment modules but an even smaller subset of states can be used. </p> <p>For example Aborted Idle Execute Completed might be enough.  If faulted, Clear to get to idle, to perform a function Start and execute, when the function is finished go to completed, to trigger another sequence reset to get back to idle. </p> <p>Why can\u2019t I simply have Idle, Execute and aborted?  Prior to the 2022 version of the standard this was problematic.   Execute automatically completes and issues a state change, if completed doesn\u2019t exist, it goes right back to ide.  Sounds like it does exactly what I want, however:   When you command start, you are in idle, and when you check again you are in idle.  Now the question is, is the device in Idle because it performed the function or is it in idle because execute has not started yet?  In TR88.00.02-2022 this was addressed getting out of Execute can now be accomplished with the command complete.  This now gives the full handshake necessary.  Command Start, Wait for execute, Command Complete, wait for Idle, and then command start again.  Aborted, Execute Idle will function without any other handshakes required, switching the command from Start to Complete and the state changes from Idle to Execute completes the handshake.  State Idle with Command complete means the last cycle finished.  </p>"},{"location":"SPT%20Training/ControlSource.html","title":"Overview","text":"<p>A Control Source provides a way to connect an external controller to a specific <code>FB_PackML_BaseModule</code>, this could be the Machine Module or any Equipment module. The external component could be the HMI, the main operator panel, or any push button station on the machine. For the purpose of Encapsulation, it is typical to use multiple Control Sources, and even multiple Control Sources per module.</p>"},{"location":"SPT%20Training/ControlSource.html#registration","title":"Registration","text":"<p>Each Control Source must be registered to the MM or EM using its <code>RegisterExternalController()</code> method. An instance of a function block that implements <code>I_PackML_ExternalController</code> must be passed into the method. This is typically done by creating your control source that <code>EXTENDS FB_ControlSource</code> from the <code>SPT Base Types</code> Library. Once the FB has been passed to the <code>Registration()</code> method the <code>CyclicLogic()</code> method of the <code>ControlSource</code> must be called once.</p>"},{"location":"SPT%20Training/ControlSource.html#permissive","title":"Permissive","text":"<p>The Control Source is then used to control the state machine of the module. In its simplest form it will have a single <code>CyclicLogic()</code> method that monitors the current mode and state, when a HMI, Hardware push button or other command is passed into the control source through a property, it will be compared against the defined permissive and conditions to determine how the state machine will respond. For example, if the current state is Aborting then most likely all commands will be ignored. But once the state changes to Aborted, the Reset button could be used to issue the Clear command to the state machine from within the Control Source.  The permissive can also be used to ensure an axis is homed before it\u2019s allowed to be jogged, and to check that other interlocks have been properly handled.</p>"},{"location":"SPT%20Training/ControlSource.html#requests","title":"Requests","text":"<p>When a button is pressed or a switch is turned, this status can be sent to the control source through a property. This can then be read internally by the <code>CyclicLogic()</code> method, and if the permissive allows it, the state or mode can be changed. Once the state machine is in the proper condition, the same property can be read from the state method of the EM to carry out the command. For example, if the machine is currently in <code>Manual</code> and <code>Idle</code>, and the Jog button is pressed. The control source will check the permissive and issue the Start command to the state machine. Then, once the <code>Execute()</code> method for the EM is called it will process the code for Manual and read the <code>ControlSource.Jog</code> property as its command to jog the axis. </p>"},{"location":"SPT%20Training/ControlSource.html#where-should-control-sources-be-used","title":"Where should Control Sources be used?","text":"<p>The Machine Module is the most obvious choice to start with a Control Source. While you can directly call the <code>ChangeMode()</code> or <code>ChangeState()</code> methods, using a Control Source creates a clean and encapsulated way to manage changes in the state machine. It is possible to register a control source for each Equipment module. Doing so can allow for a more modular machine, and also allow for the HMI connection to mirror the modularity of the PLC.</p> <p>Not only can the HMI be a reason for a Control Source, but it is also possible to have a Control Source dedicated to hardware inputs and outputs. Some smaller operator panels have similar button layouts and functionality, and these can be excellent candidates for a reusable control source. Although being reusable is not a requirement, it does help with development time. Creating a Control Source for the operator hardware provides a single location for the declaration of the hardware variables along with a place to connect them to the code. If the <code>%I</code> and <code>%Q</code> variables are declared locally within a Control Source then properties can be created to provide those variables to other parts of the code. Additionally a Control Source can be created for HMI variable which will provide the same familiarity for connecting external variables to the PLC code.</p>"},{"location":"SPT%20Training/Conventions.html","title":"Conventions","text":"<p>On Screen components such as Menu items will be in Helvetica (for example File menu) TwinCAT code will be in sans-serif Lucida (for example <code>VAR, END_VAR</code>) when used in the text or a paragraph, and when used in a code block.</p> <pre><code>VAR\nEND_VAR\n</code></pre> <p>Note</p> <p>Notes are added to provide additional information in order to add clarity or to bring up a point of consideration.</p> <p>Info</p> <p>Information is added to provide additional information that may be useful, but is not required to understand the content.</p> <p>Tip</p> <p>Tips are added to provide additional information that may be useful, but are not required to understand the content.</p> <p>Question</p> <p>Questions are added to address items that are commonly asked or to encourage the reader to think about how something will need to be considered in their project.</p> <p>Success</p> <p>Success items are added to provide information that is a best practice or a good way to do something.  These are not the only way to do something, but they are a good starting point.</p> <p>Danger</p> <p>These are items that if not managed correctly can be a source of frustration and can cause problems.</p> <p>Warning</p> <p>Warnings point out items that are common mistakes and can cause issues if not addressed.</p> <p>Example</p> <p>Examples are added to provide a sample of how something is done or how it can be done.  These are not the only way to do something, but they are a good starting point.</p> <p>Code that you might wish to copy will have a copy button in the top right corner of the code block. <pre><code>a := b + c;\n</code></pre></p> <p>Code that is used to show an example will not have the copy button, but can still be highlighted and copied. <pre><code>a := b + c;\n</code></pre></p> <p>When code samples are modified, the following will be used to show differences in code by using the following format: <pre><code>- Previous Code\n+ New Code that replaces the previous code\n</code></pre></p>"},{"location":"SPT%20Training/InitializeAndCyclicLogic.html","title":"Initialize and CyclicLogic","text":"<p>The <code>Initialize()</code> and <code>CyclicLogic()</code> methods are used by both the <code>FB_PackML_BaseModule</code> and the <code>FB_ComponentBase</code>. These are extended to create Machine Modules, Equipment Modules, and Components. Without these two methods the framework doesn\u2019t function.  </p>"},{"location":"SPT%20Training/InitializeAndCyclicLogic.html#initialize","title":"Initialize","text":"<p>The <code>Initialize()</code> method of <code>FB_ComponentBase</code> simply calls the <code>CreateEvents()</code> Method and returns TRUE. This ensures that the EventClasses of the component are properly configured and provides consistency in program design by allowing us to override the <code>Initialize()</code> method when we inherit from <code>FB_ComponentBase</code>. The <code>Initialize()</code> method of the <code>FB_PackML_BaseModule</code> is more complex. In addition to calling the <code>CreateEvents()</code> method it also creates a list of SubModules and Components that the Module is responsible for controlling. It then calls the <code>CyclicLogic()</code> method of each of these. This call is done in order to allow each of these to call their respective <code>Initialize()</code> methods. Because an <code>Initialize()</code> method will take multiple scans to complete, the method is continually called until it returns TRUE at the end of the CASE statement. This program design also requires us to first call the <code>Initialize()</code> method at the beginning of any <code>CyclicLogic()</code> method if it has not been completed. The variables and methods required for this are already declared in the base classes.</p> <p>Each <code>Initialize()</code> method will return TRUE, therefore ultimately setting <code>_InitComplete</code> to TRUE which is declared within <code>FB_CyclicFB</code>, which is a parent of <code>FB_PackML_BaseModule</code>. The <code>InitComplete</code> variable is a property that will get the <code>_InitComplete</code> variable. Once the <code>Initialize()</code> method has finished for all SubModules and Components the <code>CyclicLogic()</code> methods will run for all of them as long as each Child calls <code>SUPER^.CyclicLogic()</code>.</p> CyclicLogic()<pre><code>    IF NOT _InitComplete THEN\n        _InitComplete := Initialize();\n        RETURN;\n    END_IF\n\n    SUPER^.CyclicLogic();\n</code></pre>"},{"location":"SPT%20Training/InitializeAndCyclicLogic.html#cycliclogic","title":"CyclicLogic","text":"<p>It is important for all <code>CyclicLogic()</code> methods to be called Cyclically. While this might seem obvious, there will be times when you might want to alter this, and it is important not to do so. If you have code that is not needed Cyclically then call it conditionally from the <code>Cycliclogic()</code> method, but always call the <code>CycliLogic()</code> methods. This will ensure that the internal hierarchy of <code>CyclicLogic()</code> methods and the state machine is never broken.</p> <p>As programs grow it will become necessary to break up the code within the <code>CyclicLogic()</code> method into smaller helper methods or simply into digestible chunks of code. </p> <p>The First call to <code>CyclicLogic()</code> of the Machine Module can be handled at a couple of different levels. Some prefer to add a <code>CyclicLogic()</code> method onto the <code>MAIN</code> POU, which is acceptable, but then you must also add the <code>Initialize()</code> method to <code>MAIN</code>. The other option is to declare <code>Machine : FB_Machine;</code> within <code>MAIN</code> (assuming that <code>FB_Machine EXTENDS FB_PackMLBaseModule</code>) and then letting <code>MAIN</code> call <code>Machine.CyclicLogic();</code>. While this is the simplest way to get started there can be some benefits to <code>MAIN</code> having its own <code>Initialize()</code> method that runs once before the remaining code is Initialized and run.</p>"},{"location":"SPT%20Training/LibraryParams.html","title":"SPT Library Parameters","text":"<p>Parameters are a special type of Constant Global Variable, but can be changed in the library. Parameters are used to set the various array sizes and properties which need to be fixed, but can vary from one machine or project to another.</p>"},{"location":"SPT%20Training/LibraryParams.html#spt-base-types","title":"SPT Base Types","text":"<p>Parameters_BaseComponent: <pre><code>    COMPONENT_BASE_ALARM_COUNT : UINT := 2; // Max array size for base alarms\n    INHIBIT_SIMULATION_WARNING : BOOL := FALSE; // Disables simulation warning messages\n</code></pre></p> <p>Parameters_PackML_Base:</p> SPT V4SPT V3 <pre><code>    MAX_NO_OF_SUBMODULES              : UDINT                      := 20; //Max array size for submodules\n    MAX_NO_OF_COMPONENTS              : UDINT                      := 32; //Max array size for components\n    MAX_NO_OF_EXTERNAL_CONTROLLERS    : UDINT                      := 10; //Max array size for external controllers\n    UNIT_MODE_DEFAULT                 : E_PMLUnitMode              := E_PMLUnitMode.Production; //Mode default for power on\n    UNIT_STATE_DEFAULT                : Tc3_PackML_V3.E_PMLCommand := E_PMLCommand.Abort; // State default for power on\n    CONCAT_SUBMODULE_NAME_WITH_PARENT : BOOL                       := FALSE; // Concatenate submodule name with parent name\n    CONCAT_COMPONENT_NAME_WITH_PARENT : BOOL                       := TRUE; // Concatenate component name with parent name\n    SUBMODULE_NAME_DELIMETER          : STRING(10)                 := ' '; // Delimeter for submodule name\n    COMPONENT_NAME_DELIMETER          : STRING(10)                 := ' '; // Delimeter for component name\n    STATELOGGER_DISABLED              : BOOL                       := FALSE; // When FALSE, all PackML State Changes will be logged\n    RESET_COMPONENTS_WITHOUT_ERROR    : BOOL                       := FALSE; // When TRUE, all components will be reset even if no error is present\n</code></pre> <pre><code>    MAX_NO_OF_SUBMODULES              : UDINT                      := 20; //Max array size for submodules\n    MAX_NO_OF_COMPONENTS              : UDINT                      := 32; //Max array size for components\n    MAX_NO_OF_EXTERNAL_CONTROLLERS    : UDINT                      := 10; //Max array size for external controllers\n    UNIT_MODE_DEFAULT                 : E_PMLUnitMode              := E_PMLUnitMode.ePMLUnitMode_Production; //Mode default for power on\n    UNIT_STATE_DEFAULT                : Tc3_PackML_V2.E_PMLCommand := E_PMLCommand.ePMLCommand_Abort; // State default for power on\n    CONCAT_SUBMODULE_NAME_WITH_PARENT : BOOL                       := FALSE; // Concatenate submodule name with parent name\n    CONCAT_COMPONENT_NAME_WITH_PARENT : BOOL                       := TRUE; // Concatenate component name with parent name\n    SUBMODULE_NAME_DELIMETER          : STRING(10)                 := ' '; // Delimeter for submodule name\n    COMPONENT_NAME_DELIMETER          : STRING(10)                 := ' '; // Delimeter for component name\n    STATELOGGER_DISABLED              : BOOL                       := FALSE; // When FALSE, all PackML State Changes will be logged\n    RESET_COMPONENTS_WITHOUT_ERROR    : BOOL                       := FALSE; // When TRUE, all components will be reset even if no error is present\n</code></pre> <p>Parameters_Tracing: <pre><code>    TRACING_ENABLED                     : BOOL := True; // Enable Trace Messages\n    MAX_LOG_ENTRIES_PER_SCAN            : UDINT := 100; //Limits the number of trace messages per scan\n    ALLOW_DUPLICATE_SEQUENTIAL_MESSAGES : BOOL  := FALSE; //Prevents duplicate messages from being logged\n</code></pre></p>"},{"location":"SPT%20Training/LibraryParams.html#spt-components","title":"SPT Components","text":"<p>Parameters_Cylinder <pre><code>    MAX_NO_OF_Solenoids : UDINT := 10; // Max array size for solenoids in FB_SolenoidBankBase\n</code></pre></p>"},{"location":"SPT%20Training/LibraryParams.html#spt-utilities","title":"SPT Utilities","text":"<p>Parameters_Utilities: <pre><code>    FILE_SIZE : UDINT := 1300000; // Number of characters in the file to read via Read/Write Symbol\n</code></pre></p>"},{"location":"SPT%20Training/LibraryParams.html#spt-motion-control","title":"SPT Motion Control","text":"<p>Parameters_Motion_Control: <pre><code>    ALLOW_UNLINKED_NC_AXES             : BOOL  := FALSE; // When FALSE, will create an error if an axis is not linked to a NC, this will also prevent the Initialize() method from being completed.\n    CAM_SLAVE_AXIS_TABLES              : UDINT := 10; // Max array size for cam slave axis tables\n    CAM_SLAVE_AXIS_MAX_CAM_POINTS      : UDINT := 30; // Max array size for cam slave axis points\n    ALWAYS_CALL_IPRESETMETHOD_ON_RESET : BOOL  := FALSE; // When TRUE, all axes will be reset even if no error is present\n</code></pre></p>"},{"location":"SPT%20Training/MachineCodeProgression.html","title":"Machine Code Progression","text":"<p>There are several different ways to plan your machine code. The following is just one option that has evolved over time as it has been applied to several different projects across multiple industries. While the goal is to have the machine running and making products, the code for \u2018Auto\u2019 should be the last code written. Planning and coding the basic functionality of the machine will lead to a much better overall system and maintainable machine.</p> <p>An important design decision needs to be made early on. Will the machine implement multiple modes, and where will the code be that causes movement on the machine? This document is written with the idea that movement will only occur in the Execute state, and therefore multiple modes are used to facilitate this idea. Once a specific function has been completed, then the state machine will transition to Completed and continue to Idle where the Mode can change based on the current condition of the machine.</p>"},{"location":"SPT%20Training/MachineCodeProgression.html#overview","title":"Overview","text":"<ol> <li> <p>Planning and gaining a common understanding of the machine operation and terminology. This section should involve all stakeholders.</p> </li> <li> <p>Planning and developing the individual Components based on the items identified in Section I. This section involves programming to control the hardware, or to interact with other external software. All the components for a machine should be reusable and therefore the planning of these components is crucial to ensure their longevity across multiple machines.</p> </li> <li> <p>Planning and developing the Machine Module and Equipment Modules. This is where the components are brought together to make a unique machine. This is where the state machine will be coded to handle multiple modes and how the components will interact with each other.</p> </li> </ol>"},{"location":"SPT%20Training/MachineCodeProgression.html#planning","title":"Planning","text":""},{"location":"SPT%20Training/MachineCodeProgression.html#identify-equipment-modules-and-components","title":"Identify Equipment Modules and Components","text":"<ol> <li> <p>Break the machine into mechanically dependent sections. If parts of the machine are physically connected, then they will most likely be required to follow the same state machine and therefore be in the same Equipment Module.</p> </li> <li> <p>Identify the Components that exist within each Equipment Module.</p> </li> <li> <p>Identify Components that are optional add-ons and isolate these into their own Equipment Modules to create modularity.</p> </li> <li> <p>Identify and list the Components (Cylinders, Servos, Valves, Temperature Controllers, etc.) </p> </li> <li> <p>From the full list, create a list of unique Components and consider which components will be building blocks for other components.</p> </li> <li> <p>Identify the Modes of Operation that will be needed for the Machine.</p> Default modes within PackML Other possible modes Invalid Home Production Pre-Positioning Maintenance Pre-Production Manual Post-Production Setup Clean In Place Dry Cycle Teach </li> <li> <p>Once the required Modes are identified, list the Equipment Modules and Components that will make use of each mode and a brief explanation of what functionality is expected.</p> Mode Equipment Module Components Functionality ALL Machine Module Stack Light Indicate Current Mode or Machine Error state Production Unwind Solenoid Brake Energize / De-energize Production Unwind Cylinder Clamp Extend Manual Unwind Cylinder Clamp Extend / Retract </li> </ol>"},{"location":"SPT%20Training/MachineCodeProgression.html#state-machine-planning","title":"State Machine planning","text":"<p>The Machine Module will control each of the Equipment Modules by sending commands and monitoring their statuses. The sequential operation of the overall machine can therefore be defined within the Execute method of the Machine Module.</p> <ol> <li> <p>Create a sequence of operations for each Equipment Module under the Machine Module.</p> <p>This will also be where the Machine Module handles the interaction between the Equipment Modules to prevent mechanical collisions, and the transfer of parts and data from one EM to the next.</p> </li> <li> <p>Within each Equipment Module create a sequence of operations that will handle commands from the Machine Module and control the components of the Equipment Module.</p> </li> <li> <p>Define any homing or other movement priorities that will need to be managed.</p> <p>Warning</p> <p>Are there any possible mechanical collisions? Consider Servos or Cylinders that must be moved to a specific position or range before another item can be moved.</p> </li> <li> <p>Define Critical alarms within components that will immediately stop the entire machine    a. Estops, Door switches, power failure, etc.</p> </li> <li> <p>Define Critical alarms within components that will immediately stop just an Equipment Module.</p> </li> <li> <p>Define Errors that will immediately stop the entire machine    a. Drive Errors    b. Hardware errors</p> </li> <li> <p>Define Errors that will immediately stop just an Equipment Module</p> </li> <li>Define Warnings for other items such as temperature and tank level tolerances.</li> <li>Decide if the default configuration for Alarm Responses will suit your needs, if not then define what will be needed. Alarm Responses can be customized for each Module and Component.</li> </ol>"},{"location":"SPT%20Training/MachineCodeProgression.html#components","title":"Components","text":"<p>In this you will be planning for how to interact with the components using interfaces. Using the functionality descriptions above create common interfaces for command and status (Extend/Retract, Energize/De-energize, Home/Homed, Reset/Ready, Start, Stop, Running, etc.).</p> <p>Identify what commands and statuses are common among components and consider how they can be grouped together.</p> <p>Assume that a component will have multiple interfaces, some that are shared among most components, some that are shared with only a small number of components, and likely one that is unique to a component. The important part is to identify the commands and statuses that a component will have and place them into an interface. This will encourage the use of programming to the interface, create consistency across variable names, and create reusability and modularity.</p> <p>All components should be created in a way that allows them to be used without the SPT Framework and should be able to be declared in MAIN for individual testing and validation purposes.</p> <ol> <li> <p>Define the methods and properties of the Components. The commands will be the methods that can be called to control the component, and the statuses will be the properties that can be read to determine the current state of the component.     Cylinder<pre><code>    Extend / Extended  \n    Retract / Retracted  \n    Home / Homed  \n</code></pre> Servo Basic<pre><code>    Move to Position  \n    Move at Velocity  \n    Home / Homed  \n    Jog in Direction  \n    Move to Position  \n    Move to Enumerated Positions  \n    Move at Velocity  \n    Move at Enumerated Velocity  \n</code></pre></p> <p>Servo Advanced<pre><code>    Reference (Some axes require a valid reference before any movement)  \n    Discover Hardware Limits  \n    Discover Software Limits  \n</code></pre> Valve<pre><code>    Open / Opened  \n    Close / Closed  \n</code></pre> Temp Controller<pre><code>    Basic:  \n        Change setpoint  \n        Move to set point  \n\n    Advanced:  \n        Discover Tuning Parameters (Auto-Tune)  \n</code></pre></p> </li> <li> <p>Identify and create the Enumerated positions or values for each component</p> </li> <li> <p>Identify and create the Machine Parameters for each component</p> </li> <li> <p>Identify and create a Structure for the recipe values of each component</p> </li> <li> <p>If hardware is available, then configure the hardware parameters and add the necessary code for the manual controls to send commands to the hardware and monitor for feedback.  </p> <p>Tip</p> <p>Keeping the hardware layer separate from the control layer will allow for more flexibility and modularity. For example, not all servos use the same internal command bit to jog forward; therefore, abstracting the Command/Status layer from the hardware control layer allows the lower layer to be replaced when the hardware changes, but the Command/Status layer can remain the same. The downside to this is that the extra layers create more complexity when troubleshooting.</p> </li> <li> <p>Create a tmc file for each Component type (Cylinder, Servo, etc)         Start with the basic 5 Severity levels         Add specific alarms as needed         Add hardware errors, specifically, the ones you encounter during startup.</p> </li> </ol>"},{"location":"SPT%20Training/MachineCodeProgression.html#modules","title":"Modules","text":"<p>Once the list of components is completed, move up to the Equipment Modules and repeat the process for creating their interfaces.</p> <p>Identify what commands and statuses are common among Equipment Modules.</p> <p>Similar to the Components, an Equipment Module will likely have multiple interfaces, some that are shared among other Equipment Modules, and likely one that is unique. The important part is to identify the commands and statuses that an Equipment Module will have and place them into an interface. This will encourage the use of programming to the interface, create consistency across variable names, and create reusability and modularity.</p> <ol> <li> <p>Define Equipment Modules and the Components they will contain.</p> </li> <li> <p>Create the Function Blocks that will be the MM and EMs.</p> </li> <li>Instantiate the Function Blocks along with their Components.</li> <li> <p>Implement the basic CyclicLogic and Initialize methods for each.     In MAIN, add code for Mode and State control or use the Visu from the SPT Framework library.</p> </li> <li> <p>Implement Manual Mode for the Components basic functionality. Most of the machine process should be able to be commanded in Manual. Add the necessary error detection and recovery</p> </li> <li> <p>Implement Maintenance Mode for the Components advanced functionality.  </p> <p>Note</p> <p>Consider the commands that could cause damage to the machine and need to be done with extreme caution.</p> <pre><code>Moving into collision areas  \nMoving beyond software or hardware limits  \nOpening certain valves\n</code></pre> </li> <li> <p>Implement Home mode     Create the sequence across all EMs that will place the components in a known position  </p> <p>Implement priorities if necessary to avoid any possible collisions Reference all axes and place them in a defined position Extend or retract all cylinders Open or close all valves  </p> </li> <li> <p>Implement the \u2018Pre\u2019 modes                 These modes are used for turning on heaters and placing axes or cylinders into recipe positions in preparation for \u2018Production Mode\u2019</p> <p>Note</p> <p>The use of a Pre-Production mode can be used to place the Machine Module in a mode to control the Equipment Modules and walk them through their various \u2018Pre\u2019 modes. As there is no need for an Equipment Module of axes to wait for an Equipment Module of heaters to preheat, each EM can have its own mode that is controlled by the Machine Module.</p> </li> </ol>"},{"location":"SPT%20Training/ModulesSubmodulesAndComponents.html","title":"Modules, Submodules, and Components","text":"<p>The idea of the modules is to logically separate the parts of the machine into controllable pieces based on their mechanical and functional dependencies. The hierarchy used helps to further separate the modules into logical processes that can operate independently or together as a single unit.</p> <p>The PackML standard defines both a Machine Module and an Equipment Module. The purpose of the Machine Module is to act as the communication point for other Machine Modules on other machines working together on the same production line. This enables the possibility of a downstream machine sending a Stopped status up the line so that a machine can enter its Suspended state. The Machine Module is also responsible for sending commands to its Equipment Modules and monitoring their status.</p> <p>The definitions and functionality of a Machine Module and Equipment Module can be unified under the same function block. Therefore, within the SPT Framework we use <code>FB_PackML_BaseModule</code> as the base of all modules, whether they be the Machine Module (MM) or an Equipment Module (EM). According to the Pack ML standard it is possible for an EM to contain other EMs, acting similarly in function to the MM. Due to this similarity the SPT Framework employs a concept of Modules and Submodules. Each of these extends the functionality provided by the <code>FB_PackML_BaseModule</code>. It is the location of the declaration that will define the Module or Submodule hierarchy. It is important to recognize that the PackML documentation will use the term Equipment Modules, the SPT documentation and code comments will refer to Equipment Modules and Submodules interchangeably, and the code will only refer Submodules.</p> <p>These Modules and Submodules will each have their own state machine. By default, they will follow the state machine of the module they are defined within, but it is possible for each module to be in a different state and / or mode. So, while the majority of a machine\u2019s modules might be in Automatic / Idle, some EMs might be in Homing / Execute. The machine could also be designed where all EMs go to Homing / Execute and the EMs that do not require homing simply have no logic to perform other than reporting their status to an upper-level module. This type of design decision is to be decided by the programmer as they are not defined by the standard.</p> <p>Each of these Modules, whether Sub or not, may contain Components (including the Machine Module). Components are the more specific interactions that happen while in a specific Mode and State, such as an Axis, Cylinder, Stack Light, Message Logging, Heating Element, Safety Monitoring, etc. Any module may contain 0,1 or multiple components. Components do not have a state machine defined by the PackML standard but should instead follow any commands issued by the module based on its state machine. Components can however have their own unique state machine internal to the component. A component is not always as simple as a single cylinder or axis, there is also the possibility to create a more complex component. The situation could arise that a machine needs several cylinders to work together in unison, and for this purpose it could be advantageous for a single component to contain multiple cylinders that will respond to a single extend or retract command. However, the argument could also be made that each cylinder should be able to act individually when in manual, and the programmer will have to determine the best way to accomplish this feature request.</p> <p>Components are responsible for managing their own error handling; and should be self-contained code parts, that are reusable without the PackML state machine or the SPT Framework. This will allow for the most flexibility, adaptability, and reuse in the future. Each component should be able to stand alone as its own entity.</p>"},{"location":"SPT%20Training/ModulesSubmodulesAndComponents.html#machine","title":"Machine","text":"<p><pre><code>Machine : FB_Machine EXTENDS FB_PackML_BaseModule\n</code></pre> The top level of the hierarchy is the Machine Module which we typically refer to as the Machine or Machine Module (MM). The module will extend the <code>FB_PackML_BaseModule</code> from the SPT Base Types library. This will give the Machine function block all the functionality within the methods and properties of <code>FB_PackML_BaseModule</code>. This includes the <code>CyclicLogic()</code> and <code>Initialize()</code> methods which are key parts of the SPT Framework. Within the Machine function block instance, we will declare an instance of each Equipment Module that the Machine is responsible for controlling directly. Likely this will be all of the EMs, but there will be exceptions when Submodules are grouped together under another Equipment Module. The Machine may also directly contain some Components, such as a Stack Light, a pressure switch for machine air, the safety monitoring code, a connection to the recipe database, or many other items that don\u2019t need a state machine that is separate from the Machine Module. </p> <p>Because of the way that the SPT Framework works behind the scenes, it is not necessary for each module to have its own method for each state. For example, not all Equipment modules will need a Held state, therefore it does not need to exist only to call its parents method (using Super). However, if the EM needs to do something in addition to what the base class does, then the method can be added to the EM, the unique code can be added, and then the method can call its Super at the end of the method (or any other place depending on what is being done in the code).</p> <p>Note for TwinCAT 4024</p> <p>While a method does not need to be added just to call the SUPER, if the FB is going to be inherited again (grandchild), then any method overridden by the grandchild will need to be added to the child and it's SUPER called, in order to allow the grandchild to call the base method of the original class.</p>"},{"location":"SPT%20Training/ModulesSubmodulesAndComponents.html#controlling-the-ems","title":"Controlling the EMs","text":"<p>From the Machine Module, when a transitional method (Acting State) of the state machine is called (Resetting), it is standard practice to call <code>Super^.Resetting()</code> at the end of the method. The code in the <code>Resetting()</code> method of the base class will then run. The code in <code>FB_PackML_BaseModule.Resetting()</code> will loop through all the Submodules and pass along the commands required in order to move the state machine of each Submodule into Idle. </p> <p>If the programmer wishes to control the state machine of the EMs separately from the Machine Module, this can be done by not calling the <code>Super^.Resetting()</code> method. In this way the EM can be controlled independently of the MM. To be clear, this applies to all methods, in order for the EM to act independently of the MM or a higher-level Submodule, simply do not call the Super from the independent Submodule. </p> <p>Note</p> <p>We are discussing two different hierarchies here, both the MM/EM/Submodules, and the Base/Child/Grandchild classes. The call to the Super is within the hierarchy of the Base/Child/Grandchild class. The core code to advance the state machine forward is within the <code>FB_PackML_BaseModule</code>, therefore when making an EM/Submodule that has an independent state machine it is the call to <code>FB_PackML_BaseModule</code> (Base) that we don\u2019t want to make. </p> <p>The methods for the Primary or Waiting states do not contain any code in the base class. Therefore, all code to be processed must be placed in the method of the Machine Module or Equipment Module.</p>"},{"location":"SPT%20Training/ModulesSubmodulesAndComponents.html#monitoring-the-ems","title":"Monitoring the EMs","text":"<p>The <code>FB_PackML_BaseModule</code> has a method named <code>SubModuleMonitor()</code>, likewise there is an equivalent method for <code>ComponentMonitor()</code>. These methods are responsible for detecting when an EM or Component has an Alarm or Event that needs a response, such as an E-Stop or a controlled stop. Imagine the machine has an unwind with a sensor for the end of the roll. When the sensor detects the end of the roll, it will set the event to TRUE within the Component. The <code>ComponentMonitor()</code> method of the EM can then respond by issuing a Change State command of Suspend to itself in order to go to the Suspended state. The Machine Module will also be calling its <code>SubmoduleMonitor()</code> method and will detect that an EM has entered the Suspended state and then command all other EMs to also enter the Suspended state. This monitor and response will be covered again in more detail in the Alarm and Events document, but for now what is important to understand is that the code within the methods is isolated to a single purpose. There is no code for error detection within the waiting or acting states, and there is no code for issuing hardware commands in the error detection.</p>"},{"location":"SPT%20Training/ModulesSubmodulesAndComponents.html#giving-data-to-ems","title":"Giving Data to EMs","text":"<p>The Equipment Modules are going to need some configuration data that might be based on physical machine measurements, station configuration, or product specific values. It is best to configure the EM to use Properties if these values are being provided by an external source. These properties can be used in one of the following ways: directly provide each value through multiple properties, an instance of a structure that contains several values, a location for the EM to read its values from (such as a file or database location); or if the Machine Module has already retrieved the values from a file or database, then it can provide the property of the EM with a pointer or reference to where that data is available. For now it is important to start thinking about passing data between classes or functions blocks using properties and not through <code>VAR_INPUT</code> and <code>VAR_OUTPUT</code>.</p>"},{"location":"SPT%20Training/ModulesSubmodulesAndComponents.html#exchanging-data-between-ems","title":"Exchanging data between EMs","text":"<p>There are multiple ways for the EMs to communicate with each other. As mentioned above, the most direct way is by using properties. A property of one EM can be read by another EM, or by the Machine Module. If the Machine Module is set up to read specific properties from EMs, then it can have one method for reading a value, and another method for writing the value to the EMs that need that data. The problem with this is that this code in the Machine Module must be maintained to work with any changes in each EM, and the EM code becomes less portable. </p> <p>Using some form of a pointer to reference the actual location of the data is both more efficient for the CPU and the Memory, it also creates code that is more portable. Think of it this way, instead of passing all the values from one EM to another and therefore creating a second copy of that data, we can simply pass a memory address to the other EM to let it know where to find the data. </p> <p>This has multiple benefits: </p> <ol> <li>There is only one copy of the data, this uses less memory and if the data changes, then all EMs have access to the new values at the same time without having to be told the values changed.</li> <li>When the structure of the data changes (new variables added), only the code that will use the new variables has to change,  the code that shares the data doesn\u2019t need to. </li> <li>One of the great benefits is portability, by passing the address of the data in a property, the EM can be easily reused and plugged in to other EMs, even within another project. </li> </ol> Interfaces <p>One of the best ways to make use of passing addresses instead of data is by implementing Interfaces. Interface pointers (or simply Interfaces) provide several benefits, but the important parts for now are the structure of the data and the address where the data exists. When you define an interface, it is simply a blueprint of the structure or layout of the data. We formalize it (make it specific) by adding methods and properties to it, but in its simplest form it\u2019s just an overlay or a map of how the code should interpret the data, you can think of it as the instructions on how to use the data. </p> <p>The second part of an Interface comes into play when we use it. This is when we assign an instance of an interface to a memory address. This is no different that any other variable declaration. In its basic form, a variable is a name given to a location in memory that stores a value. An instance of an interface is still a name given to a location in memory that stores a value, but in this case the value is not simply an integer or structure, but instead is a more complex data type that needs some custom instructions on how to use it. Those instructions are contained within the methods and properties of the Interfaces implementation. </p> <p>Taking things one step further, each instance of the interface creates its own set of those instructions. While the names of the methods and properties are defined in the generic interface, the actual instructions are left to the specific implementation where the interface is used. For those new to OOP and Interfaces this can be a bit overwhelming, the labs will help explain things in a more step by step process. For now, one great example of this is the Homing routine used by the SPT Motion Control library. The <code>FB_BasicAxis</code> has a default homing routine built into the block, but we also have the option to define a homing sequence of our own design and then use an Interface to \u2018point\u2019 the <code>FB_BasicAxis</code> to our homing sequence and use the code there as the homing routine instead of the default. </p> Observer Pattern <p>A specific design pattern exists for our use case of sharing data between modules. Although the cyclic nature of the PLC provides a way to have some of this functionality without fully implementing the pattern, it still provides us with a well-recognized coding practice. The Observer pattern is typically used in PC programming when a piece of code (a class) needs to receive updated information from another class when the data changes. The full implementation of the Observer pattern allows for a class to connect and disconnect at run time. A simple example of this would be a Bluetooth client for a weather station. Imagine having a weather station that allows you to connect via Bluetooth. Due to the limited range of Bluetooth you will not always be connected to it and therefore there is no need for it to send updates. So, when the Bluetooth connection is established, the client will register with the weather station. The station is known as the Observable, and the phone would be the Observer. Once the Observer is registered to the Observable, the Observable will send notifications to the Observer(s). It is possible for the Observable to send the new data, or to simply send the notification and let the Observer handle retrieving the new data. </p> <p>Within the SPT Framework we partially implement this when we register Submodules and Components to a Module in the <code>Initialize()</code> method. Each Submodule or Component is an Observer of the MM or EM that it is registered to, and the MM and EMs are the Observables. The code in the base of the Framework adds each EM to the array <code>ipSubModules</code>. We can then use this array to loop through all of the Submodules (Observers) and send them commands or notify them of a change at the same time. The true Observer pattern allows for Observers to come and go, but in this use case we are not expecting any of the EMs to be detachable from the overall control of the machine. If this is a feature that is needed, it can be added by extending the base class to suit your needs.</p>"},{"location":"SPT%20Training/ModulesSubmodulesAndComponents.html#exchanging-data-with-mms-on-other-plcs","title":"Exchanging data with MMs on other PLCs","text":"<p>The PackML standard uses PackTags to define a common set of Command, Status, and Admin structures. The idea is to allow multiple different companies to build a machine in their own way, but then provide a standard data format by which they will be able to exchange information. It was previously mentioned that a machine in a production line could stop and then need to transmit that status upstream for other machines to not send product downstream, and to accurately log why they stopped. By populating the PackTags the data can be made available to other Machine Modules that will allow them an access point to both send commands and read status information from another machine, while keeping the internal proprietary control code abstracted and isolated from other companies.</p>"},{"location":"SPT%20Training/ModulesSubmodulesAndComponents.html#components-of-the-mm","title":"Components of the MM","text":"<p>Components in general are the building blocks that allow us to make connections between the State Machine and anything that is outside of the PLC. Whether it\u2019s a cylinder, an axis, a stack light, or something non-hardware like a database. The simplest implementation of the SPT Framework would be a Machine Module with a single component, and this will be one of the labs we do early on. Components do not have a state machine defined by the standard, but within the SPT Framework they must extend the <code>FB_ComponentBase</code>. This allows them to be a part of the Framework and provides the minimal <code>CyclicLogic()</code> and <code>Initialize()</code> methods that are necessary. Beyond that the commands, status, and configuration of a component are up to the programmer to implement as needed.</p>"},{"location":"SPT%20Training/ModulesSubmodulesAndComponents.html#equipment-modules","title":"Equipment Modules","text":"<p>EMs are defined by their mechanical and functional dependencies. It would typically be the way we group a machine. A simple machine might have an Infeed, a Process and an Outfeed. Each of these could be an Equipment Module. But what if the process station is 2 axes, or has a cylinder before the axis? Then it\u2019s possible that the process station EM could have Submodules, or each of these could be an EM of the Machine Module. How do you decide on architecture? The effective solution is the one that considers the state machine needs of the EMs. If all of the stations can and should follow the same state machine, then they could possibly be implemented as Components of a single EM. But if there could be a need for one of them to be in a different state or mode then it should be placed within its own EM. Another consideration is Portability. If there is a possibility that another machine design will need an independent EM, then some thought should be given to how the EM design choices will impact that design. If one machine had a station with a cylinder and an axis that could function under the same state machine, but another machine would need them to be independently controlled, it might make sense to separate them into their own EMs. When they are working together under one state machine, they can both be controlled by commands from the MM.</p>"},{"location":"SPT%20Training/ModulesSubmodulesAndComponents.html#here-are-some-things-to-consider-when-deciding-on-the-architecture-of-the-ems","title":"Here are some things to consider when deciding on the architecture of the EMs:","text":"Does the component need its own state machine? <p>A component follows the commands of the EM that it is defined within. These commands are driven by the EMs state machine. For example, we might extend a cylinder in <code>Production.Starting</code>, monitor its position in <code>Production.Execute</code>, and retract it in <code>Production.Completing</code>. If another component will always operate within the same state machine as this component, then we could consider placing them both within the same EM. For example, 2 cylinders that operate on the same mechanical assembly. There is no need to look through the components of the machine and try to find ways to group them together, but instead we should consider when separation is necessary and advantageous. It could be that a component has a unique process that will require it to have its own state machine that is separate from any other on the machine. It is possible that a heating component will need to preheat before the other EMs can go into Production mode. By placing the heating component in its own EM, its mode and state can be completely controlled by its own internal state machine while the other EMs remain in <code>Production.Idle</code>, <code>Production.Starting</code>, or any other mode and state.</p> Does the component follow the state machine of another component? <p>There will be components that follow the same state machine and always work together. Some of these will have mechanical connections that force them to work together, while others will simply need to interact synchronously to achieve the desired outcome. While these components can be placed within the same EM it is important to consider how these components will be controlled. If we have a clamp that is activated by a cylinder, then that clamp could be a component of an EM. If there is a long bar with a clamp and cylinder at each end then these two will be connected mechanically and could therefore be designed as a dual cylinder component within an EM, because we should never move one cylinder without moving the other. But what if there is no mechanical connection? What if we have 4 clamps on each side of a table and we want the recipe to decide which clamps to use based on the size of the part? Do we want to control all clamps with a single command, or do we want the option to open and close each one independently? By answering these questions, we can start to see how some components will need to be grouped together, while others must be separated as either individual components or possibly as individual EMs.</p> Will the component or EM need to change modes independently? <p>In addition to a separate state machine, it could also be that a component has need to change modes separately from another component. While components might generally operate together, it could be that in a special case that a component needs to change modes to perform a unique function. In this case it would be suggested to create a separate EM for this component.</p> What about alarm severity and the reactions to them? <p>As discussed in the Alarms and Events section, each EM can have it own unique alarm responses to each of the five severity levels. Therefore it might be feasible to separate components into different EMs based on their necessary alarm responses. For example, if a heater component might have a need to stay energized during an alarm that would otherwise remove power, then it should be placed within its own EM. This will allow the programmer to define the alarm response for that EM without having to worry about how it will affect the other EMs.</p>"},{"location":"SPT%20Training/ModulesSubmodulesAndComponents.html#submodules","title":"SubModules","text":"When are submodules needed? <p>While all EMs are programmatically Submodules of the MM, there is the possibility for an EM to have a Submodule, and for that Submodule to have a Submodule. While these more complex Submodules are possible there are few times when they are needed. The idea of being able to have independent state machines at this many levels requires some planning. Typically, the use case for this is when two EMs are serving the same purpose, but only one is being used at any given time. For example, if a machine has two Unwind EMs that it will alternate between, then a Supervisory EM for the Unwinds could hold two instances of an Unwind EM, where one is in production and feeding material into the machine, and the other is in manual while the material roll is being replaced. </p> <p>It could also be that you want to group EMs together for the purpose of programmatically isolating them from other EMs. When hot connect groups are used, it could be that all those EMs are grouped together under one larger EM for the purpose of enabling and disabling the hot connect group. It could also be that on a more modular machine design, a group of EMs can be replaced with a different group of EMs depending on the product. This could also be a use case for a group of EMs and therefore create an easier way to integrate that single larger EM into the remainder of the machine.</p>"},{"location":"SPT%20Training/ModulesSubmodulesAndComponents.html#components","title":"Components","text":"<p>Components are the way in which we make a connection between the PLC and anything outside of the PLC, whether it be a Virtual or Real Axis, a cylinder, or a database. We use components to receive commands from the control code and then manage the device of the component. It is important to understand that a component does not have to be used within the PackML state machine, or within the SPT Framework. A component should be able to exist on its own within any project. Ideally components can be declared within any project and reused as needed.</p>"},{"location":"SPT%20Training/ModulesSubmodulesAndComponents.html#setting-values-in-a-component","title":"Setting values in a component","text":"<p>Using properties and parameters we can configure a component for a specific use case. This could be the number of cylinders within the component, the home position of an axis, or the recipe value for the temperature of a heating element. It is preferable to not have any literal values within the component and instead set those values from outside using either parameters or the control code.  </p> <p>Exchanging data between components When a component needs to send or receive a value it can be handled by the <code>CyclicLogic()</code> method of the EM that it is declared within. The process and options are no different than how the EMs exchange data with each other.</p>"},{"location":"SPT%20Training/Overview.html","title":"Overview","text":"<p>The SPT Framework is a collection of libraries that facilitates the creation of standardized machine code and can be reused on future projects due to its modularity and flexibility. The SPT libraries include the necessary objects to create a hierarchical structure to group the machine parts based on their interdependencies and then control those parts with a predefined state machine that can keep the parts synchronized or let them operate independently. The existing control code for external items can be encapsulated within standardized components that can then be utilized by the framework. This allows for rapid development of new machine code when a component such as an axis, cylinder, or database is deployed on future machines. Additionally, the integration of alarm handling enables the programmer to easily create and monitor conditions by separating these concerns from the control code. Because these alarms are created per component, they are portable and easily reused on future projects. These isolated code portions allow for easier development and troubleshooting. </p> <p>The framework is designed to separate the \u2018happy path\u2019 control code from the error detection, the HMI interaction, and the recovery. This enables developers to focus on one subject at a time while lowering the concern for negatively impacting another section of code.</p> <p>There are 2 main pieces of the SPT Framework: Components and Modules. </p> <p></p>"},{"location":"SPT%20Training/Overview.html#components","title":"Components","text":"<p>The components are used to control hardware such as an axis, a cylinder, or any other device connected to the I/O. They can also be the connection point to a database, implement a client/server communication architecture, or add functionality to other components. The purpose of a component is to encapsulate functionality within a standardized function block that can be used by the SPT Framework. Each component has a base set of features that the framework knows how to interact with, any additional functionality of the component can be handled by the code that implements the component. Components can work without the framework and therefore can be developed independently and tested outside of the framework. </p> <p>Components are portable pieces of code that can have multiple instances within a project and also be reused on all projects. This reuse allows for component development time to be reduced each time it is implemented. When managed properly this also allows for future improvements to a component to be integrated into older instances.</p> <p>A common implementation of a component is to encapsulate the functionality of a 3rd party device into a single component. Some hardware vendors will provide a library that can be used to communicate with their hardware. Creating a component from this library will allow development to happen in a single piece of code that can then be reused each time the hardware is reused. While this idea is not unique to the SPT Framework, the features of the framework encourage the use of good coding practices and provide a starting point for proper separation of concerns, along with integration to alarm monitoring and recovery, HMI communication, initialization, and cyclic updates.</p>"},{"location":"SPT%20Training/Overview.html#modules","title":"Modules","text":"<p>The modules which follow a state machine and issue commands to components based on the current state and mode of the module. A module contains 0 or more components and possibly other modules. Each module is responsible for controlling its components while also monitoring each component for any alarms it may have. Modules represent a section of the physical or logical machine. Just like components they provide a standardized way to make the code more reusable, more importantly each module provides a separation of concerns by placing state specific code into individual methods. This allows for code that handles the resetting of errors to be isolated from the code for initializing or preparing for operation. </p> <p>Each project will hold a single Machine Module that is at the top of the hierarchy and contains the Equipment Modules which represent the parts of the machine. This Machine Module (MM) will be responsible for controlling and monitoring each of the Equipment Modules (EMs). When the operator requests for the machine to change modes, it is the responsibility of the MM to command all EMs and wait for them to complete before continuing. The same is true with the state machine. When an operator starts and stops the machine, it is the MM that will command the EMs to change states in the appropriate order.</p>"},{"location":"SPT%20Training/PackMLModeAndStates.html","title":"PackML Modes and States","text":""},{"location":"SPT%20Training/PackMLModeAndStates.html#modes-what-are-they-and-how-to-use-them","title":"Modes \u2013 What are they and how to use them.","text":"<p>The PackML standard allows for 32 possible modes. Within the <code>Tc3_PackML_V2</code> library there is a Global Constant named <code>MaxUnitMode</code> and declared as an integer with an Initial value of 31. There is also a structure named <code>stPMLUnitModeConfiguration</code> declared as an <code>Array [0..MaxUnitMode] of ST_PMLUnitModeConfiguration</code>. This means that we are limited to 32 total possible modes across the entire machine. <code>stPMLUnitModeConfiguration</code> is initialized with values for the first four indexes of the array as defined by the PackML standard.</p> <p>The ENUM <code>E_PMLProtectedUnitMode</code> is defined within the PackML library with 4 values: </p> PackML V3PackML V2 <pre><code>    Invalid\n    Production\n    Maintenance\n    Manual\n</code></pre> <pre><code>    ePMLProtUnitMode_Invalid\n    ePMLProtUnitMode_Production\n    ePMLProtUnitMode_Maintenance\n    ePMLProtUnitMode_Manual\n</code></pre> <p>These four modes correspond to the first for array indexes 0 through 3 of <code>stPMLUnitModeConfiguration</code>. Therefore, we have 28 possible custom modes that can be defined for a machine.</p> <p>Each mode can be customized for which states are available, and from which states transitions are allowed between modes. The Protected Unit Modes are listed within the ENUM <code>E_PMLProtectedUnitMode</code> and are defined by their initialization within <code>stPMLUnitModeConfiguration</code>. These are just the initial values given and therefore they can be modified by the code. It is also important to understand that these modes are not required, they are simply a means by which to separate functionality within a subset of states that work together. </p>"},{"location":"SPT%20Training/PackMLModeAndStates.html#creating-custom-modes","title":"Creating Custom Modes","text":"<p>The remaining 28 indexes in the array (4 through 31) can be assigned to modes that are created by the programmer. The function block <code>PML_UnitModeConfig</code> is provided by the PackML library. The function block requires the enumeration value to be assigned (eMode), a string value for the name (sName), a True/False value for each state that will set the Disable of that state, and a True/False value for each state that will set the Enable for Mode change to or from that state. Only one instance of the <code>PML_UnitModeConfig</code> function block is required as it can be called repeatedly with new information about each unique eMode value. Later we will cover how this function block is implemented within the <code>FB_Machine.Initialize()</code> method of the SPT Framework.     Some other common modes are Clean in Place, Run Out, Semi-Auto, Dry Cycle, Homing, Post-Production, Pre-Heat, and Test. These modes are distinguishable by the differences in commands given within a subset of states. In other words, each mode provides a way to separate commands within the Execute state between Manual, Automatic, or any other mode.</p>"},{"location":"SPT%20Training/PackMLModeAndStates.html#mode-transition-states","title":"Mode Transition States","text":"<p>By having a consistent state machine across all modes, we can transition between modes with some commonality. By default, the wait states are defined as the Mode transition states. For example, Idle or Stopped. It is these states where the machine is waiting on some external factor, such as operator input, before continuing to the next state. At any time, it is possible to call the <code>PML_UnitModeConfig</code> and modify the states which allow for mode change. When changing modes, both modes (from and to) must have the state enabled. </p> <p>The available states are designed in a pattern that allows for a normal startup process to be followed by the desired machine execution and then a way to stop the machine. Additionally, it is also possible to manage unexpected conditions such as Estops and material end.</p> PackML V3PackML V2PackML V2 Mode Transition States <p></p> <p></p> <p></p> <p>Generally, there are two types of states: Wait and Acting. </p> Waiting Acting Stopped Clearing Idle Starting Suspended Execute Aborted Stopping Held Aborting Completed Holding Unholding Suspending Unsuspending Resetting Completing <p>Transitioning from a wait state requires a command to do so, this command can be from either an operator input, or from the logic of the machine. The acting states will complete their logic and then internally issue a <code>StateComplete()</code> which will transition the state machine to the next state.</p> <p>While the state machine has a normal/expected flow there are also 2 commands that can be issued at any time. The first one is the Abort command. When the Abort command is given the state machine will move from its current state to the Abort state. This is typically used for an E-Stop or other abnormal conditions. The Stop command can be issued at any time (excluding while in Abort) and the state machine will switch to the Stopping state. This is typically used for stopping the machine at the request of the operator but could also be used for specific machine conditions.</p> <p>The operator commands to leave a Wait state can be issued directly or code can be written to simply go to the next state in the normal flow. For example, when in the Idle state the Start command must be given to the <code>PML_StateMachine</code> function block. This command can come from the operator issuing the specific command, or it\u2019s also possible to have code that accepts a generic command to go to the next state and then have some code to analyze the current state and determine what proper next state will be.</p> <p>The State Complete command is issued by logic based on the programmed conditions. For example, in the Starting state once the conditions are met the StateComplete command will be issued, and the state machine will transition to the Execute state.</p> <p>When configuring modes with the <code>PML_UnitModeConfig</code> function block it is possible to disable certain states. When a state is disabled, it will still use it normal command to leave that state, and if the following normal state is disabled then the <code>PML_StateMachine</code> function block will manage which state to transition to. It is also possible to have the code pass through a state by simply setting the StateComplete command upon entering or automatically calling the command required to leave a wait state.</p> <p>According to the documentation the Execute state is defined as an Acting state. However, it does not use State Complete as the other acting states do. Instead, the Complete command must be issued in order to transition to the Completing state. This can be done based on some logic such as the number of parts produced, or it could be issued when the operator gives the command at the end of a batch.</p> <p>The Execute state also has the possibility of moving to either the Hold or Suspend state. The Suspend state is used when the machine stops itself based on the defined conditions. Typically, this will be a material-end situation or other possible machine conditions that cause the machine to pause itself. The machine can then return to the Execute state either by operator command or machine logic. The Held state is used by the operator when a condition arises that the operator wishes to pause the machine for. This could simply be for the operator to step away from the machine or to fix an issue before it becomes a larger problem. The operator will then issue the Unhold command to return to the Execute state.</p> <p>Beckhoff InfoSys - PackML Documentation</p>"},{"location":"SPT%20Training/PackMLStateMachine.html","title":"PackMLStateMachine","text":"<p>Calling the state methods Using SequenceState and DesendentSequenceState</p>"},{"location":"SPT%20Training/SPT_Libraries.html","title":"SPT Libraries","text":"<p>The SPT Libraries are stored publicly on github.com<sup>1</sup>. This allows everyone easy access to the latest releases and a central location for everyone to access the libraries, documentation, and also provide feedback to the Special Projects Team (SPT).  The libraries can be added to a development PC by directly downloading the zip file or by using a Software Repository Management tool. While the zip file might be easier for a one time download, using a repo cloning tool is more effective for long term use.</p>"},{"location":"SPT%20Training/SPT_Libraries.html#option-1-download-the-zip-file","title":"Option 1 (Download the zip file):","text":"<p>This method is only recommended for those who wish to explore the libraries and do some simple and temporary testing. For continued use of the libraries Option 2 is the preferred method.</p> <p>Clone the repo by downloading a zip, by simply clicking the green button that says \u2018&lt;&gt; Code\u2019, and at the bottom of the menu that appears select \u2018Download ZIP\u2019. Once the download is complete, extract the zip file to the location of your choosing. Where you extract it to doesn\u2019t matter, and the files can be deleted at the end of the process. Each library can then be installed as instructed below.</p>"},{"location":"SPT%20Training/SPT_Libraries.html#option-2-clone-the-repo","title":"Option 2 (Clone the Repo):","text":"<p>Using a Repo management tool The biggest advantage of using a Repo management tool is the ability to easily update your local repo and have new versions readily available without having to repeat the install process. Starting from the same GitHub page as before click on the green button that says \u2018&lt;&gt; Code\u2019, but this time click the \u2018Copy url to clipboard\u2019 button to the right of the HTTPS url. You can then use this within your cloning tool to make a local copy of the repo (More details are covered in the section on \u2019Other Software Tools\u2019). Once you have a local copy of the repo, your cloning tool can be used to pull updates from the server. This will include not only new versions of existing libraries, but also new libraries added to the repo. Each library can then be installed as instructed below.</p>"},{"location":"SPT%20Training/SPT_Libraries.html#installing-the-libraries","title":"Installing the libraries","text":"<p>Open TwinCAT XAE and from the PLC menu select Library Repository. Set the \u2018Location\u2019 drop down list to \u2018System\u2019 and click the \u2018Install\u2019 button. Locate the extracted files and install them one at a time, multiple versions of the same library can also be installed this way, and any time a new version is available the entire zip file will have to be downloaded again and the install process repeated for the new version of the library. The first library will appear below the Miscellaneous tree item. After TwinCAT XAE is closed and reopened, a new tree item for SPT will appear in the Library Repository.</p>"},{"location":"SPT%20Training/SPT_Libraries.html#using-the-libraries-in-a-project","title":"Using the Libraries in a project","text":"<p>Once the libraries have been installed, they can be added to the project in the same way as any other library. Either double click on the \u2018References\u2019 tree item and select \u2018Add library\u2019 or right-click on the \u2018References\u2019 tree item and select \u2018Add library\u2019. Within the \u2018Add Library\u2019 window navigate to the SPT Base Type library and double click to add it to the project. When a library is added, the default setting is to always use the newest version. Represented by the * in the Library Manager. </p>"},{"location":"SPT%20Training/SPT_Libraries.html#pinned-versions","title":"Pinned Versions","text":"<p>When starting out the option to use the latest version is recommended, but at some point, it might be optimal to pin your library versions (compliance, tracking, etc.). By selecting a library under the References tree item in the Solution Explorer and then viewing its Properties window, you can select a specific version of a library in order to pin your project to that version.</p>"},{"location":"SPT%20Training/SPT_Libraries.html#placeholders","title":"Placeholders","text":"<p>Some libraries make use of other libraries and therefore hold a reference to them, and to the version of the library. By default, the reference to the other libraries will always be set to \u2018Newest Version\u2019, but it could be that a change to a library can break a library that is dependent on it. Or again for compliance, testing, etc. library dependencies might need to be pinned to a version.  While good programming practices should prevent dependency errors it can still happen. For this reason, we can choose the specific version of dependency. Within the \u2018Library Manager\u2019 if you expand a library and one of its dependencies is set to the newest version *. You can use the 'Placeholders' window to select specific dependency versions. Be aware that when this dependency version is set, it will also set the version for the used library. For example, if you add the SPT Base Types library to your project, it has a dependency on the SPT Event Logger library. If you use the Placeholder to set the version of the SPT Event Logger library and then later add the SPT Event Logger library to your project, it will also be pinned to that same version, and it is not possible to set them to different versions.  The other situation where this becomes important is when you open a project that uses a pinned version of a library and you do not have that version available on your system. Your options are to either obtain that version and install it or change the dependency to a version you have (but this can create other compatibility problems).</p>"},{"location":"SPT%20Training/SPT_Libraries.html#install-project-library","title":"Install Project Library","text":"<p>If a full project is provided to you and it contains libraries that you have not previously installed, then from the PLC Project tree item in the Solution Explorer it is possible to install these libraries. It is important to note that the libraries must be present in the project folder that was provided and not just a reference to them. For example, in the demo projects on our GitHub the .gitignore file is configured to ignore the library files; therefore, they are not included within that repository. This means that when you clone the repo if you have not previously installed the SPT libraries you will not be able to compile the project, and if you try to Install Project Libraries it will not be able to because the libraries do not exist within the project folder. To resolve this issue you must separately download and install the SPT libraries.</p> <ol> <li> <p>https://github.com/Beckhoff-USA-Community/SPT-Libraries\u00a0\u21a9</p> </li> </ol>"},{"location":"SPT%20Training/SafetyMonitoring.html","title":"Safety Monitoring","text":""},{"location":"SPT%20Training/SafetyMonitoring.html#overview","title":"Overview","text":"<p>Safety hardware, along with TwinSAFE Groups and Function Blocks, can be monitored through their available State and Diag variables. The SPT Diagnostic library provides the necessary components for monitoring and resetting each of these. </p> <p>All of the safety monitoring components inherit from <code>FB_Component_Safety_Base</code>. This provides the ability for each safety monitoring component to be registered to a module, the same as any other component. If the SPT Framework is not being used, it is still possible to use the components on their own by calling the <code>CyclicLogic()</code> and <code>Reset()</code> methods of the components. </p> <p>The Base Safety component is extended by all other safety monitoring function blocks, and contains a declaration for <code>InfoData AT %I* : ST_SafetyStateDiag</code>. When the Base Safety component is extended by the specific child classes they will inherit this variable for their own use. The <code>Initialization()</code> method of this block will check to see if the variable is linked, and if not, it will set the error bit to true and provide a trace message.</p> Note <p>There is no detection for the link being correct, only that one exists. </p> <p>Additionally, a property of type <code>I_SafetyReset</code> is available. This will allow for an instance of a class that implements the <code>I_SafetyReset</code> interface to be assigned as the reset routine when the <code>Reset()</code> method is called. </p> <p><code>FB_SafetyResetPulse</code> is available for use from the library. An instance of this can be declared and passed into a child class. It is also possible to assign a DependenceFB to any of the child classes. This will allow for error suppression when the defined FB has an error. For example: without the use of a DependenceFB a hardware error can cause consequential errors to be raised for multiple FBs that use the hardware. But when the DependenceFBs are properly defined these extraneous errors can be reduced.</p>"},{"location":"SPT%20Training/SafetyMonitoring.html#safety-group-monitoring","title":"Safety Group Monitoring","text":""},{"location":"SPT%20Training/SafetyMonitoring.html#fb-instances-and-links","title":"FB Instances and Links","text":"<p>An instance of <code>FB_ComponentSafety_Group</code> can be declared as follows: <pre><code>SafetyGroupAutoReset : FB_SafetyResetPulse;\nSafetyGroup_Main     : FB_Component_Safety_Group :=(\n    Name := 'Safety Group Main',\n    SafetyReset := SafetyGroupAutoReset,\n    AutoResetConnectionFaults := TRUE);\n</code></pre></p> <p>A unique instance of the <code>FB_SafetyResetPulse</code> is defined and passed to the instance <code>SafetyGroup_Main</code>. When the code is compiled an instance variable will appear under the Plc Task Inputs of the PLC Instance with the declared name.</p> <p></p> <p>In the code we must call the <code>CyclicLogic()</code> method, and selectively call the <code>Reset()</code> method. It is imperative that the <code>Reset()</code> method be called at least once before valid messages can be logged. When using the SPT Framework this is handled by the state machine.</p> <p>The two links for State and Diag cannot be made until the TwinSAFE logic program has been created. Once created, you will find the TwinSAFE Group Info Data under the EL6910 or other safety controller. For this variable, enabling \u2018Matching Type\u2019 and \u2018Matching Size\u2019 will be helpful.</p> <p></p> <p>For the Diag variable, remove \u2018Matching Type\u2019 and 'Matching Size\u2019, and select \u2018All Types\u2019. Then type diag in the search window. The Diag variable in the <code>ST_SafetyStateDiag</code> is of type UINT and the hardware variable is of type USINT. </p> <p></p> <p>When creating the link there will be a popup window for a Size Mismatch, because we are linking a UINT to a USINT. No changes are needed in the popup window.</p> <p></p> <p>The reason behind this is that some of the Diag variables are of the smaller USINT type, and other Diag variables are a UINT. But in order to use a single structure for all Diag variables, we created the structure with the larger UINT and link it to a smaller variable. Once the link is created, you can see that the link is only to the first 8 bits \u2018Diag&lt;0-7&gt;\u2019:</p> <p></p>"},{"location":"SPT%20Training/SafetyMonitoring.html#alarms","title":"Alarms","text":"<p>The Alarms provided by the <code>FB_Component_Safety_Group</code> are based on the following event class:</p> <p></p> <p>An instance of <code>FB_Component_Safety_ConnectionFB</code> can be declared as follows: <pre><code>SafetyReset   : FB_SafetyResetPulse;\nSafetyOutput  : FB_Component_Safety_ConnectionFB :=(\n    Name := 'EL2904',\n    DependenceFB := SafetyGroup_Main,\n    SafetyReset := SafetyReset);\n</code></pre></p> <p>The SafetyReset instance of <code>FB_SafetyResetPulse</code> is passed to the <code>FB_Component_Safety_ConnectionFB</code>. When the Component\u2019s <code>Reset()</code> method is called, it will in turn call the <code>Execute()</code> method of <code>FB_SafetyResetPulse</code>. The default behavior of the <code>FB_SafetyResetPulse</code> is to toggle the variable <code>Reset</code> which is defined as a <code>%Q*</code> at the duration of the <code>PulseDuration</code> input. The <code>PulseDuration</code> time is a configurable property, with a default of 100ms. If a custom reset is needed, a function block that implements the <code>I_SafetyReset</code> interface can be passed to your instance of <code>FB_Component_Safety_ConnectionFB</code> using the strategy pattern.</p> <p>The <code>FB_Component_Safety_ConnectionFB</code> also uses a DependenceFB which allows for the errors of that function block to suppress the errors of this function block.</p> <p>The <code>SafetyOutput</code> instance will provide the following variables for linking to the safety controller hardware.</p> <p></p> <p>Before the variables in the PLC instance can be linked, the variables in the safety projects must be enabled. Locate the sds for the connection to be monitored, enable the <code>Map State</code> and <code>Map Diag</code> check boxes. This will create the variables needed in the process image.</p> <p></p> <p>Then select the <code>Linking</code> tab and take note of the Name. In this image it is <code>Message_3</code>.</p> <p></p> <p>When the <code>State</code> and <code>Diag</code> variables are linked, it is important to ensure that they are linked to the correct message of the Safety Controller.</p> <p></p> <p>Again, changing the filter options and searching for diag will add in finding the needed variable.</p> <p></p> <p>The component instance will either need to be registered with an EM in the SPT Framework, or the <code>CyclicLogic()</code> and <code>Reset()</code> methods will need to be called appropriately from your code.</p> <p>The alarms provided by the <code>FB_Component_Safety_ConnectionFB</code> are defined in the <code>SafetyConection</code> event class:</p> <p></p> <p>Monitoring a Safety Input is similar to the Safety Output. The biggest difference being the DependenceFB would typically be set to the Safety FB that the input is being passed to (covered in the next section). <pre><code>SafetyInput  : FB_Component_Safety_ConnectionFB :=(\n    Name := 'EL1904',\n    DependenceFB := SafetyEstop,\n    SafetyReset := SafetyReset);\n</code></pre></p> <p>An instance of <code>FB_Component_Safety_EstopFB</code> can be declared as follows: <pre><code>SafetyEstop  : FB_Component_Safety_EstopFB  :=(\n    Name := 'E-Stop',\n    DependenceFB := SafetyOutput,\n    SafetyReset := SafetyReset);\n</code></pre></p> <p>The DependenceFB is set to the <code>SafetyOutput</code> Connection that the safeEstop is driving, if the output is faulted then the safeEstop will also be faulted and its errors will only cause confusing and misdirection.</p> <p>In order to link the State and Diag variables they must first be created in the safety project. After opening the <code>sal</code> file, select the desired safety function block and open the properties window. Under <code>Info Data</code> set the Map Diag and Map State to TRUE.</p> <p></p> <p>This will create the variables under the Safety Controller for linking.</p> <p></p> <p>These links between the PLC and the Safety Controller do not require an offset, and can be linked directly.</p> <p>The component instance will either need to be registered with an EM in the SPT Framework, or the <code>CyclicLogic()</code> and <code>Reset()</code> methods will need to be called appropriately from your code.</p> <p>The alarms provided by the <code>FB_Component_Safety_EStopFB</code> are defined in the SafetyEstop event class:</p> <p></p> <p>The remaining Safety Function Blocks will have a similar configuration. The alarms are defined in the following event classes:</p> <p>Safety Edm</p> <p></p> <p>Safety Mon</p> <p></p>"},{"location":"SPT%20Training/SampleCode.html","title":"Sample Code","text":"<p>Sample projects for specific use cases can be found on our GitHub repository</p> <p>V3 SPT Samples </p> <p>V4 SPT Samples</p> <p>SPT VM Axis: Displays how an axis in one EM can be coupled to an axis in another EM.</p> <p>SPT AX5000 SoE Reset: A sample for replacing the default reset behavior (CoE) with a SoE reset for the AX5000 servo drive. </p> <p>SPT Alarms: Various configurations of alarms and how to configure the state machine responses and recovery.</p> <p>SPT AxisHoming: A sample for the various types of homing routines available from the SPT Motion Control library.</p> <p>SPT Camming: A sample demonstrating the use of camming in the SPT framework. It includes two cam tables, and shows how to modify the running table for the next cycle of the master axis.</p> <p>SPT ControlledStop: When a Component has an error the EM can notify the MM and bring the entire machine to a controlled stop.</p> <p>SPT ExternalSequence: A sample for using the I_MotionSequence interface to provide the FB_ComponentBasicAxis with a custom move sequence. The example specifically uses a reversing sequence.</p> <p>SPT External Setpoint Generator: A sample including both a standard implementation of the External Setpoint Generator for both Velocity and Position, and a SPT specific implementation for using the External Setpoint Generator as an External Sequence.</p> <p>SPT MultiMaster: A sample to display the various gearing and camming options available for a single or multi-master system.</p> <p>SPT Simple Machine: A sample demonstrating a basic machine setup using the SPT framework. This is the smallest possible implementation of the SPT Framework.</p>"},{"location":"SPT%20Training/SampleCode.html#v4-only-samples","title":"V4 Only Samples:","text":"<p>SPT Mode Manager: A sample for creating custom modes.</p> <p>SPT Dynamic Axis Assignment: A sample for dynamically assigning axes to an EM at runtime.</p>"},{"location":"SPT%20Training/StartingNewRepo.html","title":"Starting a new Repository","text":"<p>The repository is a location to store files and information about those files, including a history of the changes made. We use GitHub for our examples and SPT Libraries because it provides us with an online location that can be easily accessed from anywhere and by anyone. When starting a new repository for a project some simple planning should be done, and having a standard design for all your repositories can make them easier to interact with.</p> <p>One of the first items to be added to the repo should be the .gitignore file. If the ignore file is added after a file(s) that is to be ignored, then that file(s) must be dealt with. The .gitignore file is used in order to not save files that change frequently in the background, and also files that you might want to save in a different repository such as libraries. There are also some files that are specific to the user environment and therefore each programmer should have their own local version of these files. The .gitignore file for the SPT_XPlanar_Demo is a good starter file: https://github.com/Beckhoff-USA-Community/SPT_XPlanar_Demo/blob/master/.gitignore or you can create your own at: https://www.toptal.com/developers/gitignore. Further details about the contents of the gitignore file can be found below in the Sample gitignore file.</p> <p>The next point to consider is branches and how you will use them. Currently the default branch for a new repo on GitHub is main. Branches are a great way to make a copy of the existing repo and then try something, if it works then it can be merged back into the main branch, if not then it can be abandoned until later or deleted. Major branches can be made for Release, Development, and many other reasons. From the major branches it is also possible to create additional branches for specific tasks or features. </p> <p>Possibility 1: If using some form of tracking for work items such as Azure DevOps the branches could be names based on the ID of the Work item. This makes searching for branches easier but is less human readable. However, it does create a consistent user interface and adds clarity between the work item and branch associated with it.</p> <p>Possibility 2: Name the branches based on the task to be done. For smaller projects and teams this can work well, especially if the branches are merged back in and deleted afterwards. But this can be a bit challenging as projects and teams grow.</p> <p>Possibility 3: Create folders under a branch, and then branch again as needed. It has been my preference to create a folder and name it after the work item, and then create branched under the folder for the task being done. A work item in Azure can have several child tasks assigned to it; therefore, the folder can be named for the work item number and the branch for the specific task.</p> <p>For example, let\u2019s assume there is a work item \u2018123 JSON additional features\u2019, and it has tasks \u2018read struct\u2019 and \u2018write struct\u2019. A folder on the development branch could be named 123, with a branch under it for each task. All of this design depends on personal preferences and how your project is managed, but having some consistency between your work log and your repository can really help.</p> <p>Something that is nice to have would be a readme file that includes information about what the project is for and any dependencies on external resources that are needed. Also including what version of software was used in the development of the project can be helpful.</p>"},{"location":"SPT%20Training/StartingNewRepo.html#sample-gitignore-file","title":"Sample gitignore file","text":"<p>Note</p> <p>Below is a good starting point for creating a gitnore file. These files are simple text files that can be opened in any text editor.</p> <pre><code># Any text following this symbol is a comment and will be ignored\n## Multiple # are just used for formatting a comment\n</code></pre> <p>The starting location of the files to be ignored is the location of the .gitignore file Entire folders can be ignore by using the folder name followed by a / <pre><code>folderName/\n</code></pre></p> <p>Note</p> <p>Be careful with this as it is recursive and will ignore all folders and subfolders that match that name.</p> <p>Specific files can be ignored by using the file name with its extension <pre><code>Sample.txt\n</code></pre></p> <p>To ignore all files of a specific type you can use the wildcard. The below will ignore all backup files. <pre><code>*.bak\n</code></pre></p> <p>There are times when we generally want to ignore all files of a type, except for some specific ones. The tmc files that we use for the Event Logger is an example of this. Most of the tmc files within the project folder are created and managed by TwinCAT so we could add *.tmc to the gitignore file. However this can cause some problems. Therefore we can specifically include certain tmc files after ignore them in general. By adding a ! to the front of the file name, git knows that that specific file should be included, even though the extension has been ignored.</p> <pre><code>*.tmc\n!myEvents.tmc\n</code></pre> <p>Note</p> <p>Don't include the tmc-file rule if either of the following is true:</p> <ol> <li> <p>You have TwinCAT C++ projects, as the information in the TMC-file is created manually for the C++ projects (in that case, only (manually) ignore the tmc-files for the PLC projects)</p> </li> <li> <p>You have created a standalone PLC-project and added events to it, as these are stored in the TMC-file.</p> </li> <li> <p>Shared tmc files are used to exchange data types that should be persisted in the project</p> </li> </ol> <p>As a place to start you can copy everything below into your .gitignore file. However it should be expected that this file will need to be customized to your specific situation and needs. For a more exhaustive list of possibilities www.toptal.io can be used to generate a file that includes both TwinCAT 3 and Visual Studio files.</p> <pre><code># Visual Studio Files\n*.bak\n*.sln\n*.suo\n*.~u\n.vs\nUpgradeLog.htm\n\n# TwinCAT Files\n*.sln\n\n## .tpy file can be ignored. They are a holdover from CoDeSys and aren't used much by beckhoff\n### Source: https://infosys.beckhoff.com/english.php?content=../content/1033/tc3_sourcecontrol/18014398915785483.html&amp;id=\n*.tpy\n\n## Compilation Process Artifact\n.tmcRefac\n\n## TwinCAT Archive Formats\n*.tnzip\n*.tszip\n*.tfzip\n\n## Build Files\n_CompileInfo\n_Boot\n_Libraries\n\n## TwinCAT Licence Files (Machine Specific)\nTrialLicense.tclrs\n\n## Project Specific Files (Optional)\n### Add folder or file path(s)\n</code></pre>"},{"location":"SPT%20Training/StartingNewTwinCATProject.html","title":"Project settings","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#pin-project-version","title":"Pin project version","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#system-general-pin-version","title":"System \u2013 General \u2013 Pin Version","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#real-time-settings","title":"Real-Time settings","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#xts-and-xplanar-considerations","title":"XTS and XPlanar Considerations","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#core-isolation","title":"Core Isolation","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#xts-and-xplanar-considerations_1","title":"XTS and XPlanar Considerations","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#local-during-development-vs-remote-during-startup","title":"Local during development VS Remote during Startup","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#real-time-settings-read-from-target","title":"Real-Time Settings \u2013 Read from target","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#ams-net-id","title":"AMS Net ID","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#save-in-own-file","title":"Save in own file","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#add-libraries","title":"add libraries","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#spt-base-types","title":"SPT Base Types","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#plan-for-alarms-and-events","title":"Plan for Alarms and Events","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#create-components","title":"Create Components","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#create-ems","title":"Create EMs","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#declare-components-within-ems","title":"declare components within EMs","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#add-initialize-and-cycliclogic-methods","title":"add Initialize and CyclicLogic methods","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#create-control-sources","title":"Create Control Sources","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#add-initialize-and-cycliclogic-methods_1","title":"add Initialize and CyclicLogic methods","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#create-the-mm","title":"Create the MM","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#declare-ems-within","title":"declare EMs within","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#declare-components","title":"declare components","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#add-cyclilogic-methods","title":"add CycliLogic methods","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#add-local-variables-and-properties","title":"add local variables and properties","text":""},{"location":"SPT%20Training/StartingNewTwinCATProject.html#recipes-and-parameters","title":"Recipes and Parameters","text":""},{"location":"SPT%20Training/samples.html","title":"Samples","text":"<p>https://github.com/im-luka/markdown-cheatsheet</p> <p>https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/quickstart-for-writing-on-github</p> <p>https://github.com/markdown-templates/markdown-emojis</p> <p> </p> <p>https://squidfunk.github.io/mkdocs-material/reference/content-tabs/#anchor-links--or-even-me</p> <p>Note</p> <p>Fixed</p> Note <p>Collapsible</p> Interfaces <p>Test text</p> Check this out <p>Test text</p> Watch out!! <p>Don't do it!</p> Example <p><code>Cool Code Here</code></p> Dig into the source     Put text and markup here  Cool Tip <p>The + sign expands the block by default</p> Success <p>Green Check Mark</p> <p>Failure</p> <p>Test</p> <p>Question</p> <p>Test</p> <p>Danger</p> <p>Test    </p> <p>Abstract</p> <p>Test</p> <p>Bug</p> <p>Text</p> <p>Quote</p> <p>Text</p> <p>Task</p> <ul> <li> Green Checked Circle</li> <li> Gray Checked Circle</li> </ul> Tab 1Tab 2 <p>Tab 1 Text</p> <p>Bug</p> <p>Text</p> <pre><code>classDiagram\n    I_BaseFB &lt;|-- I_CyclicFB\n    FB_BaseFB ..|&gt; I_BaseFB    \n    FB_CyclicFB --|&gt; FB_BaseFB\n    FB_CyclicFB ..|&gt; I_CyclicFB\n\n    class I_BaseFB{\n        &lt;&lt;Interface&gt;&gt;\n        +BOOL Busy\n        +BOOL Error\n        +UDINT ErrorID\n    }\n\n    class I_CyclicFB{\n        &lt;&lt;Interface&gt;&gt;\n        +BOOL InitComplete\n        +CyclicLogic()\n    }\n\n    class FB_BaseFB{\n        &lt;&lt;Abstract&gt;&gt;\n        Trace()\n        TraceWithJson()\n        Marker()\n    }\n\n    class FB_CyclicFB{\n        &lt;&lt;Abstract&gt;&gt;\n    }</code></pre> <pre><code>    If SendMsg then\n        SendMsg := FALSE;\n        fbInfoMsg.Send(0);\n    END_IF\n</code></pre> <pre><code>    If SendMsg then\n        SendMsg := FALSE;\n        fbInfoMsg.Send(0);\n    END_IF\n</code></pre> Code block title<pre><code>    If SendMsg then\n        SendMsg := FALSE;\n        fbInfoMsg.Send(0);\n    END_IF\n</code></pre> <p>Combining attributes Title<pre><code>    Code in block\n</code></pre></p> <p>Code Differences - the red background is difficult to see in dark mode <pre><code>-old code\n+new code\n</code></pre></p> <p>Note</p> <p>Note</p> <p>Images can be dragged in from the explorer</p> <p> </p> Logged Trace Message <p></p> Logged Trace Message <p>Bold Text Italic Text</p> Machine Module Events Submodule Events Component Events <p>External Links: VFFS Demo PLC</p> <p>Local Link in another folder: E_AlarmResponse</p> <p>Local link in same folder: E_AlarmResponse</p> <p>Referenced Link - for use when the page is printed github.com[1]</p> <p>Open link in new tab Beckhoff InfoSys - PackML Documentation</p> <p>Footnote: This has a footnote<sup>1</sup>.</p> Method Property Input Output InOut (cyclic) Reset Position (mm) Enable Error Axis  Reference Move(Pos,Vel) Position (inch) Error ID Stop Busy Ready <p>The same for outputs, <code>Axis1.Error</code> or <code>Axis1.GetError()</code>.</p>"},{"location":"SPT%20Training/samples.html#references","title":"References","text":"<p>[1]  https://github.com/Beckhoff-USA-Community/SPT-Libraries</p> <ol> <li> <p>This is the footnote.\u00a0\u21a9</p> </li> </ol>"},{"location":"SPT%20Training/Alarms/AlarmsAndEvents.html","title":"AlarmsAndEvents","text":""},{"location":"SPT%20Training/Alarms/ComponentAlarms.html","title":"Component Alarms","text":"<p>This section will build upon the information covered in the Simple Alarms above; however, we will now implement alarms at the component level within the SPT Framework. If you did not add the SPT Base Types library before, please do so before continuing.</p> <p>The creation of the tmc file will follow the same process, but the idea of creating separate files for each component becomes more important for portability of the component. Create a tmc file for a component with the following events:</p> <p> </p> <p>In the Simple Alarm document, we placed the code directly in the Main POU, for this example we will first need to create a Machine Module and add a Component to it. Start a new project (or use the existing one from above) and add the following libraries as needed: SPT Base Types, Tc3_PackML_V3, SPT Event Logger, and TC3_EventLogger. </p>"},{"location":"SPT%20Training/Alarms/ComponentAlarms.html#create-a-component","title":"Create a Component","text":"<p>Add a new POU named <code>Component</code> that <code>EXTENDS FB_ComponentBase</code> and include the following variable declarations:</p> <pre><code>FUNCTION_BLOCK Component EXTENDS FB_ComponentBase\nVAR\n    ComponentAlarms     : ARRAY[1..COMPONENT_ALARM_COUNT] OF FB_TcAlarm;\n    testCritical        : BOOL;\n    testError           : BOOL;\n    testWarning         : BOOL;\n    testInfo            : BOOL;\n    testVerbose         : BOOL;\n    clearAlarms         : BOOL;\nEND_VAR\n\nVAR CONSTANT\n    COMPONENT_ALARM_COUNT : UDINT := 6; \nEND_VAR\n</code></pre> <p>The size of the Array of <code>ComponentAlarms</code> must match the tmc file, as each index of the array represents one Event in the tmc, the array declaration in the PLC starts at 1 because we have no need to Raise the <code>InitReferenceEvent</code>.</p>"},{"location":"SPT%20Training/Alarms/ComponentAlarms.html#cycliclogic","title":"CyclicLogic","text":"<p>Add the CyclicLogic method to the Component with the following code:</p> <pre><code>IF NOT _InitComplete THEN\n    _InitComplete := Initialize();\n    RETURN;\nEND_IF\n\nSUPER^.CyclicLogic();\n\n(*\n// The following code must be called after SUPER^.CyclicLogic();\n*)\n\n// Update alarm severity from this component\n_CurrentAlarmSeverity := F_GetMaxSeverityRaised(\n    Alarms := ComponentAlarms,\n    CurrentSeverity := _CurrentAlarmSeverity);\n\n_Error := _CurrentAlarmSeverity &gt;= TcEventSeverity.Error;\n</code></pre> <p>The <code>_CurrentAlarmSeverity</code> is set to Verbose in the <code>Super^.CyclicLogic()</code> and therefore it must be called within the component after the call to the base class, otherwise it will never get reset.</p>"},{"location":"SPT%20Training/Alarms/ComponentAlarms.html#createevents","title":"CreateEvents","text":"<p>Add the CreateEvents method with the following code:</p> <pre><code>F_CreateAllEventsInClass(Alarms     := ComponentAlarms,\n                        ClassSize   := SIZEOF(TC_EVENTS.ComponentEvents),\n                        pInitEvent  := ADR(TC_EVENTS.ComponentEvents.InitReferenceEvent),\n                        Prefix      := Name);\n\nSUPER^.CreateEvents();\n</code></pre> <p>This code provides a reference to the <code>InitReferenceEvent</code> in the tmc file and will create a list of events specific to this component. The <code>Name</code> variable passed to the <code>Prefix</code> is declared in the base class and will be set when the component is declared within the Machine Module.</p> <p>The call to the <code>Super^</code> will create any events contained within the base class as provided by the SPT Base Types Library.</p>"},{"location":"SPT%20Training/Alarms/ComponentAlarms.html#raisealarm2args","title":"RaiseAlarm2Args","text":"<p>Add a simple method that will be called and passed the alarm that needs to be raised. This will be used by the next method.</p> <pre><code>METHOD RaiseAlarm2Args\nVAR_IN_OUT\n    Alarm : FB_TcAlarm;\nEND_VAR\n\nVAR_INPUT\n    // The Name of this component will automatically be applied as a prefix to the message\n    String_Text     : STRING; // First String Parameter \n    String_Suffix   : STRING; // Second String Parameter\nEND_VAR\n-------------------------------------------------------------------------------\nF_RaiseAlarmWithStringParameters(Alarm   := Alarm,\n                                String_1 := Name,\n                                String_2 := String_Text,\n                                String_3 := String_Suffix);\n</code></pre>"},{"location":"SPT%20Training/Alarms/ComponentAlarms.html#monitoring","title":"Monitoring","text":"<p>Add the <code>Monitoring()</code> method to the component. This method exists within the base class <code>FB_ComponentBase</code> and will be overridden. Within this method the component will monitor the conditions which can Raise an event. Placing this code in the <code>Monitoring()</code> method reduces the complexity of the other methods and provides a single location within the component to locate the condition that raises the event. </p> <p>Add the following code to the Monitoring method:</p> <pre><code>IF testVerbose AND NOT ComponentAlarms[E_ComponentEvents.VerboseEvent].bRaised THEN\n    RaiseAlarm2Args(Alarm := ComponentAlarms[E_ComponentEvents.VerboseEvent], 'Note_1', 'Note_2');\nEND_IF\n\nIF testInfo AND NOT ComponentAlarms[E_ComponentEvents.InfoEvent].bRaised THEN\n    RaiseAlarm2Args(Alarm := ComponentAlarms[E_ComponentEvents.InfoEvent], 'Note_1', 'Note_2');\nEND_IF\n\nIF testWarning AND NOT ComponentAlarms[E_ComponentEvents.WarningEvent].bRaised THEN\n    RaiseAlarm2Args(Alarm := ComponentAlarms[E_ComponentEvents.WarningEvent], 'Note_1', 'Note_2');\nEND_IF\n\nIF testError AND NOT ComponentAlarms[E_ComponentEvents.ErrorEvent].bRaised THEN\n    RaiseAlarm2Args(Alarm := ComponentAlarms[E_ComponentEvents.ErrorEvent], 'Note_1', 'Note_2');\nEND_IF\n\nIF testCritical AND NOT ComponentAlarms[E_ComponentEvents.CriticalEvent].bRaised THEN\n    RaiseAlarm2Args(Alarm := ComponentAlarms[E_ComponentEvents.CriticalEvent], 'Note_1', 'Note_2');\nEND_IF\n\nSUPER^.Monitoring();\n</code></pre> <p>Each of these <code>test</code> variables were declared earlier in the Component, along with the array of ComponentAlarms. The enumerations used as the array indexes <code>E_ComponentEvent</code> were created from the tmc events. The name <code>ComponentEvents</code> will match the name used within the properties of the event class and not the name of the tmc file.</p> <p>Checking that the event is not already Raised is one of the steps we take to prevent it from being raised every PLC cycle.</p> <p>The <code>Note1</code> and <code>Note2</code> can be replaced by more specific data. Ideally there would be an event in the tmc file for every possible condition. This would allow for a more flexible solution when implementing language translations. However, it is not always possible to know what these events will be when first creating a component. This is where creating an event of each type (Verbose, Info, Warning, Error, and Critical) can be helpful. This allows you to be able to raise any event type and then provide the details when the event is raised. Even when specific events are added to the tmc, <code>Note 1</code> and <code>Note 2</code> can still be used to provide further information about why the event was raised. For example, if a position command is given that exceeds the limits of an axis, these values could be provided, or if a current temperature value is exceeded then the actual and alarm setpoint temperatures can be added using the <code>Notes</code>. </p> <p>This Monitoring method will be called by the <code>CyclicLogic()</code> method of the base class, from here calling the <code>SUPER^.Monitoring()</code> will call the <code>Monitoring()</code> method of the base class which will raise any alarms within the base class. This is also where the <code>_CurrentEventSeverity</code> is set to Verbose. Therefore, when you add the <code>Monitoring()</code> method to your component it is important to call the <code>Super^</code>, otherwise you will have to reset the <code>_CurrentSeverity</code> within your code. If <code>_CurrentSeverity</code> is never reset to Verbose, then it will retain the highest value it has been set to by the <code>F_GetMaxSeverity</code> function, which can trigger an endless cycle of Raising and Clearing the same alarm, or not being able to clear and alarm at all.</p>"},{"location":"SPT%20Training/Alarms/ComponentAlarms.html#reset","title":"Reset","text":"<p>Add a Reset method that will be called by the Equipment or Machine Module. The reset method will call the function <code>F_ClearAllEventsInClass</code> and the array of <code>ComponentAlarms</code> will be passed into it. This will loop through the array of alarms and if and alarm status is set to Raised, then the Clear method will be called on that alarm. Calling the <code>Super^</code> will clear the <code>ComponentBaseAlarms</code>. Any actual hardware reset commands for the component should also be done here.</p> <pre><code>F_ClearAllEventsInClass(Alarms := ComponentAlarms);\nIF SUPER^.Reset() THEN\n    _Error   := FALSE;\n    _ErrorID := 0;\n    Reset    := TRUE;\nEND_IF\n</code></pre>"},{"location":"SPT%20Training/Alarms/ComponentAlarms.html#testing-the-component-alarms","title":"Testing the Component Alarms","text":"<p>In the MAIN POU declare an instance of your component and a variable to trigger the <code>Reset()</code> method</p> <pre><code>Component : Component := (Name:= 'myComponent');\nreset : BOOL;\n</code></pre> <p>Call the <code>CyclicLogic()</code> method of the your component, and a way to call the <code>Reset()</code> method</p> <pre><code>    Component.CyclicLogic();\n\n    IF reset THEN\n        IF Component.Reset() THEN\n            reset := FALSE;\n        END_IF\n    END_IF\n</code></pre> <p>From the <code>Monitoring()</code> method of your component you can now test each alarm and verify that is is raised in the error list. Setting the <code>reset</code> variable to true in <code>MAIN</code> will attempt to clear the alarms. Any alarms that are still set in the <code>Monitoring()</code> method will log both an <code>AlarmCleared</code> and an <code>AlarmRaised</code>, while the ones that are FALSE will simply log <code>AlarmCleared</code>.</p> <p> </p>"},{"location":"SPT%20Training/Alarms/EventLogger.html","title":"Event Logger","text":"<p>The framework uses the Event Logger for its Alarms. While this provides a great deal of flexibility, it also provides some complexity. At a minimum there are 2 separate parts of this system that must be configured. The Type System, and the PLC Code. </p> <p>The Type System holds items that are available globally to the entire TwinCAT system, each of which have a globally unique identifier or GUID. For example, under \u2018Data Types\u2019 we find the data format of the AMS Address, FSoE Structures, IP Address format, and even the NCTOPLC_AXIS_REF. These are all items used by the system that are fixed and do not change. Under the \u2018Event Classes\u2019 tab are some TwinCAT and Windows based events and errors. There are Router events, Real Time events, and ADS events; some of which you may have seen in the past. This list of events exists so that the internal system can refer to each event by its GUID, and not have to be concerned with the details of the event, but only deal with the GUID and what we want to happen (Raise, Clear, etc.). </p> Tip <p>An additional feature of these events is the ability to provide language translation and select the language to be displayed based on a single global selection. </p> <p>There is the possibility to create a custom event for any messages or alarms that you wish to be able to add to the event logger. Once an event has been added to the event logger it can be easily exchanged with both TwinCAT and non-TwinCAT components.</p> <p></p> <p>For example, the XAE can be used to create an Event Class, the XAR will Raise the event, the HMI will display the event, and then there is the possibility to send the event to some other component to log the event.</p> <p>When adding events, it is recommended to add a new tmc file that will hold those events separate from the TwinCAT System. This will allow the events to be modified and held in revision control. Additionally, this will allow for the tmc files to be portable and able to be reused on multiple projects. Because of these options it is also recommended that each EM and Component have their own tmc file.</p> <p>Ideally an event or alarm will be created for every possible condition, this will allow for language translation to be created and used in the HMI; however, to get started you can simply create a single event of each severity type and populate the text from the PLC, and then add specific events later.</p>"},{"location":"SPT%20Training/Alarms/MonitoringAlarms.html","title":"Monitoring Alarms","text":"<p>This section is a continuation of the principles covered in SPT Framework Alarms section above.</p> <p>The supervisory monitoring, response, and clearing of alarms within components and modules requires some configuration to ensure that the alarms are not raised and cleared cyclically, which results in flooding the event logger, and potentially causing other ADS traffic to stop. The below sections will cover how to properly monitor and reset the alarms properly.</p>"},{"location":"SPT%20Training/Alarms/MonitoringAlarms.html#monitoring-components-of-an-em","title":"Monitoring Components of an EM","text":"<p>While a component will monitor its own conditions for raising an alarm, the EM that contains the component will monitor the component and raise an alarm of its own, indicating the condition. The EM has a default set of responses for the 5 levels of alarms, which can be modified in order to invoke the desired response of the state machine for the EM. The MM will then monitor the EM and respond accordingly.</p> <p>The <code>CyclicLogic()</code> method of the EM will call the <code>SUPER^.CyclicLogic()</code> which in turn will call the <code>ComponentMonitor()</code> method. Depending on the current state of the EM, this method will loop through all the components and check if any of them have an alarm. An enumeration of Alarm Responses exists which corresponds to the 5 alarm levels.</p> <p>Here are the defaults:</p> <pre><code>TcEventSeverity     Alarm Response\nVerbose             E_AlarmResponse.NoResponse\nInfo                E_AlarmResponse.NoResponse\nWarning             E_AlarmResponse.NoResponse\nError               E_AlarmResponse.Abort_ImmediateError\nCritical            E_AlarmResponse.Abort_ImmediateError\n</code></pre> Severity Levels <p>The severity levels can be a reason to separate components into different EMs. The need for components to respond differently to severity levels could be a reason to separate them into different EMs. For example, if one component needs to respond to a error with an immediate stop, while another component only needs to respond to a critical alarm with an immediate stop, then it may be best to separate them into different EMs. This is not a requirement, but it is something to consider when designing the system.</p> <p>These defaults are initialized to the array variable <code>_ParentFaultResponseDefinitions</code> in the declaration of <code>FB_ComponentBase</code>. When other responses are required the values of <code>_ParentFaultResponseDefinitions</code> can be modified in your code. <pre><code>    _ParentFaultResponseDefinitions : ARRAY[0..4] OF E_AlarmResponse :=[\n        E_AlarmResponse.NoResponse,\n        E_AlarmResponse.NoResponse,\n        E_AlarmResponse.NoResponse,\n        E_AlarmResponse.Abort_ImmediateError,\n        E_AlarmResponse.Abort_ImmediateError];\n</code></pre></p> <p>In the <code>ComponentMonitor()</code> method of the EM, the components <code>ParentFaultResponseDefinitions</code> are copied to a local variable <code>AlarmResponses</code>. </p> <pre><code>    AlarmResponses := ipComponents[i].ParentResponseDefinitions;\n\n    CASE AlarmResponses[ipComponents[i].CurrentAlarmSeverity] OF\n\n                E_AlarmResponse.Abort_ImmediateError:\n                    AbortImmediateError(ipComponents[i].Name, FALSE);\n\n                E_AlarmResponse.NoResponse:\n                    ;\n</code></pre> <p>We then evaluate the components <code>CurrentAlarmSeverity</code> ranging from 0..4, then we evaluate the <code>AlarmResponses</code> array at that index to determine which method to call. So if the <code>CurrentAlarmSeverity</code> is 0 (TcEventSeverity.Verbose) then the <code>AlarmResponse[TcEventSeverity.Verbose]</code> will be <code>E_AlarmResponse.NoResponse</code>. However; if the <code>CurrentAlarmSeverity</code> is 4 (TcEventSeverity.Critical), the <code>AlarmResponse[TcEventSeverity.Critical]</code> will be <code>E_AlarmResponse.Abort_ImmediateError</code>.</p> <p>Here is another list of the possible Alarm Responses and the method that will be called:</p> <pre><code>    E_AlarmResponse.        Method Call         \n    Abort_ImmediateError    AbortImmediateError()   //Raise Alarm and Change State Abort\n    Abort_Immediate         AbortImmediate()        //Change State Abort\n    Stop_Immediate          StopImmediate()         //Change State Stop\n    Stop_Controlled         StopControlled()        //Change State Stop\n    Hold_Immediate          HoldImmediate()         //Change State Hold\n    Hold_Controlled         HoldControlled()        //Change State Hold\n    Suspend_Immediate       SuspendImmediate()      //Change State Suspend\n    Suspend_Controlled      SuspendControlled()     //Change State Suspend\n    NoResponse              ;                       //Do Nothing\n</code></pre> <p>The code in these methods can be overridden with your own implementation. It is important to remember that there are only 5 Alarm levels and therefore 5 Alarm responses that can be used per EM.</p>"},{"location":"SPT%20Training/Alarms/MonitoringAlarms.html#monitoring-events-of-the-mm","title":"Monitoring Events of the MM","text":"<p>The Machine Module will call it's own <code>ComponentMonitor</code> and <code>SubModuleMonitor</code> methods from <code>CyclicLogic()</code>. However it is possible for the Machine to have its own events that can be monitored in <code>CyclicLogic()</code>. When done properly, if any of these raise an event, the <code>_CurrentAlarmSeverity</code> will be set accordingly. For an Equipment Module the Machine Module will be monitoring this variable through the <code>SubModuleMonitor()</code> method, which is called by <code>CyclicLogic()</code>. However their is no code to monitor and respond to the <code>_CurrentAlarmSeverity()</code> of the Machine Module. Therefore we can use the code within <code>SubModuleMonitor()</code> and modify it to suit our needs. The biggest difference being that the <code>SubModuleMonitor()</code> will loop through all registered SubModules, while the Machine Module only needs to monitor itself.</p> <p>If you have been following along from the beginning we do not yet have a Machine Module. If you are working in your own project then skip ahead</p> <p>Create a new Function Block for the Machine Module <pre><code>    FUNCTION_BLOCK Machine EXTENDS FB_PackML_BaseModule\n    VAR\n        Component : Component := (Name := 'myMachineComponent');\n    END_VAR\n</code></pre> Add the <code>CyclicLogic()</code> method <pre><code>    METHOD PUBLIC CyclicLogic\n\n    IF NOT _InitComplete THEN\n        _InitComplete := Initialize();\n        RETURN;\n    END_IF\n\n    SUPER^.CyclicLogic();\n</code></pre> Add the <code>Initialize()</code> method <pre><code>    METHOD PROTECTED Initialize : BOOL\n\n    Initialize := FALSE;\n    CASE DescendantSequenceState OF\n        0:\n            RegisterComponent(Component);\n            DescendantSequenceState := DescendantSequenceState + 10;\n\n        10:\n            IF SUPER^.Initialize() THEN\n                Initialize := TRUE;\n            END_IF\n    END_CASE\n</code></pre></p> <p>    Create a new method named <code>MachineMonitor()</code> </p> SPT V4SPT V3 <pre><code>    METHOD MachineMonitor\n    VAR\n        AlarmResponses : ARRAY[0..4] OF E_AlarmResponse; //Temporary response array \n    END_VAR\n</code></pre> <pre><code>    IF _CurrentState &lt;&gt; E_PMLState.Aborted \n        AND _CurrentState &lt;&gt; E_PMLState.Aborting \n        AND _CurrentState &lt;&gt; E_PMLState.Clearing \n        AND _CurrentState &lt;&gt; E_PMLState.Stopped \n        AND _CurrentState &lt;&gt; E_PMLState.Stopping THEN\n\n        AlarmResponses := ParentResponseDefinitions;\n\n        CASE AlarmResponses[_CurrentAlarmSeverity] OF\n            E_AlarmResponse.Abort_ImmediateError:\n                AbortImmediateError(Name, TRUE);\n\n            E_AlarmResponse.Abort_Immediate:\n                AbortImmediate();\n\n            E_AlarmResponse.Stop_Immediate:\n                StopImmediate();\n\n            E_AlarmResponse.Stop_Controlled:\n                StopControlled();\n\n            E_AlarmResponse.Hold_Immediate:\n                HoldImmediate();\n\n            E_AlarmResponse.Hold_Controlled:\n                HoldControlled();\n\n            E_AlarmResponse.Suspend_Immediate:\n                SuspendImmediate();\n\n            E_AlarmResponse.Suspend_Controlled:\n                SuspendControlled();\n\n            E_AlarmResponse.NoResponse:\n                ;\n        END_CASE\n    ELSIF _CurrentState = E_PMLState.Stopped \n            OR _CurrentState = E_PMLState.Stopping THEN\n\n        AlarmResponses := ParentResponseDefinitions;\n\n        CASE AlarmResponses[CurrentAlarmSeverity] OF\n            E_AlarmResponse.Abort_ImmediateError:\n                AbortImmediateError(Name, TRUE);\n\n            E_AlarmResponse.Abort_Immediate:\n                AbortImmediate();\n\n            E_AlarmResponse.NoResponse:\n                ;\n        END_CASE\n    END_IF\n</code></pre> <pre><code>    METHOD MachineMonitor\n    VAR\n        AlarmResponses : ARRAY[0..4] OF E_AlarmResponse; //Temporary response array \n    END_VAR\n</code></pre> <pre><code>    IF _CurrentState &lt;&gt; E_PMLState.ePMLState_Aborted \n        AND _CurrentState &lt;&gt; E_PMLState.ePMLState_Aborting \n        AND _CurrentState &lt;&gt; E_PMLState.ePMLState_Clearing \n        AND _CurrentState &lt;&gt; E_PMLState.ePMLState_Stopped \n        AND _CurrentState &lt;&gt; E_PMLState.ePMLState_Stopping THEN\n\n        AlarmResponses := ParentResponseDefinitions;\n\n        CASE AlarmResponses[_CurrentAlarmSeverity] OF\n            E_AlarmResponse.Abort_ImmediateError:\n                AbortImmediateError(Name, TRUE);\n\n            E_AlarmResponse.Abort_Immediate:\n                AbortImmediate();\n\n            E_AlarmResponse.Stop_Immediate:\n                StopImmediate();\n\n            E_AlarmResponse.Stop_Controlled:\n                StopControlled();\n\n            E_AlarmResponse.Hold_Immediate:\n                HoldImmediate();\n\n            E_AlarmResponse.Hold_Controlled:\n                HoldControlled();\n\n            E_AlarmResponse.Suspend_Immediate:\n                SuspendImmediate();\n\n            E_AlarmResponse.Suspend_Controlled:\n                SuspendControlled();\n\n            E_AlarmResponse.NoResponse:\n                ;\n        END_CASE\n    ELSIF _CurrentState = E_PMLState.ePMLState_Stopped \n            OR _CurrentState = E_PMLState.ePMLState_Stopping THEN\n\n        AlarmResponses := ParentResponseDefinitions;\n\n        CASE AlarmResponses[CurrentAlarmSeverity] OF\n            E_AlarmResponse.Abort_ImmediateError:\n                AbortImmediateError(Name, TRUE);\n\n            E_AlarmResponse.Abort_Immediate:\n                AbortImmediate();\n\n            E_AlarmResponse.NoResponse:\n                ;\n        END_CASE\n    END_IF\n</code></pre> <p>Open <code>CyclicLogic</code> and call <code>MachineMonitor()</code> before <code>SUPER^.CyclicLogic()</code></p> <p>Then <code>_Error</code> after <code>SUPER^.CyclicLogic()</code> <pre><code>    //The MachineMonitor is based on the SubModuleMonitor, but is only monitors itself\n    MachineMonitor();\n\n    //\n    SUPER^.CyclicLogic();\n\n    (*\n    // Code must be after SUPER^.CyclicLogic();\n    *)\n\n    // The TcEventSeverity of each Submodule and Component will increase the \n    // _CurrentAlarmSeverity during the call to SUPER^.CyclicLogic().\n    // We then set the local _Error bit based on this\n\n    _Error := _CurrentAlarmSeverity &gt;= TcEventSeverity.Error;\n</code></pre></p>"},{"location":"SPT%20Training/Alarms/ResettingAlarms.html","title":"Resetting Alarms","text":""},{"location":"SPT%20Training/Alarms/ResettingAlarms.html#resetting-components-of-the-mm","title":"Resetting components of the MM","text":"<p>If there are no Components of the Machine then we can clear the Machine Alarms and let the SUPER^.Clearing() handle the rest. But if the Machine Module has one or more components then the process of clearing the alarms must be handled in a slightly different manner. This will prevent an existing alarm condition that is still TRUE from being cleared and raised multiple times.</p> <p>In the Machine.Clearing() method the following code can be used:</p> <p>Note</p> <p>This code is a modified version of what is used in the <code>FB_PackML_BaseModule.Clearing()</code></p> SPT V4SPT V3 <pre><code>    IF NumberOfComponents = 0 THEN\n        F_ClearAllEventsInClass(Alarms := MachineAlarms);\n        SUPER^.Clearing();\n    ELSE\n        CASE SequenceState OF\n            0:\n                F_ClearAllEventsInClass(Alarms := MachineAlarms);\n                SequenceState := SequenceState + 10;\n\n            10:\n                // Send the command to all EMs to change state to Clearing\n                FOR i := 1 TO NumberOfSubModules DO\n                    ipSubModules[i].StateCommand := E_PMLCommand.Clear;\n                END_FOR\n\n                IF BaseAlarms[E_BaseAlarms.ComponentError].bRaised THEN\n                    BaseAlarms[E_BaseAlarms.ComponentError].Clear(0, 0);\n                END_IF;\n\n                IF BaseAlarms[E_BaseAlarms.SubModuleError].bRaised THEN\n                    BaseAlarms[E_BaseAlarms.SubModuleError].Clear(0, 0);\n                END_IF;\n\n                SequenceState := SequenceState + 10;\n\n            20:\n                // Call the Reset method of all Components of the MM\n                FOR i := 1 TO NumberOfComponents DO\n                    IF Parameters_PackML_Base.RESET_COMPONENTS_WITHOUT_ERROR THEN\n                        ipComponents[i].Reset();\n                    ELSE\n                        IF ipComponents[i].Error THEN\n                            ipComponents[i].Reset();\n                        END_IF\n                    END_IF\n                END_FOR\n\n                //Check that all components are Error free and Ready\n                FOR i := 1 TO NumberOfComponents DO\n                    ComponentsReady := ComponentsReady AND NOT ipComponents[i].Error;\n                END_FOR\n\n                IF ComponentsReady THEN\n                    SequenceState := SequenceState + 10;\n                END_IF\n\n            30:\n                //Check that all EMs have finished Clearing and reached the Stopped state\n                FOR i := 1 TO NumberOfSubModules DO\n                    SubModulesReady := SubModulesReady AND (ipSubModules[i].CurrentState = E_PMLState.Stopped);\n                END_FOR\n\n                // Move the MM to the Stopped state\n                IF SubModulesReady AND (StateTasksComplete OR NoStateTasksToComplete) THEN\n                    NoStateTasksToComplete := TRUE;\n                    StateTasksComplete     := FALSE;\n                    StateComplete();\n                END_IF\n        END_CASE\n    END_IF\n</code></pre> <pre><code>    IF NumberOfComponents = 0 THEN\n        F_ClearAllEventsInClass(Alarms := MachineAlarms);\n        SUPER^.Clearing();\n    ELSE\n        CASE SequenceState OF\n            0:\n                F_ClearAllEventsInClass(Alarms := MachineAlarms);\n                SequenceState := SequenceState + 10;\n\n            10:\n                // Send the command to all EMs to change state to Clearing\n                FOR i := 1 TO NumberOfSubModules DO\n                    ipSubModules[i].StateCommand := ePMLCommand_Clear;\n                END_FOR\n\n                IF BaseAlarms[E_BaseAlarms.ComponentError].bRaised THEN\n                    BaseAlarms[E_BaseAlarms.ComponentError].Clear(0, 0);\n                END_IF;\n\n                IF BaseAlarms[E_BaseAlarms.SubModuleError].bRaised THEN\n                    BaseAlarms[E_BaseAlarms.SubModuleError].Clear(0, 0);\n                END_IF;\n\n                SequenceState := SequenceState + 10;\n\n            20:\n                // Call the Reset method of all Components of the MM\n                FOR i := 1 TO NumberOfComponents DO\n                    IF Parameters_PackML_Base.RESET_COMPONENTS_WITHOUT_ERROR THEN\n                        ipComponents[i].Reset();\n                    ELSE\n                        IF ipComponents[i].Error THEN\n                            ipComponents[i].Reset();\n                        END_IF\n                    END_IF\n                END_FOR\n\n                //Check that all components are Error free and Ready\n                FOR i := 1 TO NumberOfComponents DO\n                    ComponentsReady := ComponentsReady AND NOT ipComponents[i].Error;\n                END_FOR\n\n                IF ComponentsReady THEN\n                    SequenceState := SequenceState + 10;\n                END_IF\n\n            30:\n                //Check that all EMs have finished Clearing and reached the Stopped state\n                FOR i := 1 TO NumberOfSubModules DO\n                    SubModulesReady := SubModulesReady AND (ipSubModules[i].CurrentState = ePMLState_Stopped);\n                END_FOR\n\n                // Move the MM to the Stopped state\n                IF SubModulesReady AND (StateTasksComplete OR NoStateTasksToComplete) THEN\n                    NoStateTasksToComplete := TRUE;\n                    StateTasksComplete     := FALSE;\n                    StateComplete();\n                END_IF\n        END_CASE\n    END_IF\n</code></pre>"},{"location":"SPT%20Training/Alarms/SimpleAlarms.html","title":"Simple Alarms","text":"<p>Alarms require a tmc file that contains generic information and configuration about the Event Class, along with PLC code to assign an Alarm function block to an Event Class, and the code to Raise and Clear those Alarms. So that\u2019s 3 parts, the data (tmc file), the alarm (FB_TcAlarm), and the connection between them (F_CreateAllEventsInClass).</p> <p>The tmc file is created in the Type System. The Type System provides a way to create generic data types that can be referenced by the PLC code, and tasks external to the PLC. The motion controller, TwinSAFE, Vision, and even 3rd party software makes use of the Type System. Most of the time this part of TwinCAT is not used by the casual PLC programmer. But to implement the most flexible error handling possible, it is best to define those errors within the Type System. This will allow for them to be grouped together in classes and assigned Severity levels that can be referenced by the PLC code. Additionally, external software such as the HMI can access this information along with translation information and further details such as comments, and Cause/Remedy information when it\u2019s provided.</p> Use a Sandbox <p>When first starting with the tmc editor it is recommended to get familiar with it in a sandbox environment before making changes on your actual project. See section on TMC File Errors below.</p> <p>A new tmc file should be created for each set of alarms (Equipment Modules and Components). This modularity will allow for them to be portable between machines. If the alarm classes are all added to the same tmc file, it can become very large and more difficult to manage.</p>"},{"location":"SPT%20Training/Alarms/SimpleAlarms.html#create-the-tmc-file","title":"Create the tmc file","text":"<p>Warning</p> <p>NO SPACES should exist in the tmc file. Any names created should be done so without spaces. If you notice any text box with a red background, fix this before saving the file. </p> <p>The tmc files can be created within a single folder of the project in order to help more easily manage them later. </p> <p>When a new tmc file is created there is one important feature that must be configured correctly to work properly with the SPT Framework. </p> <p>The first event must be named as follows</p> <pre><code>InitReferenceEvent\n</code></pre> <p>This allows for the PLC code to be consistent throughout the implementation. This first event should be at Pos 0 and Id 1.</p> <p> </p> <p>Further events can be added in any order that you deem logical.</p> <p>Once the events have been added the file must be saved and the Solution Rebuilt. In the Solution Explorer under System, right click on the Type System and select \u2018Add New Item\u2019.</p> <p> </p> <p>In the \u2018Save As\u2019 dialog box you should be at the project level. You can verify this by seeing the _Boot and _Config folders. By default, the folder path is: <code>C:\\Users\\userName\\Documents\\TcXaeShell\\projectName</code>. Create a new folder for the tmc file at this location, call it tmcFiles. </p> <p> </p> <p>Double click on the folder tmcFiles, provide a name for your tmc file (Cylinder) and select \u2018Save\u2019. Right click on the new Cylinder item in the Solution Explorer and select \u2018Edit Project File\u2019. </p> <p> </p> <p>Right click on \u2018Data Types\u2019 and select 'Add new event class\u2019. </p> <p> </p> <p>Select \u2018EventClass1\u2019 and change the Name to match the tmc file name (Cylinder). </p> <p> </p> <p>Expand the 2 items under Data Types. Select \u2018Events\u2019 and add 2 items using the green plus sign. Select the first event and change the name to <code>InitReferenceEvent</code>. </p> <p>Warning</p> <p>It is important that this name matches exactly and is the first event in the list (Id: 1). In the PLC we will use some generic code that always references the <code>InitReferenceEvent</code>. Being consistent with the naming makes this possible. </p> <p>Next, set the severity to Verbose. </p> <p> </p> <p>Select the other two events and change the names to something valid for the error or warning you wish to create. In this example we will set one to warning, and the other to error. Also, change the <code>Display Text</code> to something meaningful, this text is what will be displayed in the <code>Error List</code>. Finally set the Severity to match the Warning and Error. </p> <p> </p> <p>Close the tmc editor window and select <code>Yes</code> to save the tmc file. Double click the new tmc file under the Type System and select the <code>Event Classes</code> tab. Locate the Cylinder row and place a checkbox in the first column; it doesn\u2019t have a name. </p> <p> </p> <p>This checkbox will add the event class to the Type System for this project. Rebuild the Solution and check that you have no errors.</p>"},{"location":"SPT%20Training/Alarms/SimpleAlarms.html#tmc-file-errors","title":"TMC File Errors","text":""},{"location":"SPT%20Training/Alarms/SimpleAlarms.html#no-spaces-allowed","title":"No Spaces Allowed","text":"<p>Warning</p> <p>Spaces are not allowed in the Name of the event or Data Type. This will be indicated by the text box turning red. If you do put a space in the name when you save the file it will be saved with the bad entry. </p> <p> </p> <p>When you perform a Build -&gt; Rebuild Solution, you will notice 2 errors in the Error List. The first error is in the TC_EVENTS file, and the second error is in the TC_EVENTS_CLASSES file. </p> <p> </p> <p>You should first fix the error in the name before continuing.</p> <p> </p> <p>Next, you must manually edit these files to remove these bad entries. Double click on the error in the Error list to open the files (TC_EVENTS and TC_EVENTS_CLASSES). While you can simply remove the line of code that contains the space in the variable name, it is recommended to remove all the data related to it.</p> <p> </p> <p> </p> <p>While it is possible to have more than one bad entry. They should all be deleted.</p> <p>Do not save the file, you can just simply close it.</p> <p>After creating a proper tmc file, the event classes of that file should be associated with the Type System. After you make changes inside the tmc editor, when you close the editor you will be prompted to save the new tmc file. Click yes. You should now be on the Event Classes tab. The left column does not have a name, but it does have an empty check box. Click the check box, close the window, and click yes to save changes.</p>"},{"location":"SPT%20Training/Alarms/SimpleAlarms.html#libraries","title":"Libraries","text":"<p>Within the PLC project the following libraries are required for proper Alarming:  <pre><code>SPT Base Types\nSPT Event Logger\nTc3_EventLoggger\n</code></pre> The SPT Event Logger library provides some specific code to wrap the functionality of the Tc3_EventLogger into function blocks that meet the needs of the SPT Framework. If you are not using the SPT Framework and would just like to use the SPT Event logger library, then the SPT Base Types library is not needed.</p>"},{"location":"SPT%20Training/Alarms/SimpleAlarms.html#component-alarm-declaration","title":"Component Alarm Declaration","text":"<p>For this short sample we will place all the code within the MAIN POU. The first part of the PLC is the connection between the Alarm Function Blocks, and the Type System.</p> <p>To do this we create an array of FB_Alarm (Tc3_EventLogger) and the other variables that will be used.</p> <p><pre><code>VAR\n    Alarms          : ARRAY [1..MAX_ALARMS] OF FB_TcAlarm;\n    CreateEvents    : BOOL;\n    Name            : STRING := 'Test Alarms';\n    AlarmWarning    : BOOL;\n    AlarmError      : BOOL;\n    ClearError      : BOOL;\nEND_VAR\n</code></pre> MAX_ALARMS should be defined as a VAR CONSTANT equal to the number of events created in the tmc file. </p> <pre><code>VAR CONSTANT\n    MAX_ALARMS : INT := 3;\nEND_VAR\n</code></pre> <p>Within the code we call the Function <code>F_CreateAllEventsInClass</code> (SPT Event Logger) pass it the array of alarms, the tmc info along with the <code>InitReferenceEvent</code>, and a string to help identify the specific group of alarms (in a larger program this would be the name of the EM or Component). This function only needs to be called once, so we use a simple resetting Boolean.</p> <p><pre><code>IF CreateEvents THEN\n    CreateEvents := FALSE;\n    F_CreateAllEventsInClass(Alarms     := Alarms, //array of alarms\n                        ClassSize       := SIZEOF(TC_EVENTS.Cylinder), //tmc info\n                        pInitEvent      := ADR(TC_EVENTS.Cylinder.InitReferenceEvent), //tmc info InitReferenceEvent\n                        Prefix          := Name); //string to help identify the specific group of alarms\n\nEND_IF\n</code></pre> Once the alarms have been created within the PLC, code can be added to raise and clear those alarms. In the following example we will directly call the function <code>F_RaiseAlarmWithStringParameters</code> (SPT Event Logger). We can trigger the \u2018Event\u2019 by setting <code>AlarmWarning</code> or <code>AlarmError</code> to TRUE. If it is not already raised, then the function will raise the alarm (Set its state to Raised) and pass the data to the event logger. The extra strings can be used to add extra information to the message that is logged. Once the condition that set <code>AlarmWarning</code> or <code>AlarmError</code> returns to FALSE, the alarm state for the <code>AlarmWarning</code> will be automatically set to Cleared and the <code>AlarmError</code> will require a separate condition to clear the alarm.</p> <pre><code>IF AlarmWarning AND NOT Alarms[2].bRaised THEN\n    F_RaiseAlarmWithStringParameters(Alarm   := Alarms[2],\n                                    String_1 := Name,\n                                    String_2 := 'Note 1',\n                                    String_3 := 'Note 2');\n//Clear the warning when the condition that raised it is gone                                   \nELSIF NOT AlarmWarning AND Alarms[2].bRaised THEN\n    Alarms[2].Clear(0, 0);\nEND_IF\n\nIF AlarmError AND NOT Alarms[3].bRaised THEN\n    F_RaiseAlarmWithStringParameters(Alarm   := Alarms[3],\n                                    String_1 := Name,\n                                    String_2 := 'Note 1',\n                                    String_3 := 'Note 2');\nEND_IF\n\nIF ClearError AND NOT AlarmError AND Alarms[3].bRaised THEN\n    ClearError := FALSE;\n    Alarms[3].Clear(0, 0);\nEND_IF\n</code></pre>"},{"location":"SPT%20Training/Alarms/TraceMessages.html","title":"Trace Messages","text":"<p>Trace messages can be used to log messages to the Output window. Any Function Block that inherits from the <code>FB_BaseFB</code> in the SPT Base Types library will be able to use the <code>Trace()</code> method. At its lowest level the Trace method parametrizes the <code>FB_TcMessage</code> function block from the Tc3_EventLogger library and then calls its <code>Send()</code> method to log the text to the Output window. </p> Note <p>An important feature of the implementation within the SPT library is to help prevent messages from being logged more than once. By default, the library Parameter <code>ALLOW_DUPLICATE_SEQUENTIAL_MESSAGES</code> has an Initial value of FALSE. </p> <p>When using the Trace method any string (literal or variable) can be passed to it, for example: </p> String LiteralString Variable <pre><code>Trace(Message:= 'Test');\n</code></pre> <pre><code>Trace(Message:= myStringValue);\n</code></pre> <p> This will add the following entry in the output window: <pre><code>MSG | 5/24/2024 2:05:31 PM 059 ms | 'Tracing.GlobalTraceLog': Test|19:05:31.0590306|SPT_Alarms.PLC.MAIN.Machine|PLC_PlcTask|44|0\n</code></pre></p> Tip <p>It is required to set the \u2018Show output from:\u2019 drop down list to \u2018TwinCAT\u2019, otherwise the message will not be displayed.</p> <p></p> <p>The string will be displayed along with the Timestamp, the fully qualified name of the POU that calls the Trace method (but not the method name), and the PLC Cycle Number.</p> Danger <p>Care must be taken as the feature that does not allow for duplicate messages applies to a single instance of the Trace method. This means that if the Trace method is called from 2 methods of the same class, with a different string value then the duplication cannot be detected. It also means that if a child and a parent both use the Trace method with a different string value, then this also cannot be detected. Both use cases can cause duplicates to be logged cyclically.</p> <p>The Trace message is good for logging status or confirming code during debug. Placing a Trace message within a state machine can provide confirmation that a state has been entered or completed. It can also be used to log the value of a variable at a specific condition (use TO_String). <pre><code>Trace(Message:= CONCAT('The value is: ', TO_STRING(myVar)));\n</code></pre></p>"},{"location":"SPT%20Training/Components/ComponentGuide.html","title":"Guide","text":"<p>Please see the Guide to write a Component in the Components section.</p>"},{"location":"SPT%20Training/Components/ExtendingExisting.html","title":"Extending an Existing Component","text":"<p>Now that we have a working component, we will use it to build another component. With 2 solenoids we can build a cylinder. We do have the choice of building a complex component that encompasses other components, building a component from scratch using the knowledge we have of another component, or we can build another standalone component that will be controlled in conjunction with the other components by the equipment module.  </p> <p>To help visualize this we can look at a simple declaration of each.</p> <ol> <li>A Cylinder Component that encapsulates 2 Solenoid Components         In this case the Cylinder Component must implement the controls for each of the Solenoid Components, including calling the CyclicLogic method of each, and handling the HMI interactions. While this implementation allows for the reuse of the Solenoid code, it places the burden on the Cylinder component to properly implement all parts of both Solenoid components.</li> <li>A Cylinder Component that directly controls the 2 Solenoids         Using the knowledge of the Solenoid Component to create a new component that directly controls the solenoid outputs is probably the simplest and fastest implementation. The downside is that the modularity of the Solenoid Component is lost. When the Solenoid Component is used for something other than a Cylinder, and a change is made, then that same change will have to be considered for the Cylinder Component. Whereas in the previous use case, the change to the Solenoid Component would be immediately available to the Cylinder Component.</li> <li>A Cylinder that is controlled and monitored by the Equipment module, but has no awareness of the Solenoid outputs         Creating an instance of each component within the Equipment Module (EM) and letting the control be handled at this level is a viable option, however the implementation of the EM is not designed to be as portable as the Components. This means that each time you wish to add a Cylinder to an EM all the interactions will need to be handled/repeated, again. This lends itself to the potential for errors that could be avoided by keeping as much code as possible within the Component.  </li> </ol> <p>The recommendation is to take the time to develop a component that handles things in the most reuseable way possible. While the above examples may seem a bit simplistic, if you consider something more complicated than a Cylinder and its Solenoids you can start to see the benefits. Imagine that after the Cylinder is completed you need multiples of them, and then some of them will use sensors to know when the move is complete. Some with both extend and retract, while others with only retract. Then the Solenoid component is used for a clutch, but the clutch has opened and closed position sensors. The point of this drawn-out scenario is to highlight the fact that components need to be modular, reusable, and flexible. When you isolate yourself to the simple implementation, you will most likely find yourself wishing you had started things differently.</p>"},{"location":"SPT%20Training/Components/ExtendingExisting.html#encapsulating-components","title":"Encapsulating Components","text":"<p>This Cylinder Component contains 2 other components that it must manage in a similar way to how the Framework handles components. The <code>FB_Component_Cylinder</code> must call the <code>CyclicLogic()</code> method of each of them, call their <code>Reset()</code> methods, and handle any possible HMI interactions.  </p> <ol> <li>Create the <code>FB_Component_Cylinder</code> function block and <code>Extend FB_CompnentBase</code> </li> <li>Declare the 2 Solenoid components     FUNCTION_BLOCK FB_Component_Cylinder EXTENDS FB_ComponentBase<pre><code>VAR\n    ExtendSolenoid  : FB_Component_Solenoid;\n    RetractSolenoid : FB_Component_Solenoid;\nEND_VAR\n</code></pre></li> <li> <p>Add the CyclicLogic method and call the overridden method of the base class.     CycleLogic()<pre><code>ExtendSolenoid.CyclicLogic();\nRetractSolenoid.CyclicLogic();\nSUPER^.CyclicLogic();\n</code></pre></p> </li> <li> <p>Previously we added code to call the Initialize method. This code exists in the <code>CyclicLogic()</code> method of the base class and can be copied from there. </p> <p>CyclicLogic()<pre><code>+IF NOT _InitComplete THEN\n+   _InitComplete := Initialize();\n+   RETURN;\n+END_IF\n\nExtendSolenoid.CyclicLogic();\nRetractSolenoid.CyclicLogic();\nSUPER^.CyclicLogic();\n</code></pre> 5. Add the Reset method and call the overridden method of the base class. Along with the reset of the 2 solenoids.</p> Reset()<pre><code>Reset := FALSE;\nIF SUPER^.Reset() THEN\n    ExtendSolenoid.Reset();\n    RetractSolenoid.Reset();\nEND_IF  \n</code></pre> <p>Note</p> <p>The <code>Reset()</code> method of the Solenoid classes both call their <code>Deenergize()</code> method. This might not be the desired outcome. Therefore, consider the possibility of creating a configuration parameter for the <code>FB_Component_Solenoid</code> that allows the user to choose whether the solenoids should be de-energized or energized on <code>Reset()</code>, similar to how the <code>Home()</code> method works.</p> </li> </ol>"},{"location":"SPT%20Training/Components/SelfContained.html","title":"Self-Contained","text":""},{"location":"SPT%20Training/Components/SelfContained.html#self-contained","title":"Self-Contained","text":"<p>These are components that are created from scratch, with no preexisting code other than the <code>FB_ComponentBase</code>. They can be a simple component for a single output, or a more complex component with multiple inputs and outputs. In the below example we will create a simple component to control a solenoid. The simple version of this component will have the ability to energize and de-energize the output, and will have a property to read the status of the solenoid.</p> <p>Note</p> <p>This Simple Solenoid does not properly comply with the rules of the SPT Framework as we are not returning a value from the Energize and Deenergize methods. This is done to keep the example simple. The Better Solenoid will return a value from the Energize and Deenergize methods.</p>"},{"location":"SPT%20Training/Components/SelfContained.html#simple-solenoid","title":"Simple Solenoid:","text":"<ol> <li>Add the <code>SPT Base Types</code> library to your project</li> <li>Create a function block that <code>Extends FB_ComponentBase</code> and name it <code>FB_Component_Solenoid</code></li> <li>Remove the <code>VAR_INPUT</code> and <code>VAR_OUTPUT</code> sections of the declaration <pre><code>FB_Component_Solenoid EXTENDS FB_ComponentBase\n-VAR_INPUT\n-END_VAR\n-VAR_OUTPUT\n-END_VAR\nVAR\nEND_VAR\n</code></pre></li> <li> <p>Declare a local variable for the output <pre><code>VAR\n    _Energize AT %Q* : BOOL;\nEND_VAR\n</code></pre></p> </li> <li> <p>Create 2 methods that return a BOOL, one to turn on the output, and one to turn off the output     Method Declaration<pre><code>METHOD Energize : BOOL;\n</code></pre> Method Implementation<pre><code>_Energize := TRUE;\n</code></pre></p> <p>Method Declaration<pre><code>METHOD Deenergize : BOOL;\n</code></pre> Method Implementation<pre><code>_Energize := FALSE;\n</code></pre></p> </li> <li> <p>Create a property that returns a BOOL to read that value of the output</p> <p>Energized.Get() <pre><code>Energized := _Energize;\n</code></pre></p> </li> <li> <p>To test the Simple Solenoid create an instance of it in MAIN and add the following code: <pre><code>MAIN\nVAR\n    Solenoid : FB_Component_Solenoid;\nEND_VAR\n</code></pre> <pre><code>Solenoid.CyclicLogic();\n\nIF NOT Solenoid.Energized THEN\n    Solenoid.Energize();\nEND_IF\n</code></pre></p> </li> </ol> <p>Note</p> <p>We are not yet making use of anything within the CyclicLogic() method, it is important to build the habit of always calling it. As not doing so will cause problems in the future.</p>"},{"location":"SPT%20Training/Components/SelfContained.html#better-solenoid","title":"Better Solenoid:","text":"<p>While the above Simple Solenoid is functional, to comply with the SPT Framework standards a few changes need to be made. The Better Solenoid will return a value from the <code>Energize()</code> and <code>Deenergize()</code> methods, while also implementing the use of the <code>_Busy</code> and <code>_Error</code> status variables.</p> <p>We will also be adding an inhibit property to prevent the solenoid from operating, along with method to home the solenoid and a few other features.</p> <ol> <li> <p>Add a new Structure and declare the %Q variable    Structure Declaration<pre><code> TYPE ST_IO_Solenoid :\n     STRUCT\n         Energize AT %Q* : BOOL;\n     END_STRUCT\n END_TYPE\n</code></pre></p> </li> <li> <p>Remove the %Q variable and declare an instance of the structure in the FB     <pre><code>FB_Component_Solenoid EXTENDS FB_ComponentBase\nVAR\n-   _Energize AT %Q* : BOOL;\n+   IO : ST_IO_Solenoid;\nEND_VAR\n</code></pre></p> </li> <li> <p>Update the Methods and Properties to use the new instance of the IO structure by replacing <code>_Energize</code> with <code>IO.Energize</code> METHOD Energize<pre><code>-   _Energize := TRUE;\n+   IO.Energize := TRUE;\n</code></pre> METHOD Deenergize<pre><code>-   _Energize := FALSE;\n+   IO.Energize := FALSE;\n</code></pre> Property Energized.Get()<pre><code>-   Energized := _Energize;\n+   Energized := IO.Energize;\n</code></pre></p> </li> <li> <p>Create convenience properties for other statuses     Deenergized.Get()<pre><code>Deenergized := NOT IO.Energize;\n</code></pre></p> </li> <li> <p>Improve the command methods by replacing the existing code with the following Energize()<pre><code>//Prepare to Return FALSE in case the method is not able to complete\nEnergize := FALSE;\n\n//Check for conditions and issue command\nIF NOT _Busy AND NOT _Error THEN\n    IO.Energize := TRUE;\n    //Return TRUE to indicate that the command was accepted\n    Energize := TRUE;\nEND_IF\n</code></pre></p> </li> <li> <p>Repeat for the Deenergize() method Denergize()<pre><code>//Prepare to Return FALSE in case the method is not able to complete\nDeenergize := FALSE;\n\n//Check for conditions and issue command\nIF NOT _Busy AND NOT _Error THEN\n    IO.Energize := FALSE;\n    //Return TRUE to indicate that the command was accepted\n    Deenergize := TRUE;\nEND_IF\n</code></pre></p> <p>Note</p> <p>The <code>_Busy</code> property of the base class <code>FB_ComponentBase</code> is initialized to TRUE and we are now monitoring it in the <code>Energize()</code> and <code>Deenergize()</code> methods, we must set it to FALSE for our methods to complete properly.</p> </li> <li> <p>Add the <code>CyclicLogic()</code> method to the <code>FB_Component_Solenoid</code>, it is important to name this method exactly the same as the name used in the base class <code>FB_ComponentBase</code> since we are overriding that method.</p> CyclicLogic()<pre><code>IF NOT _InitComplete THEN\n    _InitComplete := Initialize();\n    RETURN;\nEND_IF\n\n_Busy := FALSE;\n\nSUPER^.CyclicLogic();\n</code></pre> <p>Note</p> <p>Part of the design of the framework is to not process anything within the <code>CyclicLogic()</code> method until the Initialization process is completed. Therefore, we always start with calling the <code>Initialize()</code> method until it returns TRUE. After which we no longer call the <code>Initialize()</code> method.</p> <p>We set <code>_Busy</code> to FALSE as none of the commands we are currently using will take more than one PLC cycle.</p> <p>Finally, we call the <code>CyclicLogic()</code> method of the base class using <code>SUPER^CyclicLogic()</code>. This will ensure that any required code of the framework is also updated.</p> </li> <li> <p>Temporary Configuration Properties - Some commands are simple enough that they do not need a method, and some properties need to be available for both Reading and Writing.    </p> <p>Declare a local variable that will be controlled by the property <pre><code>FB_Component_Solenoid EXTENDS FB_ComponentBase\nVAR\n    IO : ST_IO_Solenoid;\n+   _Inhibit : BOOL;\nEND_VAR\n</code></pre></p> </li> <li> <p>Add the Inhibit property that will be used to disable commands</p> Inhibit.Set<pre><code>_Inhibit := Inhibit;\n</code></pre> Inhibit.Get<pre><code>Inhibit := _Inhibit;\n</code></pre> </li> <li> <p>Update the methods to check the _Inhibit value before issuing the command Energize()<pre><code>Energize := FALSE;\n\n+IF _Inhibit THEN\n+   Trace('Energize Inhibited');\n+   RETURN;\n+END_IF\n\nIF NOT _Busy AND NOT _Error THEN\n    IO.Energize := TRUE;\n    Energize    := TRUE;\nEND_IF\n</code></pre></p> </li> <li> <p>Add the same code to the Deenergize() method and change the TRACE message. Deenergize()<pre><code>Deenergize := FALSE;\n\n+IF _Inhibit THEN\n+   Trace('Deenergize Inhibited');  \n+   RETURN;\n+END_IF\n\nIF NOT _Busy AND NOT _Error THEN\n    IO.Energize := FALSE;\n    Deenergize := TRUE;\nEND_IF\n</code></pre></p> <p>Note</p> <p>The <code>FB_ComponentBase</code> has a property for <code>InSimulation</code>, the code that implements your component can set/get this variable. The default implementation of <code>InSimulation</code> is to log a message when it is set to TRUE. Any other use of the variable would be up to you. </p> </li> </ol>"},{"location":"SPT%20Training/Components/SelfContained.html#hmi-control","title":"HMI Control","text":"<p><code>FB_ComponentBase</code> provides some basic functionality to manage a component\u2019s interaction with an HMI. Mainly providing status information about the component in general: <code>Busy, Error, ErrorID, InSimulation</code>, and even the provided <code>Name</code>.</p> <ol> <li> <p>Add the following 4 structures, with the respective variables. Take note that the ST_HMI_ structure contains an instance of the other 3, and the Config structure does not yet contain any variables. It is important to provide unique and descriptive names for each structure type.     ST_Command_Solenoid<pre><code>Energize : BOOL;\nDeenergize : BOOL;\n</code></pre> ST_Config_Solenoid<pre><code>//None\n</code></pre> ST_Status_Solenoid<pre><code>Energized : BOOL;\nDeenergized : BOOL;\nInhibited : BOOL;\n</code></pre> ST_HMI_Solenoid<pre><code>Cmd : ST_Command_Solenoid;\nCfg : ST_Config_Solenoid;\nSts : ST_Status_Solenoid;\n</code></pre> Create an instance of the ST_HMI_Solenoid in your component.     <pre><code>FB_Component_Solenoid EXTENDS FB_ComponentBase\nVAR\n    IO : ST_IO_Solenoid;\n    _Inhibit : BOOL;\n+   HMI : ST_HMI_Solenoid;\nEND_VAR\n</code></pre></p> </li> <li> <p>Add the <code>HMICommunication()</code> method to your FB. In this method we will add the code to read and write to the previously created HMI structures. It is important that this method be named exactly as the one in the <code>FB_ComponentBase</code>, as we will be overriding that method. Additionally, it is important to note that we do not have to call this method directly as it will be called by the <code>CyclicLogic()</code> method of the base class. The code in this method will accept requests from the HMI, verify that the HMI is allowed to control the component (i.e. machine is in Manual), and provide specific status information to the HMI. Commands from the HMI are typically received through a rising trigger, this facilitates a send and forget methodology and keeps variables from getting left on.  </p> <p>Declare a rising trigger in the component at the function block level <pre><code>FB_Component_Solenoid EXTENDS FB_ComponentBase\nVAR\n    IO : ST_IO_Solenoid;\n    _Inhibit : BOOL;\n    HMI : ST_HMI_Solenoid;\n+   HMICommand_Solenoid_RT : R_TRIG;\nEND_VAR\n</code></pre></p> </li> <li> <p>The <code>FB_ComponentBase</code> has a similar RT and it is important to not create a conflict with it. Therefore, the input conditions for our RT will be that HMI control is allowed, the base is not actively sending a command, and then the commands we wish to monitor from the  HMI. In the <code>HMICommunication()</code> method, add the following code to the beginning of the method.     HMICommunication()<pre><code>HMICommand_Solenoid_RT(CLK :=\n                   //Internal checks\n                    (ComponentBase_Hmi.Status.HMIControlAvailable AND NOT HMICommandActive_Base)\n                    //Commands from HMI\n                        AND (HMI.Cmd.Energize XOR HMI.Cmd.Deenergize));\n</code></pre></p> </li> <li> <p>Next, we need to inform the base class that we have accepted a command and disallow it from accepting one until we are done. The variable <code>HMICommandActive_Descendant</code> is already declared in the <code>FB_ComponentBase</code> for this purpose. HMICommunication()<pre><code>HMICommandActive_Descendant := \n    //Internal Checks \u2013 same as the RT\n    ComponentBase_Hmi.Status.HMIControlAvailable AND \n    //Commands from HMI\n    (HMI.Cmd.Energize OR HMI.Cmd.Deenergize);\n</code></pre></p> </li> <li> <p>We then need to respond to the Commands received from the HMI based on the acceptance through the rising edge trigger and turn off those commands. Notice that we are calling the same methods that the machine code will call. HMICommunication()<pre><code>IF HMICommand_Solenoid_RT.Q THEN\n    IF HMI.Cmd.Energize THEN\n        Energize();\n    END_IF\n    IF HMI.Cmd.Deenergize THEN\n        Deenergize();\n    END_IF\n    //\n    HMI.Cmd.Energize := FALSE;\n    HMI.Cmd.Deenergize := FALSE;\nEND_IF\n</code></pre></p> </li> <li>One of the last things to do is update the status information going back to the HMI. HMICommunication()<pre><code>HMI.Sts.Energized   := IO.Energize;\nHMI.Sts.Deenergized := NOT IO.Energize;\nHMI.Sts.Inhibited   := _Inhibit;\n</code></pre></li> <li>Lastly it is important to call the method of the base class.     HMICommunication()<pre><code>SUPER^.HMICommunication();\n</code></pre></li> </ol>"},{"location":"SPT%20Training/Components/SelfContained.html#other-methods-and-properties","title":"Other Methods and Properties","text":"<p>Other command methods could be used to help in the implementation of a component.  As an example, we could consider a <code>Home()</code> method.  The position for homing would need to be configurable as <code>Energized</code> or <code>Deenergized</code>,  and then the appropriate method could be called from the <code>Home()</code> method.  While this might seem trivial it will allow for the programmer who is implementing the component to write their code as <code>Component.Home()</code> and in one location set a property for the Component to change how it responds. <code>HomeIsDeenergized := TRUE</code>.  Then when the need arises they can change only the <code>HomeIsDeenergized</code> property from TRUE to FALSE, and all of the calls to the <code>Home()</code> method will respond accordingly. </p> <ol> <li>Within <code>ST_Config_Solenoid</code> add the following variable to the structure ST_Config_Solenoid<pre><code>HomeIsDeenergized : BOOL;\n</code></pre></li> <li>Add a property for HomeIsDeenergized HomeIsDeenergized.Get<pre><code>HomeIsDeenergized := HMI.Cfg.HomeIsDeenergized;\n</code></pre> HomeIsDeenergized.Set<pre><code>HMI.Cfg.HomeIsDeenergized := HomeIsDeenergized;\n</code></pre></li> <li> <p>Add a Home() method that returns a BOOL     Method Declaration<pre><code>METHOD Home : BOOL\n</code></pre> Method Implementation<pre><code>Home := FALSE;\nIF HMI.Cfg.HomeIsDeenergized THEN\n    Home := Deenergize();       \nELSE\n    Home := Energize();\nEND_IF\n</code></pre></p> <p>Note</p> <p>The <code>Home()</code> method sets the return value to FALSE at the beginning. Afterwards the selected <code>Deenergize()</code> or <code>Energize()</code> method is called, each of those will return TRUE or FALSE depending on their completion and that value will then be returned from the <code>Home()</code> method.</p> <p>The property <code>HomeIsDeenergized</code> is currently FALSE by default. This can be handled in several ways, but this is a great opportunity to show the purpose of the <code>Initialize()</code> method. </p> </li> <li> <p>Add the <code>Initialize()</code> method and the following code. Again, this method name needs to match the name used by the base class. Method Declaration<pre><code>METHOD Initialize : BOOL;\n</code></pre> Method Implementation<pre><code>HomeIsDeenergized := TRUE;\nInitialize := SUPER^.Initialize();\n</code></pre></p> <p>This code sets the value of the property and then calls the method of the base class so that it may handle the initialization of <code>FB_ComponentBase</code>.</p> <p>Note</p> <p>Notice that we are setting the Property <code>HomeIsDeenergized</code> which calls the <code>Set()</code>  method of that property. Internally that will write directly to <code>HMI.Cfg.HomeIsDeenergized</code>. Within the <code>Initialize()</code> method we could also write to <code>HMI.Cfg.HomeIsDeenergized</code>; however, if we do this then we are bypassing any code that could be placed within the <code>Set()</code> method to ensure data integrity and also ensure that the code in the <code>Initialize()</code> method will continue to work properly if the internal name within the <code>HMI.Cfg</code> structure was to change. When making a decision of which variable to write to, it is better to interact with variables that will be external to the component as they will have a tendency to not change as doing so will potentially break the build for everyone using the component.</p> <p>Tip</p> <p>While it is conveienient to set the configuration properties in the initialize method, it is also possible to set them in the <code>CyclicLogic()</code> method. This is useful if you want to change the configuration properties at runtime. For example, if you have a solenoid that can be configured to either energize or de-energize when homing, you could set the <code>HomeIsDeenergized</code> property in the <code>CyclicLogic()</code> method based on some external condition.</p> </li> </ol>"},{"location":"SPT%20Training/Components/SelfContained.html#testing-the-better-solenoid","title":"Testing the Better Solenoid","text":"<p>To test the Better Solenoid, we can edit the code in <code>MAIN</code>, but first notice that even with all the changes we have made the previous implementation code in <code>MAIN</code> is not required to change.</p> <ol> <li> <p>Add the test code below to <code>MAIN</code> and declare the proper variables.     MAIN Declaration<pre><code>Status              : BOOL;\nStart               : BOOL;\nStop                : BOOL;\nHome                : BOOL;\nInhibit             : BOOL;\nSetHomeDeenergize   : BOOL;\nSetHomeEnergize     : BOOL;\nHomeActive          : BOOL;\n</code></pre></p> <p>MAIN Implementation<pre><code>Solenoid.CyclicLogic();\nStatus := Solenoid.Energized;\n\nIF Start THEN\n    Start := FALSE;\n    Solenoid.Energize();\nEND_IF\n\nIF Stop THEN\n    Stop := FALSE;\n    Solenoid.Deenergize();\nEND_IF\n\nIF SetHomeDeenergize THEN\n    SetHomeDeenergize          := FALSE;\n    Solenoid.HomeIsDeenergized := TRUE;\nEND_IF\n\nIF SetHomeEnergize THEN\n    SetHomeEnergize            := FALSE;\n    Solenoid.HomeIsDeenergized := FALSE;\nEND_IF\n\nIF Home THEN\n    Home := FALSE;\n    Solenoid.Home();\nEND_IF\n\nIF Inhibit THEN\n    Inhibit := FALSE;\n    Solenoid.Inhibit := TRUE;\n    Solenoid.Energize();\nELSE\n    Solenoid.Inhibit := FALSE;\nEND_IF\n</code></pre> While the methods are returning a value, the previous code does not make use of that value. If you wish to confirm these return values, the test code can be modified as follows: <pre><code>IF Home THEN\n    Home := FALSE;\n-   Solenoid.Home();\n+   HomeActive := Solenoid.Home();  \nEND_IF\n</code></pre></p> </li> </ol> <p>Additionaly the return value of the method can be checked by the '''IF''' statement     <pre><code>IF Solenoid.Home() THEN\n    HomeActive := TRUE;\nELSE\n    HomeActive := FALSE;\nEND_IF\n</code></pre></p>"},{"location":"SPT%20Training/Components/SelfContained.html#creating-an-interface","title":"Creating an Interface","text":"<p>An interface can be added to allow for proper access from higher level code. The interface(s) should encompass the methods and properties needed to control and monitor the component.  </p> <ol> <li> <p>Create the interface <code>I_Component_Solenoid</code> </p> </li> <li> <p>Add the following to the Interface Methods<pre><code>Deenergize\nEnergize\nHome\n</code></pre> Properties<pre><code>Deenergized\nEnergized\nHomeIsDeenergized\nInhibit\n</code></pre> Notice that we did not add all of the methods and properties of <code>FB_Component_Solenoid</code> to the interface. We specifically did not add any that are a part of the base class <code>FB_ComponentBase</code>, as they are already a part of the interface for the base class and we don\u2019t need to add them again. When adding the methods and properties ensure that the spelling and return type matches and check the Get/Set of the properties and Delete the ones that are not needed. In this case the Set methods of Energize and Deenergize can be deleted.</p> </li> <li> <p>Change the declaration of the component to implement the interface     <pre><code>FUNCTION_BLOCK FB_Component_Solenoid EXTENDS FB_ComponentBase IMPLEMENTS I_Component_Solenoid\n</code></pre> Adding the interface after creating the class (Function Block) can feel backwards to some, and while prior proper planning can help minimize this it is important to know that interfaces can be modified as needed. Testing the interface can be done by declaring an instance of the interface, assigning the instance of the class to the interface, and replacing the class instance with the interface instance throughout the code.  </p> </li> <li> <p>Declare an instance of the interface in <code>MAIN</code> <pre><code>ipSolenoid : I_Component_Solenoid;\n</code></pre></p> </li> <li>Assign the instance of the class to the instance of the interface after <code>Solenoid.CyclicLogic()</code> <pre><code>Solenoid.CyclicLogic();\n+ipSolenoid := Solenoid;\n-Status := Solenoid.Energized;\n+Status := ipSolenoid.Energized;\n</code></pre> As above replace the calls to <code>Solenoid</code> with <code>ipSolenoid</code>, but only where the methods and properties of <code>ipSolenoid</code> are used. This means that <code>Solenoid.CyclicLogic()</code> should not be changed, because <code>CyclicLogic()</code> is not part of the <code>ipSolenoid</code> interface.  The code is now ready for testing with the interface.</li> </ol> <p>Note</p> <p>Although this may seem like it is not useful, once we get deeper into object-oriented programming these interfaces will become very powerful and useful. To prevent having to modify your code it is best to create the interface before creating the class and try to predict the properties and methods that will be needed. Even if you start with an empty interface and add to it as needed during the development cycle it will save you time in the long run. Another point to note is that you can copy and paste between the FB and the Interface. If you wish to create methods and properties on the FB first, you can then copy them from the FB and paste them to the Interface. </p> <p>Warning</p> <p>DO NOT drag and drop from the FB to the Interface, as this will remove the code.</p>"},{"location":"SPT%20Training/Components/SelfContained.html#reset","title":"Reset","text":"<p><code>FB_ComponentBase</code> and Implements the interface <code>I_ComponentBase</code> which defines the method <code>Reset()</code>. This method is used by the base class to call <code>F_ClearAllEventsInClass</code>, which currently only contains the message for <code>InSimulation</code>. However this allows us to override and call the <code>Reset()</code> method for all components via the interface. For this example we will deenergize the <code>Solenoid</code> in the <code>Reset()</code> method. </p> <ol> <li>Add the a method to the component and select <code>Reset</code> from the <code>Name</code> drop down list.        </li> <li>For the implementation of the method, return the proper values, call the <code>Reset()</code> method of the base class, and the <code>Deenergize()</code> method.     Reset()<pre><code>Reset := FALSE;\nIF SUPER^.Reset() THEN\n        Reset := Deenergize();\nEND_IF\n</code></pre> The method can be called from MAIN using the following, but take notice that we are not using the interface, and if you look at the intellisense drop down list of ipSolenoid, the Error and Reset items are not listed. MAIN<pre><code>IF Solenoid.Error THEN\n    Solenoid.Reset();\nEND_IF\n</code></pre> If we extend the I_Component_Solenoid interface from the I_ComponentBase interface, then the methods and properties of that interface will be available. Double click on the <code>I_Component_Solenoid</code> and modify the declaration to match the following I_Component_Solenoid<pre><code>INTERFACE I_Component_Solenoid EXTENDS I_ComponentBase\n</code></pre> Return to MAIN and update the code to use the interface ipSolenoid     MAIN<pre><code>IF ipSolenoid.Error THEN\n    ipSolenoid.Reset();\nEND_IF\n</code></pre></li> </ol>"},{"location":"SPT%20Training/Components/TypesOfComponents.html","title":"Overview","text":"<p>There are several types of components that can be created. The following are the types of components that can be created in SPT:</p> <ol> <li> <p>Self Contained: These are components that are created from scratch. They can be a simple component for a single output, or a more complex component with multiple inputs and outputs.</p> </li> <li> <p>Extending and existing Component: If an existing component is not exactly what you need, you can create a new component that extends the existing component. This allows you to add additional functionality to the existing component without changing the existing component. This could be done when you need an array of a component to work as a single component, or when you need to add additional inputs or outputs to an existing component.</p> </li> <li> <p>From an existing Function Block: If you have a function block that you previously created, that you would like to use as a component, you can create a component that contains the function block. This allows you to reuse code that has already been created and tested. </p> </li> <li> <p>From a 3rd party library: Many times hardware vendors will provide a library for a specific piece of hardware. If you have a library that you would like to use in your project, you can create a component that implements the functionality of the library.</p> </li> </ol>"},{"location":"SPT%20Training/Components/WrappingFB.html","title":"Wrapping an Existing Function Block","text":"<p>Coming Soon...</p>"},{"location":"SPT%20Training/Components/WrappingLibrary.html","title":"Wrapping a Library","text":"<p>Coming Soon...</p>"},{"location":"SPT_Base_Types/index.html","title":"Class Diagram Base","text":"<pre><code>classDiagram\n    I_BaseFB &lt;|-- I_CyclicFB\n    FB_BaseFB ..|&gt; I_BaseFB    \n    FB_CyclicFB --|&gt; FB_BaseFB\n    FB_CyclicFB ..|&gt; I_CyclicFB\n\n    class I_BaseFB{\n        &lt;&lt;Interface&gt;&gt;\n        +BOOL Busy\n        +BOOL Error\n        +UDINT ErrorID\n    }\n\n    class I_CyclicFB{\n        &lt;&lt;Interface&gt;&gt;\n        +BOOL InitComplete\n        +CyclicLogic()\n    }\n\n    class FB_BaseFB{\n        &lt;&lt;Abstract&gt;&gt;\n        Trace()\n        TraceWithJson()\n        Marker()\n    }\n\n    class FB_CyclicFB{\n        &lt;&lt;Abstract&gt;&gt;\n    }\n\n</code></pre>"},{"location":"SPT_Base_Types/index.html#design-notes","title":"Design Notes","text":"<p>Throughout the framework libraries a common pattern is used for initialization routines and how they are called.  </p> <p>Most function blocks will implement <code>I_CyclicFB</code> by way of inheriting <code>FB_CyclicFB</code>.  The entry point for these function blocks is <code>CyclicLogic()</code>.  <code>FB_CyclicFB</code> already contains a local variable backing the <code>InitComplete</code> property: <code>_InitComplete : BOOL</code>.  We can utilize this in our function blocks and assure all necessary initialization steps have been carried out before executing any further code.  This can be useful, for example, to make sure pointers are initialized before referencing them.  Another example may be waiting for another function block to set a property on our function block--useful when implementing the Observer pattern.</p> <pre><code>IF NOT _InitComplete THEN  \n    _InitComplete := Initialize();\n    RETURN;\nEND_IF\n\n...code to run once initialization is complete\n</code></pre>"},{"location":"SPT_Base_Types/index.html#class-diagram-packml-base-module","title":"Class Diagram PackML Base Module","text":"SPT V4SPT V3 <pre><code>classDiagram\n    I_PackML_BaseModule --|&gt; I_CyclicFB\n    I_PackML_BaseModule --|&gt; I_PackML_Control\n    I_PackML_BaseModule --o TcEventSeverity\n    I_PackML_BaseModule --o E_AlarmResponse\n\n    I_PackML_Control --o E_PMLUnitMode\n    I_PackML_Control --o E_PMLState\n    I_PackML_Control --o E_PMLCommand\n\n    FB_PackML_BaseModule --|&gt; FB_CyclicFB\n    FB_PackML_BaseModule ..|&gt; I_PackML_BaseModule\n    FB_PackML_BaseModule ..|&gt; I_PackML_Control\n    FB_PackML_BaseModule --o I_PackML_ExternalController\n\n    I_PackML_ExternalController --o I_PackML_Control\n\n\n\n    FB_CyclicFB ..|&gt; I_CyclicFB\n\n    class I_PackML_BaseModule{\n        &lt;&lt;Interface&gt;&gt;\n        +TcEventSeverity CurrentAlarmSeverity\n        +BOOL LogModeChanges\n        +BOOL LogStateChanges\n        +STRING Name\n        +ARRAY[0..4] OF E_AlarmResponse ParentResponseDef\n    }\n\n    class I_PackML_Control{\n        &lt;&lt;Interface&gt;&gt;\n        +E_PMLUnitMode CurrentMode\n        +E_PMLState CurrentState\n        +DINT ModeCommand\n        +E_PMLCommand StateCommand\n        +ChangeMode()\n        +ChangeState()\n    }\n\n    class I_PackML_ExternalController{\n        &lt;&lt;Interface&gt;&gt;\n        +I_PackML_Control Control\n        +ModeChanged()\n        +StateChanged()\n    }\n\n\n    class FB_PackML_BaseModule{\n        &lt;&lt;Abstract&gt;&gt;\n        #AbortImmediate()\n        #AbortImmediateError()\n        #HoldControlled()\n        #HoleImmediate()\n        #StopControlled()\n        #StopImmediate()\n        #SuspendControlled()\n        #SuspendImmediate()\n        #AllowHMIControl()\n        #BlockHMIControl()\n        #HMICommunication()\n        #HMIPermissions()\n        #ComponentMonitor()\n        #SubModuleMonitor()\n        #Aborting()\n        #Aborted()\n        #Clearing()\n        #Completing()\n        #Completed()\n        #Execute()\n        #Holding();\n        #Held()\n        #Idle()\n        #Resetting()\n        #Starting()\n        #Stopping()\n        #Stopped()\n        #Suspending()\n        #Suspended()\n        #Unholding()\n        #Unsuspending()\n        #Undefined()\n\n        -StateControl()\n        -ModeControl()\n\n        #CreateEvents()\n        #Initialize() BOOL\n        #StateComplete()\n        +RegsterExernalController() BOOL\n\n    }\n\n    class FB_CyclicFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n    class I_CyclicFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class TcEventSeverity{\n        &lt;&lt;enumeration&gt;&gt;\n        Verbose : 0 \n        Info : 1 \n        Warning : 2\n        Error : 3\n        Critical : 4\n    }\n\n    class E_AlarmResponse{\n        &lt;&lt;enumeration&gt;&gt;\n        Abort_ImmediateError\n        Abort_Immediate\n        Stop_Immediate\n        Stop_Controlled\n        Hold_Immediate\n        Hold_Controlled\n        Suspend_Immediate\n        Suspend_Controlled\n        NoResponse\n    }\n\n    class E_PMLUnitMode{\n        &lt;&lt;enumeration&gt;&gt;\n        Invalid\n        Production\n        Maintenance\n        Manual\n        UserModeN\n    }\n\n    class E_PMLState{\n        &lt;&lt;Tc3_PackML_v3&gt;&gt;\n    }\n\n    class E_PMLCommand{\n        &lt;&lt;Tc3_PackML_v3&gt;&gt;\n    }</code></pre> <pre><code>classDiagram\n    I_PackML_BaseModule --|&gt; I_CyclicFB\n    I_PackML_BaseModule --|&gt; I_PackML_Control\n    I_PackML_BaseModule --o TcEventSeverity\n    I_PackML_BaseModule --o E_AlarmResponse\n\n    I_PackML_Control --o E_PMLUnitMode\n    I_PackML_Control --o E_PMLState\n    I_PackML_Control --o E_PMLCommand\n\n    FB_PackML_BaseModule --|&gt; FB_CyclicFB\n    FB_PackML_BaseModule ..|&gt; I_PackML_BaseModule\n    FB_PackML_BaseModule ..|&gt; I_PackML_Control\n    FB_PackML_BaseModule --o I_PackML_ExternalController\n\n    I_PackML_ExternalController --o I_PackML_Control\n\n\n\n    FB_CyclicFB ..|&gt; I_CyclicFB\n\n    class I_PackML_BaseModule{\n        &lt;&lt;Interface&gt;&gt;\n        +TcEventSeverity CurrentAlarmSeverity\n        +BOOL LogModeChanges\n        +BOOL LogStateChanges\n        +STRING Name\n        +ARRAY[0..4] OF E_AlarmResponse ParentResponseDef\n    }\n\n    class I_PackML_Control{\n        &lt;&lt;Interface&gt;&gt;\n        +E_PMLUnitMode CurrentMode\n        +E_PMLState CurrentState\n        +DINT ModeCommand\n        +E_PMLCommand StateCommand\n        +ChangeMode()\n        +ChangeState()\n    }\n\n    class I_PackML_ExternalController{\n        &lt;&lt;Interface&gt;&gt;\n        +I_PackML_Control Control\n        +ModeChanged()\n        +StateChanged()\n    }\n\n\n    class FB_PackML_BaseModule{\n        &lt;&lt;Abstract&gt;&gt;\n        #AbortImmediate()\n        #AbortImmediateError()\n        #HoldControlled()\n        #HoleImmediate()\n        #StopControlled()\n        #StopImmediate()\n        #SuspendControlled()\n        #SuspendImmediate()\n        #AllowHMIControl()\n        #BlockHMIControl()\n        #HMICommunication()\n        #HMIPermissions()\n        #ComponentMonitor()\n        #SubModuleMonitor()\n        #Aborting()\n        #Aborted()\n        #Clearing()\n        #Completing()\n        #Complete()\n        #Execute()\n        #Holding();\n        #Held()\n        #Idle()\n        #Resetting()\n        #Starting()\n        #Stopping()\n        #Stopped()\n        #Suspending()\n        #Suspended()\n        #Unholding()\n        #Unsuspending()\n        #Undefined()\n\n        -StateControl()\n        -ModeControl()\n\n        #CreateEvents()\n        #Initialize() BOOL\n        #StateComplete()\n        +RegsterExernalController() BOOL\n\n    }\n\n    class FB_CyclicFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n    class I_CyclicFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class TcEventSeverity{\n        &lt;&lt;enumeration&gt;&gt;\n        Verbose : 0 \n        Info : 1 \n        Warning : 2\n        Error : 3\n        Critical : 4\n    }\n\n    class E_AlarmResponse{\n        &lt;&lt;enumeration&gt;&gt;\n        Abort_ImmediateError\n        Abort_Immediate\n        Stop_Immediate\n        Stop_Controlled\n        Hold_Immediate\n        Hold_Controlled\n        Suspend_Immediate\n        Suspend_Controlled\n        NoResponse\n    }\n\n    class E_PMLUnitMode{\n        &lt;&lt;enumeration&gt;&gt;\n        ePMLUnitMode_Invalid\n        ePMLUnitMode_Production\n        ePMLUnitMode_Maintenance\n        ePMLUnitMode_Manual\n        ePMLUnitMode_UserModeN\n    }\n\n    class E_PMLState{\n        &lt;&lt;Tc3_PackML_v2&gt;&gt;\n    }\n\n    class E_PMLCommand{\n        &lt;&lt;Tc3_PackML_v2&gt;&gt;\n    }</code></pre>"},{"location":"SPT_Base_Types/changelog.html","title":"Changelog","text":""},{"location":"SPT_Base_Types/changelog.html#401-2025-06-19","title":"[4.0.1] - 2025-06-19","text":""},{"location":"SPT_Base_Types/changelog.html#updated","title":"Updated","text":"<ul> <li>V_MachineModule 'Machine' label width reduced and overall size set to 650,250</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#40-2025-05-20","title":"[4.0] - 2025-05-20","text":""},{"location":"SPT_Base_Types/changelog.html#replaced-dependencies","title":"Replaced Dependencies","text":"<ul> <li>Tc3_PackML_V2 with Tc3_PackML_V3</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#updated_1","title":"Updated","text":"<ul> <li>All references to Tc3_PackML_V2 have been updated to Tc3_PackML_V3</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#compiled","title":"Compiled","text":"<ul> <li>Using TwinCAT 3.1.4026</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#391-2025-06-19","title":"[3.9.1] - 2025-06-19","text":""},{"location":"SPT_Base_Types/changelog.html#updated_2","title":"Updated","text":"<ul> <li>V_MachineModule 'Machine' label width reduced and overall size set to 650,250</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#39-2025-04-14","title":"[3.9] - 2025-04-14","text":""},{"location":"SPT_Base_Types/changelog.html#finalizing","title":"Finalizing","text":"<ul> <li>Internal updates and cleanup</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#33-2025-04-11","title":"[3.3] - 2025-04-11","text":""},{"location":"SPT_Base_Types/changelog.html#sync","title":"Sync","text":"<ul> <li>Implement same version number across all SPT libraries</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#added","title":"Added","text":"<ul> <li>Code formatting and comments</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#3210-2024-03-01","title":"[3.2.10] - 2024-03-01","text":""},{"location":"SPT_Base_Types/changelog.html#added_1","title":"Added","text":"<ul> <li>Added library parameter RESET_COMPONENTS_WITHOUT_ERROR</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#3291-2024-01-16","title":"[3.2.9.1] - 2024-01-16","text":""},{"location":"SPT_Base_Types/changelog.html#fixed","title":"Fixed","text":"<ul> <li>3.2.9 broke trace function initialization--fixed now.</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#329-2024-01-03","title":"[3.2.9] - 2024-01-03","text":""},{"location":"SPT_Base_Types/changelog.html#fixed_1","title":"Fixed","text":"<ul> <li>Trace functions are now inhibited until event system is fully initialized</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#328-2023-11-17","title":"[3.2.8] - 2023-11-17","text":""},{"location":"SPT_Base_Types/changelog.html#changed","title":"Changed","text":"<ul> <li>Added OPC-UA access to _HMI structs</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#327-2023-11-13","title":"[3.2.7] - 2023-11-13","text":""},{"location":"SPT_Base_Types/changelog.html#added_2","title":"Added","text":"<ul> <li>Added library parameter INHIBIT_SIMULATION_WARNING</li> <li>Added library patameter STATELOGGER_DISABLED</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#changed_1","title":"Changed","text":"<ul> <li>Removed call_after_online_change_slot pragma from CreateEvents().  This should fix existing issue with online changes causing cycle exceeds.</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#326-2023-10-17","title":"[3.2.6] - 2023-10-17","text":""},{"location":"SPT_Base_Types/changelog.html#added_3","title":"Added","text":"<ul> <li>Added library parameter CONCAT_COMPONENT_NAME_WITH_PARENT</li> <li>Added Protected Methods for ModeChanged() and StateChanged() in FB_PackML_BaseModule</li> <li>Added possibility for independent Mode change via DisableSubModuleModeChange. I_PackML_BaseModule</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#fixed_2","title":"Fixed","text":"<ul> <li>Added Name of Component which raised error in AbortImmediateError()</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#325-2023-09-07","title":"[3.2.5] - 2023-09-07","text":""},{"location":"SPT_Base_Types/changelog.html#added_4","title":"Added","text":"<ul> <li>Added library parameter CONCAT_SUBMODULE_NAME_WITH_PARENT</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#324-2023-08-11","title":"[3.2.4] - 2023-08-11","text":""},{"location":"SPT_Base_Types/changelog.html#added_5","title":"Added","text":"<ul> <li>Added library parameter COMPONENT_NAME_DELIMETER</li> <li>Added library parameter SUBMODULE_NAME_DELIMETER</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#fixed_3","title":"Fixed","text":"<ul> <li>FB_ControlSource was inhibiting Stop commands when module was in Idle state.</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#323-2023-08-02","title":"[3.2.3] - 2023-08-02","text":""},{"location":"SPT_Base_Types/changelog.html#fixed_4","title":"Fixed","text":"<ul> <li>Optimized message filtering logic on Trace() functions</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#322-2023-07-27","title":"[3.2.2] - 2023-07-27","text":""},{"location":"SPT_Base_Types/changelog.html#added_6","title":"Added","text":"<ul> <li>Added RegisterComponent() and RegisterSubmodule() methods to FB_PackML_BaseModule</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#321-2023-06-29","title":"[3.2.1] - 2023-06-29","text":""},{"location":"SPT_Base_Types/changelog.html#added_7","title":"Added","text":"<ul> <li>I_BaseFB now support the use of __SYSTEM.IQueryInterface to allow the use of the __QUERYINTERFACE operator</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#320-2023-06-02","title":"[3.2.0] - 2023-06-02","text":""},{"location":"SPT_Base_Types/changelog.html#added_8","title":"Added","text":"<ul> <li>Added library parameter ALLOW_DUPLICATE_SEQUENTIAL_MESSAGES</li> <li>Added basic testing VISUs that can be connected to modules for rapid testing and debug</li> <li>Added license file to project (MIT License)</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#changed_2","title":"Changed","text":"<ul> <li>By default, Trace() messages sent are filtered if the previous message is identical to the next one.  This helps with the flooding of the message log if, for instance, the logic is stuck in a state where messages are being sent.  See ALLOW_DUPLICATE_SEQUENTIAL_MESSAGES.</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#311-2023-05-08","title":"[3.1.1] - 2023-05-08","text":""},{"location":"SPT_Base_Types/changelog.html#changed_3","title":"Changed","text":"<ul> <li>Removed all references to Tc3_System library</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#310-2023-04-14","title":"[3.1.0] - 2023-04-14","text":""},{"location":"SPT_Base_Types/changelog.html#added_9","title":"Added","text":"<ul> <li>Added FB_ControlSource</li> <li>Added contents of SPT_PackML_Base library as part of consolidation effort</li> <li>Added contents of SPT_ComponentBase library as part of consolidation effort</li> <li>Added contents of SPT_Tracing library as part of consolidation effort</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#302-2023-02-15","title":"[3.0.2] - 2023-02-15","text":""},{"location":"SPT_Base_Types/changelog.html#fixed_5","title":"Fixed","text":"<ul> <li>Updated FB_BaseFB.TraceWithJson() to correctly call AddEntryWithJson()</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#301-2022-10-05","title":"[3.0.1] - 2022-10-05","text":""},{"location":"SPT_Base_Types/changelog.html#added_10","title":"Added","text":"<ul> <li>Added Trace() method to FB_BaseFB</li> <li>Added Marker() method to FB_BaseFB</li> <li>Added TraceWithJson() method to FB_BaseFB</li> </ul>"},{"location":"SPT_Base_Types/changelog.html#300-2022-10-05","title":"[3.0.0] - 2022-10-05","text":""},{"location":"SPT_Base_Types/changelog.html#added_11","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_Base_Types/duts.html","title":"Data Types","text":""},{"location":"SPT_Base_Types/duts.html#enums","title":"ENUMs","text":""},{"location":"SPT_Base_Types/duts.html#e_alarmresponse","title":"E_AlarmResponse","text":"<pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_AlarmResponse : (\n        Abort_ImmediateError,\n        Abort_Immediate,\n        Stop_Immediate,\n        Stop_Controlled,\n        Hold_Immediate,\n        Hold_Controlled,\n        Suspend_Immediate,\n        Suspend_Controlled,\n        NoResponse\n    );\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#e_pmlunitmode","title":"E_PMLUnitMode","text":"SPT V4SPT V3 <pre><code>TYPE E_PMLUnitMode : (\n        Invalid      := 0,\n        Production   := 1,\n        Maintenance  := 2,\n        Manual       := 3,\n        UserMode1    := 4,\n        UserMode2    := 5,\n        UserMode3    := 6,\n        UserMode4    := 7,\n        UserMode5    := 8,\n        UserMode6    := 9,\n        UserMode7    := 10,\n        UserMode8    := 11,\n        UserMode9    := 12,\n        UserMode10   := 13,\n        UserMode11   := 14,\n        UserMode12   := 15,\n        UserMode13   := 16,\n        UserMode14   := 17,\n        UserMode15   := 18,\n        UserMode16   := 19,\n        UserMode17   := 20,\n        UserMode18   := 21,\n        UserMode19   := 22,\n        UserMode20   := 23,\n        UserMode21   := 24,\n        UserMode22   := 25,\n        UserMode23   := 26,\n        UserMode24   := 27,\n        UserMode25   := 28,\n        UserMode26   := 29,\n        UserMode27   := 30,\n        UserMode28   := 31\n    ) DINT;\nEND_TYPE\n</code></pre> <pre><code>TYPE E_PMLUnitMode : (\n        ePMLUnitMode_Invalid     := 0,\n        ePMLUnitMode_Production  := 1,\n        ePMLUnitMode_Maintenance := 2,\n        ePMLUnitMode_Manual      := 3,\n        ePMLUnitMode_UserMode1   := 4,\n        ePMLUnitMode_UserMode2   := 5,\n        ePMLUnitMode_UserMode3   := 6,\n        ePMLUnitMode_UserMode4   := 7,\n        ePMLUnitMode_UserMode5   := 8,\n        ePMLUnitMode_UserMode6   := 9,\n        ePMLUnitMode_UserMode7   := 10,\n        ePMLUnitMode_UserMode8   := 11,\n        ePMLUnitMode_UserMode9   := 12,\n        ePMLUnitMode_UserMode10  := 13,\n        ePMLUnitMode_UserMode11  := 14,\n        ePMLUnitMode_UserMode12  := 15,\n        ePMLUnitMode_UserMode13  := 16,\n        ePMLUnitMode_UserMode14  := 17,\n        ePMLUnitMode_UserMode15  := 18,\n        ePMLUnitMode_UserMode16  := 19,\n        ePMLUnitMode_UserMode17  := 20,\n        ePMLUnitMode_UserMode18  := 21,\n        ePMLUnitMode_UserMode19  := 22,\n        ePMLUnitMode_UserMode20  := 23,\n        ePMLUnitMode_UserMode21  := 24,\n        ePMLUnitMode_UserMode22  := 25,\n        ePMLUnitMode_UserMode23  := 26,\n        ePMLUnitMode_UserMode24  := 27,\n        ePMLUnitMode_UserMode25  := 28,\n        ePMLUnitMode_UserMode26  := 29,\n        ePMLUnitMode_UserMode27  := 30,\n        ePMLUnitMode_UserMode28  := 31\n    ) DINT;\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#structs","title":"STRUCTs","text":""},{"location":"SPT_Base_Types/duts.html#st_componentbase_hmi","title":"ST_ComponentBase_HMI","text":"<pre><code>TYPE ST_ComponentBase_HMI :\n    STRUCT\n        Config  : ST_ComponentBase_Config;\n        Command : ST_ComponentBase_Command;\n        Status  : ST_ComponentBase_Status;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_componentbase_config","title":"ST_ComponentBase_Config","text":"<pre><code>TYPE ST_ComponentBase_Config :\n    STRUCT\n        Name : STRING;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_componentbase_command","title":"ST_ComponentBase_Command","text":"<pre><code>TYPE ST_ComponentBase_Command :\n    STRUCT\n        SimulatedOperation : BOOL;\n        StandardOperation  : BOOL;\n        Reset              : BOOL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_componentbase_status","title":"ST_ComponentBase_Status","text":"<pre><code>TYPE ST_ComponentBase_Status :\n    STRUCT\n        InSimulation        : BOOL;\n        Busy                : BOOL;\n        Error               : BOOL;\n        ErrorID             : UDINT;\n        HMIControlAvailable : BOOL; //Set TRUE *FROM PLC* when HMI requests can be processed\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_packmlbasemodule_hmi","title":"ST_PackMLBaseModule_HMI","text":"<pre><code>TYPE ST_PackMLBaseModule_HMI :\n    STRUCT\n        Config  : ST_PackMLBaseModule_Config;\n        Command : ST_PackMLBaseModule_Command;\n        Status  : ST_PackMLBaseModule_Status;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_packmlbasemodule_config","title":"ST_PackMLBaseModule_Config","text":"<pre><code>TYPE ST_PackMLBaseModule_Config :\n    STRUCT\n        Name            : STRING;       //Human-readable module name for user-side messaging\n        LogStateChanges : BOOL := TRUE; //Toggle to permit or suppress state change logging (Should be tied to HMI setting to optionally reduce event logger clutter)\n        LogModeChanges  : BOOL := TRUE; //Toggle to permit or suppress state change logging (Should be tied to HMI setting to optionally reduce event logger clutter)\n        ModeNames       : ARRAY[0..31] OF STRING;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_packmlbasemodule_command","title":"ST_PackMLBaseModule_Command","text":"SPT V4SPT V3 <pre><code>TYPE ST_PackMLBaseModule_Command :\n    STRUCT\n        Mode               : E_PMLUnitMode              := Parameters_PackML_Base.UNIT_MODE_DEFAULT;\n        State              : Tc3_PackML_V3.E_PMLCommand := Parameters_PackML_Base.UNIT_STATE_DEFAULT;\n        ActivateStateLog   : BOOL; //HMI requests to enable the module\n        DeactivateStateLog : BOOL; //HMI requests to disable the module\n        ActivateModeLog    : BOOL; //HMI requests to enable the module\n        DeactivatModeLog   : BOOL; //HMI requests to disable the module\n    END_STRUCT\nEND_TYPE\n</code></pre> <pre><code>TYPE ST_PackMLBaseModule_Command :\n    STRUCT\n        Mode               : E_PMLUnitMode              := Parameters_PackML_Base.UNIT_MODE_DEFAULT;\n        State              : Tc3_PackML_V2.E_PMLCommand := Parameters_PackML_Base.UNIT_STATE_DEFAULT;\n        ActivateStateLog   : BOOL; //HMI requests to enable the module\n        DeactivateStateLog : BOOL; //HMI requests to disable the module\n        ActivateModeLog    : BOOL; //HMI requests to enable the module\n        DeactivatModeLog   : BOOL; //HMI requests to disable the module\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_packmlbasemodule_status","title":"ST_PackMLBaseModule_Status","text":"SPT V4SPT V3 <pre><code>TYPE ST_PackMLBaseModule_Status :\n    STRUCT\n        Busy                : BOOL;\n        Error               : BOOL;\n        ErrorID             : UDINT;\n        Mode                : E_PMLUnitMode;\n        State               : Tc3_PackML_V3.E_PMLState;\n        HMIControlAvailable : BOOL;\n    END_STRUCT\nEND_TYPE\n</code></pre> <pre><code>TYPE ST_PackMLBaseModule_Status :\n    STRUCT\n        Busy                : BOOL;\n        Error               : BOOL;\n        ErrorID             : UDINT;\n        Mode                : E_PMLUnitMode;\n        State               : Tc3_PackML_V2.E_PMLState;\n        HMIControlAvailable : BOOL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_packml_control","title":"ST_PackML_Control","text":"<pre><code>TYPE ST_PackML_Control :\n    STRUCT\n        CurrentMode      : E_PMLUnitMode;\n        ModeCommand      : E_PMLUnitMode;\n        CurrentState     : E_PMLState;\n        StateCommand     : E_PMLCommand;\n        ModeNames        : ARRAY[0..31] OF STRING;\n        ModeCommandLast  : E_PMLUnitMode;\n        StateCommandLast : E_PMLCommand;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/duts.html#st_packml_control_simplified","title":"ST_PackML_Control_Simplified","text":"<pre><code>TYPE ST_PackML_Control_Simplified :\n    STRUCT\n        ResetPermissive     : BOOL;\n        StartPermissive     : BOOL;\n        StopPermissive      : BOOL;\n        ResetPressed AT %I* : BOOL;\n        StartPressed AT %I* : BOOL;\n        StopPressed  AT %I* : BOOL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html","title":"Function Blocks","text":""},{"location":"SPT_Base_Types/functionblocks.html#fb_basefb","title":"FB_BaseFB","text":"<p>(abstract, implements <code>I_BaseFB</code>)</p> <p>Contains property backers for all <code>I_BaseFB</code> properties.  This is the most basic building block of all framework function blocks.  Can be directly inherited-if so, entry point is up to the developer.</p> <p>Info</p> <p>See I_BaseFB for more information.</p>"},{"location":"SPT_Base_Types/functionblocks.html#methods","title":"Methods","text":"Method Return Type Access Description Marker null PUBLIC Adds a message to the global trace log and sets its <code>Flags</code> to 1 Trace null PUBLIC Adds a message to the global trace log TraceWithJson null PUBLIC Adds a message to the global trace log along with additional JSON object"},{"location":"SPT_Base_Types/functionblocks.html#trace","title":"Trace()","text":"<pre><code>METHOD PUBLIC Trace\nVAR_INPUT\n    Message : T_MaxString;\nEND_VAR\n</code></pre> <p><code>Message</code> should be the textual description of the debug message.</p>"},{"location":"SPT_Base_Types/functionblocks.html#tracewithjson","title":"TraceWithJson()","text":"<pre><code>METHOD PUBLIC TraceWithJson\nVAR_INPUT\n    Message : T_MaxString;\n    Json    : T_MaxString;\nEND_VAR\n</code></pre> <p><code>Message</code> should be the textual description of the debug message.  <code>Json</code> should be a properly formatted JSON object.</p>"},{"location":"SPT_Base_Types/functionblocks.html#fb_componentbase","title":"FB_ComponentBase","text":"<p>(abstract, extends <code>FB_CyclicFB</code>, implements <code>I_ComponentBase</code>)</p> <p>Contains property backers for all <code>I_ComponentBase</code> properties as well as basic housekeeping code for all component-level function blocks.</p> <p>All <code>PROTECTED</code> methods can and usually should be overridden for component-specific functionality (HMI commands, event handling, etc.) and then called using <code>SUPER^.Method()</code>.</p> <p>Info</p> <p>See I_ComponentBase and FB_CyclicFB for more information.</p>"},{"location":"SPT_Base_Types/functionblocks.html#createevents","title":"CreateEvents()","text":"<p><code>METHOD PROTECTED CreateEvents</code></p> <p>If a component has its own specific events defined, override this method to initialize them and then call <code>SUPER^.CreateEvents()</code> to initialize the base component events.</p>"},{"location":"SPT_Base_Types/functionblocks.html#hmicommunication","title":"HMICommunication()","text":"<p><code>METHOD PROTECTED HMICommunication</code></p> <p>Override and <code>SUPER^</code> call this method to implement component-specific HMI commands, status, configuration items.  The base method uses a predefined local <code>HMICommandActive_Descendant</code> as an interlock to ensure only one command is fired at a time, whether it's a base command or a component-specific command.  The base method also provides <code>HMICommandActive_Base</code> for you to use in your custom method extensions.</p> <p>Info</p> <p>See ST_ComponentBase_HMI for more information.</p> <p>Example</p> <pre><code>SUPER^.HMICommunication();\nHMICommand_MyComponent_RT(CLK := (ComponentBase_HMI.Status.HMIControlAvailable AND NOT HMICommandActive_Base) AND (MyComponent_HMI.Command.MyCommand XOR MyComponent_HMI.Command.MyOtherCommand));\n\n//Signal to FB_ComponentBase that a command is active\nHMICommandActive_Descendant := ComponentBase_HMI.Status.HMIControlAvailable AND (MyComponent_HMI.Command.MyCommand OR MyComponent_HMI.Command.MyOtherCommand OR MyComponent_HMI.Command.Jog);\n\n//Process Momentary HMI requests\nIF HMICommand_MyComponent_RT.Q THEN\n    IF MyComponent_HMI.Command.MyCommand THEN\n        MyCommand();\n    ELSIF MyComponent_HMI.Command.MyOtherCommand THEN\n        MyOtherCommand();\n    END_IF\nEND_IF\n\n//Handle non-momentary commands such as jogging\nIF ComponentBase_HMI.Status.HMIControlAvailable AND NOT HMICommand_MyComponent_RT.Q THEN\n    IF MyComponent_HMI.Command.Jog THEN\n        MyComponent.Jog();\n    END_IF\nEND_IF\n\n//Update HMI status info\nMyComponent_HMI.Status.Red   := Red;\nMyComponent_HMI.Status.Green := Green;\nMyComponent_HMI.Status.Blue  := Blue;\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html#initialize","title":"Initialize()","text":"<p><code>METHOD PROTECTED Initialize</code></p> <p>In cases where a custom component contains one or many other components within, override <code>Initialize()</code> and interlock the <code>SUPER^.Initalize()</code> call with the <code>InitComplete</code> property of your subcomponent(s).  <code>CyclicLogic()</code> should also be overridden and the calls to subcomponents' <code>CyclicLogic()</code> placed within.  Through a long and complicated call chain, this pattern will ensure subcomponent(s) have initialized completely before your custom component reports <code>InitComplete = TRUE</code>.</p> <p>Example</p> <pre><code>METHOD PROTECTED FINAL Initialize : BOOL;\n\nIF NOT (MySubcomponent1.InitComplete AND MySubcomponent2.InitComplete) THEN\n    RETURN;\nEND_IF\n\nIF SUPER^.Initialize() THEN\n    Initialize := TRUE;\nEND_IF\n</code></pre> <pre><code>METHOD PUBLIC FINAL CyclicLogic\n\nMySubcomponent1.CyclicLogic();\nMySubcomponent2.CyclicLogic();\n\n//My custom component's code/state machine here\n\nSUPER^.CyclicLogic();\n\n_Busy  := MainState &lt;&gt; Idle AND MainState &lt;&gt; Error;\n_Error := MainState = Error AND MainState &lt;&gt; Reset;\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html#monitoring","title":"Monitoring()","text":"<p><code>METHOD PROTECTED Monitoring</code></p> <p>Override this method to add event handling to your custom component.</p> <p>Example</p> <pre><code>METHOD PROTECTED Monitoring\n\nSUPER^.Monitoring();\n\n//ErrorID 1 - MC_MoveVelocity\nIF BasicAxis.MC_MoveVelocity.Error AND NOT BasicAxisAlarms[E_BasicAxis.MoveVelocityError].bRaised THEN\n    RaiseAlarmWithStrings(Alarm := BasicAxisAlarms[E_BasicAxis.MoveVelocityError], UDINT_TO_STRING(BasicAxis.ErrorID), '');\nELSIF NOT BasicAxis.MC_MoveVelocity.Error AND BasicAxisAlarms[E_BasicAxis.MoveVelocityError].bRaised THEN\n    BasicAxisAlarms[E_BasicAxis.MoveVelocityError].Clear(0, 0);\nEND_IF\n\n//ErrorID 2 - MC_MoveRelative\nIF BasicAxis.MC_MoveRelative.Error AND NOT BasicAxisAlarms[E_BasicAxis.MoveRelativeError].bRaised THEN\n    RaiseAlarmWithStrings(Alarm := BasicAxisAlarms[E_BasicAxis.MoveRelativeError], UDINT_TO_STRING(BasicAxis.MC_MoveRelative.ErrorID), '');\nELSIF NOT BasicAxis.MC_MoveRelative.Error AND BasicAxisAlarms[E_BasicAxis.MoveRelativeError].bRaised THEN\n    BasicAxisAlarms[E_BasicAxis.MoveRelativeError].Clear(0, 0);\nEND_IF\n\n_CurrentAlarmSeverity := F_GetMaxSeverityRaised(Alarms := BasicAxisAlarms, CurrentSeverity := CurrentAlarmSeverity);\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html#raisealarm","title":"RaiseAlarm()","text":"<p><pre><code>METHOD PROTECTED RaiseAlarm\nVAR_IN_OUT\n    Alarm : FB_TcAlarm;\nEND_VAR\n</code></pre> Raises an alarm with no arguments</p>"},{"location":"SPT_Base_Types/functionblocks.html#raisealarmwithstrings","title":"RaiseAlarmWithStrings()","text":"<p><pre><code>METHOD PROTECTED RaiseAlarmWithStrings\nVAR_IN_OUT\n    Alarm : FB_TcAlarm;\nEND_VAR\n\nVAR_INPUT\n    String_1 : STRING;\n    String_2 : STRING;\nEND_VAR\n</code></pre> Raises an alarm with optional contextual information.  In actuality the event being raised takes 3 string arguments, but the component's <code>Name</code> is automatically passed as the first argument.</p>"},{"location":"SPT_Base_Types/functionblocks.html#raiseeventwithstrings","title":"RaiseEventWithStrings()","text":"<p><pre><code>METHOD PROTECTED RaiseEventWithStrings\nVAR_IN_OUT\n    Alarm : FB_TcAlarm;\nEND_VAR\n\nVAR_INPUT\n    String_1 : STRING;\n    String_2 : STRING;\nEND_VAR\n</code></pre> Raises an event with optional contextual information.  In actuality the event being raised takes 3 string arguments, but the component's <code>Name</code> is automatically passed as the first argument.  Events do not set the <code>Error</code> bit when they are raised.</p>"},{"location":"SPT_Base_Types/functionblocks.html#fb_controlsource","title":"FB_ControlSource","text":"<p>(abstract, extends <code>FB_CyclicFB</code>, implements <code>I_PackML_ExternalController</code>)</p> <p>A control source refers to any external device or system which needs to command a state/mode change or be notified of such a change by any I_PackML_Control.  These are usually submodules of otherwise descendants of FB_PackML_BaseModule.</p> <p>Examples of such a device are pushbutton groups, HMIs, or SCADA systems.</p> <p>Info</p> <p>See FB_CyclicFB and I_PackML_ExternalController for more information.</p> <p>Tip</p> <p>By extending <code>FB_ControlSource</code> and overriding <code>CyclicLogic()</code>, custom behavior can be designed to fit a particular need.</p>"},{"location":"SPT_Base_Types/functionblocks.html#properties","title":"Properties","text":"Property Type Access Description Registered BOOL R Flag indicating that the function block has been successfully registered with a submodule <p>CyclicLogic() Example</p> SPT V4SPT V3 <pre><code>IF NOT _InitComplete THEN\n    _InitComplete := Initialize();\n    RETURN;\nEND_IF\n\n//Copy the module to the local mode and state\nMainPMLControl_Standard.CurrentMode  := ipModule.CurrentMode;\nMainPMLControl_Standard.CurrentState := ipModule.CurrentState;\nFOR i := 1 TO 5 DO\n    MainPMLControl_Standard.ModeNames[i] := F_UnitModeToString(TO_DINT(i));\nEND_FOR\n\n//Process requests\nR_HMICommand(CLK := (MainPMLControl_Simplified.ResetPressed XOR MainPMLControl_Simplified.StartPressed XOR MainPMLControl_Simplified.StopPressed) XOR\n                    (MainPMLControl_Standard.StateCommand &lt;&gt; E_PMLCommand.Undefined AND MainPMLControl_Standard.StateCommandLast &lt;&gt; MainPMLControl_Standard.StateCommand) XOR\n                    (MainPMLControl_Standard.ModeCommandLast &lt;&gt; MainPMLControl_Standard.ModeCommand));\n\nIF R_HMICommand.Q THEN\n    MainPMLControl_Standard.ModeCommandLast  := MainPMLControl_Standard.ModeCommand;\n    MainPMLControl_Standard.StateCommandLast := MainPMLControl_Standard.StateCommand;\n    IF MainPMLControl_Simplified.ResetPressed AND MainPMLControl_Simplified.ResetPermissive AND MainPMLControl_Standard.CurrentState = E_PMLState.Aborted THEN\n        ipModule.ChangeState(Tc3_PackML_V3.E_PMLCommand.Clear);\n    ELSIF MainPMLControl_Simplified.ResetPressed AND MainPMLControl_Simplified.ResetPermissive THEN\n        ipModule.ChangeState(Tc3_PackML_V3.E_PMLCommand.Reset);\n    ELSIF MainPMLControl_Simplified.StartPressed AND MainPMLControl_Simplified.StartPermissive THEN\n        IF MainPMLControl_Standard.CurrentState = Tc3_PackML_V3.E_PMLState.Idle THEN\n            ipModule.ChangeState(Tc3_PackML_V3.E_PMLCommand.Start);\n        ELSIF MainPMLControl_Standard.CurrentState = Tc3_PackML_V3.E_PMLState.Held THEN\n            ipModule.ChangeState(Tc3_PackML_V3.E_PMLCommand.Unhold);\n        END_IF\n    ELSIF MainPMLControl_Simplified.StopPressed AND MainPMLControl_Simplified.StopPermissive THEN\n        ipModule.ChangeState(Tc3_PackML_V3.E_PMLCommand.Stop);\n    ELSIF ipModule.StateCommand &lt;&gt; MainPMLControl_Standard.StateCommand THEN\n        ipModule.StateCommand := MainPMLControl_Standard.StateCommand;\n    ELSIF ipModule.ModeCommand &lt;&gt; MainPMLControl_Standard.ModeCommand THEN\n        ipModule.ModeCommand := MainPMLControl_Standard.ModeCommand;\n    END_IF\nEND_IF\n\n//Set the permissives for each button\nMainPMLControl_Simplified.StartPermissive :=\n    MainPMLControl_Standard.CurrentState = Tc3_PackML_V3.E_PMLState.Idle OR MainPMLControl_Standard.CurrentState = Tc3_PackML_V3.E_PMLState.Held;\n\nMainPMLControl_Simplified.StopPermissive :=\n    (MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V3.E_PMLState.Stopped AND MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V3.E_PMLState.Clearing AND\n    MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V3.E_PMLState.Aborted AND MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V3.E_PMLState.Aborting AND\n    MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V3.E_PMLState.Idle AND MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V3.E_PMLState.Undefined);\n\nMainPMLControl_Simplified.ResetPermissive :=\n    MainPMLControl_Standard.CurrentState = Tc3_PackML_V3.E_PMLState.Completed OR MainPMLControl_Standard.CurrentState = Tc3_PackML_V3.E_PMLState.Stopped OR\n    MainPMLControl_Standard.CurrentState = Tc3_PackML_V3.E_PMLState.Aborted;\n</code></pre> <pre><code>IF NOT _InitComplete THEN\n    _InitComplete := Initialize();\n    RETURN;\nEND_IF\n\n//Copy the module to the local mode and state\nMainPMLControl_Standard.CurrentMode  := ipModule.CurrentMode;\nMainPMLControl_Standard.CurrentState := ipModule.CurrentState;\nFOR i := 1 TO 5 DO\n    MainPMLControl_Standard.ModeNames[i] := F_UnitModeToString(TO_DINT(i));\nEND_FOR\n\n//Process requests\nR_HMICommand(CLK := (MainPMLControl_Simplified.ResetPressed XOR MainPMLControl_Simplified.StartPressed XOR MainPMLControl_Simplified.StopPressed) XOR\n                    (MainPMLControl_Standard.StateCommand &lt;&gt; E_PMLCommand.ePMLCommand_Undefined AND MainPMLControl_Standard.StateCommandLast &lt;&gt; MainPMLControl_Standard.StateCommand) XOR\n                    (MainPMLControl_Standard.ModeCommandLast &lt;&gt; MainPMLControl_Standard.ModeCommand));\n\nIF R_HMICommand.Q THEN\n    MainPMLControl_Standard.ModeCommandLast  := MainPMLControl_Standard.ModeCommand;\n    MainPMLControl_Standard.StateCommandLast := MainPMLControl_Standard.StateCommand;\n    IF MainPMLControl_Simplified.ResetPressed AND MainPMLControl_Simplified.ResetPermissive AND MainPMLControl_Standard.CurrentState = E_PMLState.ePMLState_Aborted THEN\n        ipModule.ChangeState(Tc3_PackML_V2.E_PMLCommand.ePMLCommand_Clear);\n    ELSIF MainPMLControl_Simplified.ResetPressed AND MainPMLControl_Simplified.ResetPermissive THEN\n        ipModule.ChangeState(Tc3_PackML_V2.E_PMLCommand.ePMLCommand_Reset);\n    ELSIF MainPMLControl_Simplified.StartPressed AND MainPMLControl_Simplified.StartPermissive THEN\n        IF MainPMLControl_Standard.CurrentState = Tc3_PackML_V2.E_PMLState.ePMLState_Idle THEN\n            ipModule.ChangeState(Tc3_PackML_V2.E_PMLCommand.ePMLCommand_Start);\n        ELSIF MainPMLControl_Standard.CurrentState = Tc3_PackML_V2.E_PMLState.ePMLState_Held THEN\n            ipModule.ChangeState(Tc3_PackML_V2.E_PMLCommand.ePMLCommand_Unhold);\n        END_IF\n    ELSIF MainPMLControl_Simplified.StopPressed AND MainPMLControl_Simplified.StopPermissive THEN\n        ipModule.ChangeState(Tc3_PackML_V2.E_PMLCommand.ePMLCommand_Stop);\n    ELSIF ipModule.StateCommand &lt;&gt; MainPMLControl_Standard.StateCommand THEN\n        ipModule.StateCommand := MainPMLControl_Standard.StateCommand;\n    ELSIF ipModule.ModeCommand &lt;&gt; MainPMLControl_Standard.ModeCommand THEN\n        ipModule.ModeCommand := MainPMLControl_Standard.ModeCommand;\n    END_IF\nEND_IF\n\n//Set the permissives for each button\nMainPMLControl_Simplified.StartPermissive :=\n    MainPMLControl_Standard.CurrentState = Tc3_PackML_V2.E_PMLState.ePMLState_Idle OR MainPMLControl_Standard.CurrentState = Tc3_PackML_V2.E_PMLState.ePMLState_Held;\n\nMainPMLControl_Simplified.StopPermissive :=\n    (MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V2.E_PMLState.ePMLState_Stopped AND MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V2.E_PMLState.ePMLState_Clearing AND\n    MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V2.E_PMLState.ePMLState_Aborted AND MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V2.E_PMLState.ePMLState_Aborting AND\n    MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V2.E_PMLState.ePMLState_Idle AND MainPMLControl_Standard.CurrentState &lt;&gt; Tc3_PackML_V2.E_PMLState.ePMLState_Undefined);\n\nMainPMLControl_Simplified.ResetPermissive :=\n    MainPMLControl_Standard.CurrentState = Tc3_PackML_V2.E_PMLState.ePMLState_Complete OR MainPMLControl_Standard.CurrentState = Tc3_PackML_V2.E_PMLState.ePMLState_Stopped OR\n    MainPMLControl_Standard.CurrentState = Tc3_PackML_V2.E_PMLState.ePMLState_Aborted;\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html#fb_cyclicfb","title":"FB_CyclicFB","text":"<p>(abstract, extends <code>FB_BaseFB</code>, implements <code>I_CyclicFB</code>)</p> <p>Contains property backers for all <code>I_CyclicFB</code> properties.  <code>CyclicLogic()</code> is introduced as the entry point. </p> <p>Info</p> <p>See I_BaseFB and FB_BaseFB for more information.</p> <p>Success</p> <p>No code should be written in the body of function blocks extending. <code>FB_CyclicFB</code>.  While nothing will break by doing so, it violates the design pattern of the framework.</p>"},{"location":"SPT_Base_Types/functionblocks.html#fb_packml_basemodule","title":"FB_PackML_BaseModule","text":"<p>(abstract, extends <code>FB_CyclicFB</code>, implements <code>I_PackML_BaseModule</code>, <code>I_PackML_Control</code>)</p>"},{"location":"SPT_Base_Types/functionblocks.html#methods_1","title":"Methods","text":""},{"location":"SPT_Base_Types/functionblocks.html#general","title":"General","text":"Method Return Type Access Description CreateEvents null PROTECTED Initializes base component events Initialize BOOL PROTECTED Basic initialization routine RegisterComponent null PROTECTED Adds a given <code>I_ComponentBase</code> to the list of components in a submodule Must be done before <code>InitComplete</code> is set RegisterExternalController BOOL PUBLIC Takes an instance of <code>I_PackML_ExternalController</code> and adds it to an internal collection of external controllers.  External controllers are, for example, HMI or pushbutton aggregation function blocks. RegisterSubmodule BOOL PROTECTED Adds a given <code>I_PackML_BaseModule</code> as a child of a submodule Must be done before <code>InitComplete</code> is set StateComplete null PROTECTED Signal to PackML state machine sequencer that this module can advance to the next state.  This is normally called automatically by the state sequencer. ModeChanged null PROTECTED Method called by Base on Mode change. One Cycle call. StateChanged null PROTECTED Method called by Base on State change. One Cycle call."},{"location":"SPT_Base_Types/functionblocks.html#createevents_1","title":"CreateEvents()","text":"<p><code>METHOD PROTECTED CreateEvents</code></p> <p>If a module has its own specific events defined, override this method to initialize them and then call <code>SUPER^.CreateEvents()</code> to initialize the base component events.</p>"},{"location":"SPT_Base_Types/functionblocks.html#initialize_1","title":"Initialize()","text":"<p><code>METHOD PROTECTED Initialize</code></p> <p>The base <code>Initialize()</code> method handles some basic tasks like setting pointers, counting the number of submodules/components, and most importantly ensuring any children are completely initialized before itself returning <code>TRUE</code>.</p> <p>When creating an Equipment Module, override this method and implement your own routine.  Many times it makes sense to use a state machine to make sure things are called in order and only as required.  In fact, the base <code>Initialize()</code> does this using the predefined local <code>SequenceState</code> as the indexer.  A second predefined local <code>DescendantSequenceState</code> can be used for indexing a state machine in your overridden <code>Initialize()</code>.</p> <p>Example</p> SPT V4SPT V3 <pre><code>METHOD PROTECTED FINAL Initialize : BOOL\nVAR\n    i : UDINT; //Generic iteration value\nEND_VAR\n\nCASE DescendantSequenceState OF\n    0:\n        // Define the interfaces to the different subunits (Must take place before SUPER^.initialize call)\n        FOR i := 1 TO SPT_PackMLBase.Parameters_PackML_Base.MAX_NO_OF_SUBMODULES DO\n            ipSubModules[i] := ipSubModules_Init[i];\n        END_FOR\n\n        FOR i := 1 TO SPT_PackMLBase.Parameters_PackML_Base.MAX_NO_OF_COMPONENTS DO\n            ipComponents[i] := ipComponents_Init[i];\n        END_FOR\n\n        LogModuleModeChanges    := FALSE;\n        LogModuleStateChanges   := FALSE;\n        DescendantSequenceState := DescendantSequenceState + 10;\n    10:\n        CustomModes(eMode                          := 4,\n                    sName                          := 'My Custom Mode',\n                    bDisableClearing               := FALSE,\n                    bDisableStarting               := FALSE,\n                    bDisableSuspended              := TRUE,\n                    bDisableStopping               := FALSE,\n                    bDisableAborting               := FALSE,\n                    bDisableHolding                := TRUE,\n                    bDisableHeld                   := TRUE,\n                    bDisableUnholding              := TRUE,\n                    bDisableSuspending             := TRUE,\n                    bDisableUnsuspending           := TRUE,\n                    bDisableResetting              := FALSE,\n                    bDisableIdle                   := FALSE,\n                    bDisableCompleting             := TRUE,\n                    bDisableComplete               := TRUE,\n                    bEnableUnitModeChangeStopped   := TRUE,\n                    bEnableUnitModeChangeIdle      := TRUE,\n                    bEnableUnitModeChangeSuspended := FALSE,\n                    bEnableUnitModeChangeExecute   := TRUE,\n                    bEnableUnitModeChangeAborted   := TRUE,\n                    bEnableUnitModeChangeHeld      := FALSE,\n                    bEnableUnitModeChangeComplete  := FALSE,\n                    bError                         =&gt;,\n                    nErrorId                       =&gt;);\n    20:\n        FOR i := 1 TO 4 DO\n            ModeNames[i] := F_PMLUnitModeToString(UDINT_TO_DINT(i));\n        END_FOR\n\n        DescendantSequenceState := DescendantSequenceState + 10;\n    30:\n        IF SUPER^.Initialize() THEN\n            Initialize                 := TRUE;\n        END_IF\nEND_CASE\n</code></pre> <pre><code>METHOD PROTECTED FINAL Initialize : BOOL\nVAR\n    i : UDINT; //Generic iteration value\nEND_VAR\n\nCASE DescendantSequenceState OF\n    0:\n        // Define the interfaces to the different subunits (Must take place before SUPER^.initialize call)\n        FOR i := 1 TO SPT_PackMLBase.Parameters_PackML_Base.MAX_NO_OF_SUBMODULES DO\n            ipSubModules[i] := ipSubModules_Init[i];\n        END_FOR\n\n        FOR i := 1 TO SPT_PackMLBase.Parameters_PackML_Base.MAX_NO_OF_COMPONENTS DO\n            ipComponents[i] := ipComponents_Init[i];\n        END_FOR\n\n        LogModuleModeChanges    := FALSE;\n        LogModuleStateChanges   := FALSE;\n        DescendantSequenceState := DescendantSequenceState + 10;\n    10:\n        CustomModes(eMode                          := 4,\n                    sName                          := 'My Custom Mode',\n                    bDisableClearing               := FALSE,\n                    bDisableStarting               := FALSE,\n                    bDisableSuspended              := TRUE,\n                    bDisableStopping               := FALSE,\n                    bDisableAborting               := FALSE,\n                    bDisableHolding                := TRUE,\n                    bDisableHeld                   := TRUE,\n                    bDisableUnholding              := TRUE,\n                    bDisableSuspending             := TRUE,\n                    bDisableUnsuspending           := TRUE,\n                    bDisableResetting              := FALSE,\n                    bDisableIdle                   := FALSE,\n                    bDisableCompleting             := TRUE,\n                    bDisableComplete               := TRUE,\n                    bEnableUnitModeChangeStopped   := TRUE,\n                    bEnableUnitModeChangeIdle      := TRUE,\n                    bEnableUnitModeChangeSuspended := FALSE,\n                    bEnableUnitModeChangeExecute   := TRUE,\n                    bEnableUnitModeChangeAborted   := TRUE,\n                    bEnableUnitModeChangeHeld      := FALSE,\n                    bEnableUnitModeChangeComplete  := FALSE,\n                    bError                         =&gt;,\n                    nErrorId                       =&gt;);\n    20:\n        FOR i := 1 TO 4 DO\n            ModeNames[i] := F_UnitModeToString(UDINT_TO_DINT(i));\n        END_FOR\n\n        DescendantSequenceState := DescendantSequenceState + 10;\n    30:\n        IF SUPER^.Initialize() THEN\n            Initialize                 := TRUE;\n        END_IF\nEND_CASE\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html#registercomponent","title":"RegisterComponent()","text":"<p>Prior to v3.2.2, components were added to submodules by iterating through a preinitialized array of <code>I_ComponentBase</code> and adding them another internal array.  This was typically the first step in the submodule initialization process.  <code>RegisterComponent()</code> gives the option to add components to the internal array one at a time.  This can improve readability when the number of components grows large.</p>"},{"location":"SPT_Base_Types/functionblocks.html#registerexternalcontroller","title":"RegisterExternalController()","text":"<p>Established a two-way link between an I_PackML_ExternalController and this submodule.  Allows for external control of mode/state as well as notification of such changes via callback.</p> <p>! info     See FB_ControlSource for more information.</p> <pre><code>METHOD FINAL RegisterExternalController : BOOL\nVAR_INPUT\n    Controller : I_PackML_ExternalController;\nEND_VAR\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html#registersubmodule","title":"RegisterSubmodule()","text":"<p>Prior to v3.2.2, child submodules (e.g. Equipment Modules under a Machine Module) were added to submodules by iterating through a preinitialized array of <code>I_PackML_BaseModule</code> and adding them another internal array.  This was typically the first step in the submodule initialization process.  <code>RegisterSubmodule()</code> gives the option to add submodules to the internal array one at a time.  This can improve readability when the number of submodules grows large.</p>"},{"location":"SPT_Base_Types/functionblocks.html#alarm-handling","title":"Alarm Handling","text":"Method Return Type Access Description AbortImmediate null PROTECTED Sequence to execute when a submodule or component faults.  Ending PackML state will be <code>E_PMLState.ePMLState_Aborted</code> AbortImmediateError null PROTECTED Sequence to execute when a submodule or component faults.  Ending PackML state will be <code>E_PMLState.ePMLState_Aborted</code> and an event will be raised HoldControlled null PROTECTED Sequence to execute when a submodule or component faults.  Ending PackML state will be <code>E_PMLState.ePMLState_Held</code> HoldImmediate null PROTECTED Sequence to execute when a submodule or component faults.  Ending PackML state will be <code>E_PMLState.ePMLState_Held</code> StopControlled null PROTECTED Sequence to execute when a submodule or component faults.  Ending PackML state will be <code>E_PMLState.ePMLState_Stopped</code> StopImmediate null PROTECTED Sequence to execute when a submodule or component faults.  Ending PackML state will be <code>E_PMLState.ePMLState_Stopped</code> SuspendControlled null PROTECTED Sequence to execute when a submodule or component faults.  Ending PackML state will be <code>E_PMLState.ePMLState_Suspended</code> SuspendImmediate null PROTECTED Sequence to execute when a submodule or component faults.  Ending PackML state will be <code>E_PMLState.ePMLState_Suspended</code> <p>Info</p> <p>The method which will be called on submodule or component fault depends on the severity of the event and the behavior defined by the subcomponent/component's <code>ParentResponseDefinitions</code> property.</p>"},{"location":"SPT_Base_Types/functionblocks.html#abortimmediateerror","title":"AbortImmediateError()","text":"<p><pre><code>METHOD PROTECTED AbortImmediateError\nVAR_INPUT\n    Name     : STRING;\n    IsModule : BOOL;\nEND_VAR\n</code></pre> <code>Name</code> will be included in the event text.  If <code>IsModule</code> is <code>TRUE</code>, a SubModuleError is raised.  If <code>FALSE</code> a ComponentError is raised.</p>"},{"location":"SPT_Base_Types/functionblocks.html#hmi","title":"HMI","text":"Method Return Type Access Description AllowHMIControl null PROTECTED Signal to this module that external functions via HMI should be allowed BlockHMIControl null PROTECTED Signal to this module that external functions via HMI should be blocked HMICommunication null PROTECTED Called cyclically; Handles HMI command requests HMIPermissions null PROTECTED Called cyclically; sets whether or not HMI commands are allowed based on current PackML mode <p>Notes AllowHMIControl() <pre><code>METHOD PROTECTED FINAL AllowHMIControl\nVAR_INPUT\n    ThisModuleOnly : BOOL; //! If TRUE, only the PackML module itself is controllable. If FALSE, all components become controllable as well\nEND_VAR\n</code></pre></p> <p>HMICommunication() <code>METHOD PROTECTED HMICommunication</code></p> <p>Override and <code>SUPER^</code> call this method to implement component-specific HMI commands, status, configuration items.  The base method uses a predefined local <code>HMICommandActive_Descendant</code> as an interlock to ensure only one command is fired at a time, whether it's a base command or a component-specific command.  The base method also provides <code>HMICommandActive_Base</code> for you to use in your custom method extensions.</p> <p>Example</p> <pre><code>SUPER^.HMICommunication();\nHMICommand_MyEquipmentModule_RT(CLK := (PackMLBaseModule_HMI.Status.HMIControlAvailable AND NOT HMICommandActive_Base) AND (MyEquipmentModule_HMI.Command.MyCommand XOR MyEquipmentModule_HMI.Command.MyOtherCommand));\n\n//Signal to FB_PackMLBaseModule that a command is active\nHMICommandActive_Descendant := PackMLBaseModule_HMI.Status.HMIControlAvailable AND (MyEquipmentModule_HMI.Command.MyCommand OR MyEquipmentModule_HMI.Command.MyOtherCommand);\n\n//Process Momentary HMI requests\nIF HMICommand_MyEquipmentModule_RT.Q THEN\n    IF MyEquipmentModule_HMI.Command.MyCommand THEN\n        MyCommand();\n    ELSIF MyEquipmentModule_HMI.Command.MyOtherCommand THEN\n        MyOtherCommand();\n    END_IF\nEND_IF\n\n//Update HMI status info\nMyEquipmentModule_HMI.Status.Red   := Red;\nMyEquipmentModule_HMI.Status.Green := Green;\nMyEquipmentModule_HMI.Status.Blue  := Blue;\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html#monitoring_1","title":"Monitoring","text":"Method Return Type Access Description ComponentMonitor null PROTECTED Called cyclically; checks components for faults and calls appropriate reaction method SubModuleMonitor null PROTECTED Called cyclically; checks submodules for faults and calls appropriate reaction method SPT V4SPT V3 <p>Info</p> <p>The private method <code>StateControl</code> will automatically call the method that corresponds with the module's PackML state.  These methods are typically overriden and replaced with customized machine logic.</p> <p>Set <code>NoStateTasksToComplete</code> to <code>TRUE</code> to indicate to the state sequencer that there are things left to do before advancing states.  Set <code>StateTasksComplete</code> when your machine logic is completed.  Both of these variables are reinitialized when the state is advanced, so no additional management is necessary.</p> <p>Call <code>SUPER^.</code>State() at the end of your method override so that the base method can take care of housekeeping.</p> <p>Example</p> <pre><code>METHOD PROTECTED FINAL Clearing\n\nCASE SequenceState OF\n    0:\n        NoStateTasksToComplete := FALSE;\n        SequenceState          := SequenceState + 10;\n    10:\n        //Reset any alarms that get latched\n        UnwindAlarms[E_Unwind.StartTimeout].Clear(0, 0);\n        SequenceState := SequenceState + 10;\n    20:\n        // Enable here\n        IF Axis.Enable() THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n    30:\n        // Check enabled here\n        IF Axis.Enabled THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n    40:\n        StateTasksComplete := TRUE;\nEND_CASE\n\nSUPER^.Clearing();\n</code></pre>"},{"location":"SPT_Base_Types/functionblocks.html#primary-acting-states","title":"Primary &amp; Acting States","text":"Method Return Type Access Description Aborted null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Aborted</code> Completed null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Completed</code> Execute null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Execute</code> Held null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Held</code> Idle null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Idle</code> Stopped null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Stopped</code> Suspended null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Suspended</code> Undefined null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Undefined</code>.  Should not normally be called. Aborting null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Aborting</code> Clearing null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Clearing</code> Completing null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Completing</code> Holding null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Holding</code> Resetting null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Resetting</code> Starting null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Starting</code> Stopping null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Stopping</code> Suspending null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Suspending</code> Unholding null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Unholding</code> Unsuspending null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.Unsuspending</code>"},{"location":"SPT_Base_Types/functionblocks.html#primary-acting-states_1","title":"Primary &amp; Acting States","text":"Method Return Type Access Description Aborted null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Aborted</code> Complete null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Complete</code> Execute null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Execute</code> Held null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Held</code> Idle null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Idle</code> Stopped null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Stopped</code> Suspended null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Suspended</code> Undefined null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Undefined</code>.  Should not normally be called. Aborting null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Aborting</code> Clearing null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Clearing</code> Completing null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Completing</code> Holding null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Holding</code> Resetting null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Resetting</code> Starting null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Starting</code> Stopping null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Stopping</code> Suspending null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Suspending</code> Unholding null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Unholding</code> Unsuspending null PROTECTED Called cyclically according to PackML state; logic/sequence associated with PackML state <code>E_PMLState.ePMLState_Unsuspending</code>"},{"location":"SPT_Base_Types/functionblocks.html#fb_tracelog","title":"FB_TraceLog","text":"<p>(Global-declared in library GVL <code>Tracing</code>)</p> <p>Provides methods for adding events to the trace log.  Includes throttling mechanism to limit the number of events per PLC scan (default 100 per scan; see Parameters_Tracing).</p> <p>Automatically collects context information which is appended to the JSON attribute of the event which is raised.</p> <p>Example message</p> <p></p> <p>JSON attribute</p> <p></p>"},{"location":"SPT_Base_Types/functionblocks.html#methods_2","title":"Methods","text":"Method Return Type Access Description AddEntry null PUBLIC Adds a basic message to the trace log AddEntryWithJson null PUBLIC Adds a message to the trace log and appends a given JSON object the event attributes"},{"location":"SPT_Base_Types/functionblocks.html#addentry","title":"AddEntry()","text":"<pre><code>METHOD PUBLIC AddEntry\nVAR_INPUT\n    Source  : T_MaxString;\n    Message : T_MaxString;\n    Flags   : UDINT;\nEND_VAR\n</code></pre> <p><code>Source</code> should be used to specify where the trace message is coming from (FB name, etc.)  This is handled automatically for you if using the wrapper methods in <code>FB_BaseFB</code>.  <code>Message</code> is the the textual description of your event.  <code>Flags</code> has no defined purpose but can be used, for instance, to signal to listeners that this event should be highlighted or handled in a different way.</p>"},{"location":"SPT_Base_Types/functionblocks.html#addentrywithjson","title":"AddEntryWithJson()","text":"<pre><code>METHOD PUBLIC AddEntryWithJson\nVAR_INPUT\n    Source  : T_MaxString;\n    Message : T_MaxString;\n    Flags   : UDINT;\n    Json    : T_MaxString;\nEND_VAR\n</code></pre> <p>Behaves exactly the same way as <code>AddEntry()</code> but takes an additional argument <code>Json</code> which will be automatically appended to the JSON attribute of the event (<code>ExtendedInfo</code>).  This can be used to provide even more contextual information than is automatically provided.</p>"},{"location":"SPT_Base_Types/globals.html","title":"Globals/Parameters","text":""},{"location":"SPT_Base_Types/globals.html#parameters","title":"Parameters","text":""},{"location":"SPT_Base_Types/globals.html#parameters_packml_base","title":"Parameters_PackML_Base","text":"Parameter Type Default Description COMPONENT_NAME_DELIMETER STRING(10) ' ' (space) String applied to component names to indicate hierarchy CONCAT_SUBMODULE_NAME_WITH_PARENT BOOL FALSE If <code>TRUE</code>, submodule names will have their parent's name prepended CONCAT_COMPONENT_NAME_WITH_PARENT BOOL TRUE If <code>TRUE</code>, component names will have their parent's name prepended INHIBIT_SIMULATION_WARNING BOOL FALSE If <code>TRUE</code>, components in simulation mode will not raise a warning indicating as such MAX_NO_OF_SUBMODULES UDINT 20 Maximum number of submodules that can be registered MAX_NO_OF_COMPONENTS UDINT 32 Maximum number of components per submodule MAX_NO_OF_EXTERNAL_CONTROLLERS UDINT 10 Maximum number of I_PackML_ExternalController that can be registered with a submodule RESET_COMPONENTS_WITHOUT_ERROR BOOL FALSE If <code>TRUE</code>, components will always have <code>Reset()</code> called regardless of their error state SUBMODULE_NAME_DELIMETER STRING(10) ' ' (space) String applied to submodule names to indicate hierarchy STATELOGGER_DISABLED BOOL FALSE If <code>TRUE</code>, no state change events will be raised, no matter their severity (entering Held/Aborted states will not be raised) UNIT_MODE_DEFAULT E_PMLUnitMode E_PMLUnitMode.Production Default mode set to all submodules upon initialization UNIT_STATE_DEFAULT E_PMLCommand E_PMLCommand.Abort Default command which is set to all submodules upon initialization"},{"location":"SPT_Base_Types/globals.html#parameters_tracing","title":"Parameters_Tracing","text":"Parameter Type Default Description TRACING_ENABLED BOOL TRUE Set <code>FALSE</code> to disable all tracing functions (ex. machine in production) MAX_LOG_ENTRIES_PER_SCAN UDINT 100 Specify maximum number of messages allowed to be sent per PLC scan ALLOW_DUPLICATE_SEQUENTIAL_MESSAGES BOOL FALSE If <code>TRUE</code>, allows multiple identical trace messages to be sent sequentially"},{"location":"SPT_Base_Types/globals.html#gvls","title":"GVLs","text":""},{"location":"SPT_Base_Types/globals.html#tracing","title":"Tracing","text":"<pre><code>{attribute 'qualified_only'}\nVAR_GLOBAL\n    GlobalTraceLog : FB_TraceLog;\nEND_VAR\n</code></pre>"},{"location":"SPT_Base_Types/interfaces.html","title":"Interfaces","text":""},{"location":"SPT_Base_Types/interfaces.html#framework-base","title":"Framework Base","text":""},{"location":"SPT_Base_Types/interfaces.html#i_basefb","title":"I_BaseFB","text":"<p>Defines the most basic functionality of any function block used within the framework</p>"},{"location":"SPT_Base_Types/interfaces.html#properties","title":"Properties","text":"Property Type Access Description Busy BOOL R Function block is performing some action Error BOOL R Function block has encountered an error condition ErrorID UDINT R Error-specific identifier"},{"location":"SPT_Base_Types/interfaces.html#i_cyclicfb","title":"I_CyclicFB","text":"<p>(extends <code>I_BaseFB</code>)</p> <p>Adds to <code>I_BaseFB</code> the concept of initialization, as well as a unified entry point for cyclical code to be called.  You may have collections of <code>I_CyclicFB</code> which are iterated through, calling <code>CyclicLogic()</code> on each.</p>"},{"location":"SPT_Base_Types/interfaces.html#properties_1","title":"Properties","text":"Property Type Access Description InitComplete BOOL R Flag indicating that the function block is ready to use"},{"location":"SPT_Base_Types/interfaces.html#methods","title":"Methods","text":"Method Return Type Description CyclicLogic null Entry point for code execution"},{"location":"SPT_Base_Types/interfaces.html#component-base","title":"Component Base","text":""},{"location":"SPT_Base_Types/interfaces.html#i_componentbase","title":"I_ComponentBase","text":"<p>(extends <code>I_CyclicFB</code>)</p> <p>Defines basic required functionality for component-level function blocks</p> <p>Note</p> <p>This interface was previously located in the SPT_Component_Base library.  It was consolidated into this library as of v3.1.0.  Previous library releases are still included in this repository but are no longer maintained.</p> <p>Info</p> <p>See I_BaseFB for more information.</p>"},{"location":"SPT_Base_Types/interfaces.html#properties_2","title":"Properties","text":"Property Type Access Description CurrentAlarmSeverity TcEventSeverity R Returns the highest severity of any currently active events InSimulation BOOL RW Flag to indicate to component/parent that this component is running simulation code (defined per component) Name STRING RW Name of this component ParentResponseDefinitions ARRAY[0..4] OF E_AlarmResponse RW Defines how the parent of this component should react to each event severity"},{"location":"SPT_Base_Types/interfaces.html#parentresponsedefinitions","title":"ParentResponseDefinitions","text":"<p><code>PROPERTY ParentResponseDefinitions : ARRAY[0..4] OF E_AlarmResponse</code></p> <p>The expected response type of a component's parent can be specified.  The actual response logic is determined by the component's parent.  The parent should observe <code>CurrentAlarmSeverity</code> and then decide what to do in response.</p> <p>Example</p> <pre><code>ParentResponseDefinitions[TcEventSeverity.Verbose]  := E_AlarmResponse.NoResponse;\nParentResponseDefinitions[TcEventSeverity.Info]     := E_AlarmResponse.NoResponse;\nParentResponseDefinitions[TcEventSeverity.Warning]  := E_AlarmResponse.Suspend_Immediate;\nParentResponseDefinitions[TcEventSeverity.Error]    := E_AlarmResponse.Abort_ImmediateError;\nParentResponseDefinitions[TcEventSeverity.Critical] := E_AlarmResponse.Abort_ImmediateError;\n</code></pre>"},{"location":"SPT_Base_Types/interfaces.html#methods_1","title":"Methods","text":"Method Return Type Description AllowHMIControl null Signal to this component that external functions via HMI should be allowed BlockHMIControl null Signal to this component that external functions via HMI should be blocked Reset BOOL Command this component to execute its fault reset routine"},{"location":"SPT_Base_Types/interfaces.html#packml-base","title":"PackML Base","text":""},{"location":"SPT_Base_Types/interfaces.html#i_packml_basemodule","title":"I_PackML_BaseModule","text":"<p>(extends <code>I_CyclicFB</code>, <code>I_PackML_Control</code>)</p> <p>Defines basic state &amp; mode controls &amp; status information required of all PackML modules (Machine Modules &amp; Equipment Modules)</p> <p>Note</p> <p>This interface was previously located in the SPT_PackML_Base library.  It was consolidated into this library as of v3.1.0.  Previous library releases are still included in this repository but are no longer maintained.</p> <p>Info</p> <p>See I_BaseFB and I_PackML_Control for more information.</p>"},{"location":"SPT_Base_Types/interfaces.html#properties_3","title":"Properties","text":"Property Type Access Description CurrentAlarmSeverity TcEventSeverity R Highest severity of any currently active event(s) LogModeChanges BOOL RW Enable/Disable logging of mode changes LogStateChanges BOOL RW Enable/Disable logging of PackML state changes DisableSubModuleModeChange BOOL RW Enable/Disable SubModule Mode change if Mode of this instanz is changed Name STRING RW Name of this module ParentResponseDefinitions ARRAY[0..4] OF E_AlarmResponse RW Defines how the parent of this module should react to each event severity"},{"location":"SPT_Base_Types/interfaces.html#parentresponsedefinitions_1","title":"ParentResponseDefinitions","text":"<p><code>PROPERTY ParentResponseDefinitions : ARRAY[0..4] OF E_AlarmResponse</code></p> <p>The expected response type of a module's parent can be specified.  The actual response logic is handled by the module's parent.  The parent can observe <code>CurrentAlarmSeverity</code> and then decide what to do in response.</p> <p>Example</p> <pre><code>ParentResponseDefinitions[TcEventSeverity.Verbose]  := E_AlarmResponse.NoResponse;\nParentResponseDefinitions[TcEventSeverity.Info]     := E_AlarmResponse.NoResponse;\nParentResponseDefinitions[TcEventSeverity.Warning]  := E_AlarmResponse.Suspend_Immediate;\nParentResponseDefinitions[TcEventSeverity.Error]    := E_AlarmResponse.Abort_ImmediateError;\nParentResponseDefinitions[TcEventSeverity.Critical] := E_AlarmResponse.Abort_ImmediateError;\n</code></pre>"},{"location":"SPT_Base_Types/interfaces.html#i_packml_control","title":"I_PackML_Control","text":"<p>Defines basic control and feedback mechanisms for control of PackML modules</p> <p>Note</p> <p>This interface was previously located in the SPT_PackML_Base library.  It was consolidated into this library as of v3.1.0.  Previous library releases are still included in this repository but are no longer maintained.</p>"},{"location":"SPT_Base_Types/interfaces.html#properties_4","title":"Properties","text":"Property Type Access Description CurrentMode E_PMLUnitMode R Current PackML mode CurrentState E_PMLState R Current PackML state ModeCommand DINT RW Commanded PackML mode StateCommand E_PMLCommand RW Commanded PackML state <p>Note</p> <p>You can request a mode/state change using the method call <code>ChangeState()</code>/<code>ChangeMode()</code> or by setting the <code>StateCommand</code>/<code>ModeCommand</code> properties; they both do the same thing.</p>"},{"location":"SPT_Base_Types/interfaces.html#methods_2","title":"Methods","text":"Method Return Type Description ChangeMode null Request to enter a given mode ChangeState null Issue a specific PackML state command"},{"location":"SPT_Base_Types/interfaces.html#i_packml_externalcontroller","title":"I_PackML_ExternalController","text":"<p>(extends <code>I_CyclicFB</code>, <code>I_PackML_Control</code>)</p> <p>Defines complete means of external control of a PackML module's commanded mode and state.  A module can have many different external controllers registered with it-these could be pushbutton groups, HMIs, SCADA systems, etc.</p> <p>Note</p> <p>This interface was previously located in the SPT_PackML_Base library.  It was consolidated into this library as of v3.1.0.  Previous library releases are still included in this repository but are no longer maintained.</p> <p>Info</p> <p>See I_CyclicFB and I_PackML_Control for more information.</p> <p>Note</p> <p>See FB_PackML_BaseModule.RegisterExternalController() and See FB_ControlSource for more information.</p>"},{"location":"SPT_Base_Types/interfaces.html#properties_5","title":"Properties","text":"Property Type Access Description Control I_PackML_Control W Interface pointer to control interface of module"},{"location":"SPT_Base_Types/interfaces.html#methods_3","title":"Methods","text":"Method Return Type Description ModeChanged null Serves as a callback notification to external controllers that the module's mode has changed StateChanged null Serves as a callback notification to external controllers that the module's state has changed"},{"location":"SPT_Components/index.html","title":"Overview","text":"<p>Collection of function blocks implementing <code>I_ComponentBase</code>.  All components follow the pattern laid out in HMI DUT Pattern.</p> <p>PackML is not required to be used alongside these components, but they are made to fit directly into FB_PackML_BaseModule.</p>"},{"location":"SPT_Components/index.html#design-notes","title":"Design Notes","text":""},{"location":"SPT_Components/index.html#hmi-dut-pattern","title":"HMI DUT Pattern","text":"<p>If a function block is intended to be controlled via HMI, a DUT should be created to contain:</p> <ul> <li>Configuration Variables</li> <li>Commands</li> <li>Status Information</li> <li>A wrapper DUT should also be created to aggregate these data (see class diagram). </li> </ul> <p>Function blocks inheriting FB_ComponentBase will automatically include basic functions (including a Reset command)--see ComponentBaseHMI in FB_ComponentBase. Similarly, inheriting FB_PackML_BaseModule will give you basic mode/state commands, etc. in PackMLModuleBaseHMI.</p> <p>The idea is to give all components/PackML modules the same basic capabilities. Component or Equipment Module-specific functions should be exposed through their own group of DUTs. This pattern makes the development of User Controls on the HMI side much smoother.</p>"},{"location":"SPT_Components/ComponentGuide.html","title":"Guide to write a Component","text":"<p>Rules</p> <ul> <li> Plan your component before writing code.</li> <li> Use SPT style guide to develop your component.</li> <li> Use SPT Component Base.</li> <li> Apply SPT principal for Command execution.</li> <li> Create Errors for your Component.</li> <li> Create example Hmi for your Component.</li> <li> Prevent using <code>VAR_INPUT</code>, <code>VAR_OUTPUT</code> and <code>VAR_INOUT</code>. Use Methods and Properties to access component.</li> <li> Document your components functionality</li> </ul> <p>It is necessary to be familiar with the Design Guide of the SPT Framework.</p>"},{"location":"SPT_Components/ComponentGuide.html#planning","title":"Planning","text":"<p>Before starting to write code for your component it is essential to plan the functionality. Consider using planning tools for your class diagram such as mermaid</p> <p>To use the object oriented approach the planning process focuses on reusability of the component. </p> <ul> <li>What is the smallest single function needed?</li> <li>What is the intended function of this component?</li> <li>The component starts small with basic functions and can subsequently be inherited to add functionality.</li> <li>Plan interfaces to PackML state machine. No, to very limited sequences inside of Components. The sequencing of commands will be handled by Equipment Module or Machine Module. </li> </ul> Example Class Diagram <p>Example could be a cylinder with Extend/Retract output as base component.  The extension adds inputs for extended/retracted along with error messages for final position not reached.</p> <pre><code>    classDiagram\nFB_Component_MyComponentExtension &lt;|-- FB_Component_MyComponentBase\nFB_Component_MyComponentBase &lt;|-- FB_ComponentBase\nFB_Component_MyComponentBase &lt;|-- I_Component_MyComponentBase\nI_Component_MyComponentExtension &lt;|-- I_Component_MyComponentBase\nFB_Component_MyComponentExtension &lt;|-- I_Component_MyComponentExtension \nFB_ComponentBase &lt;|-- I_ComponentBase\nFB_ComponentBase &lt;|-- FB_CyclicFB\nFB_CyclicFB &lt;|-- FB_BaseFB\nFB_BaseFB &lt;|-- I_BaseFB\nFB_CyclicFB &lt;|-- I_CyclicFB\n\nclass I_ComponentBase{\n    CurrentAlarmSeverity\n    InSimulation\n    Name\n    ParentResponseDefinitions\n\n    AllowHmiControl()\n    BlockHmiControl()\n    Reset()\n}\nclass I_CyclicFB {\n    InitComplete\n    CyclicLogic()\n}\nclass I_BaseFB{\n    Busy\n    Error\n    ErrorID\n}\nnote for FB_ComponentBase \"This is found in Library SPT Base Types\"\nclass FB_ComponentBase{\n    CreateEvents()\n    HMICommunication()\n    Initialize()\n    Monitoring()\n    RaiseAlarm()\n    RaiseAlarmWithStrings()\n    RaiseEventWithStrings()\n}\nclass I_Component_MyComponentBase{\n    MethodCommand1()\n    MethodCommand2()\n    Property1\n    Property2\n}\nclass I_Component_MyComponentExtension{\n    FeedbackProperty1\n    FeedbackProperty2\n}</code></pre>"},{"location":"SPT_Components/ComponentGuide.html#component-development","title":"Component Development","text":"<p>The <code>FB_ComponentBase</code> provides the necessary functions to integrate seamlessly with the SPT Framework. <code>FB_ComponentBase</code> implements <code>I_ComponentBase</code> and extends <code>FB_CyclicFB</code>.</p> <p>Organize your components <code>FB_Component_MyComponent</code> methods and properties in folders as shown in the following example.</p> <p>Example Folder Structure</p> <p></p>"},{"location":"SPT_Components/ComponentGuide.html#variables","title":"Variables","text":"<p>The components variables are declared in the header of the FB. The following basic structure is recommended.</p> <p></p>"},{"location":"SPT_Components/ComponentGuide.html#cyclic-code","title":"Cyclic Code","text":"<p>Cyclic logic will be executed in the method <code>CyclicLogic()</code> provided by <code>FB_CyclicFB</code>. No code is allowed in the body of the FB as it violates the design pattern of SPT!</p> <p>Inside of <code>CyclicLogic()</code> the component will be initialized, custom code executed, super called and the alarm severity determined.</p> <p>Every component inherits <code>FB_BaseFB</code>, related variables for <code>Error</code>, <code>ErrorId</code> and <code>Busy</code> are assigned in <code>CyclicLogic()</code> based on your custom functions.</p> <p></p>"},{"location":"SPT_Components/ComponentGuide.html#commands-and-feedback","title":"Commands and Feedback","text":"<p>Interfaces provide a unified access to your component. It shall include the commands to execute functions and the required feedbacks. </p> <p>The execution of a command for the component is required to implement the following pattern. </p> <p>Trigger the Command:</p> <p>The command is executed by calling the method for one cycle, the return value of the method must indicate if the command has been accepted.</p> Example Command <p>Method <code>MyCommand1:BOOL</code>: <pre><code>// Component already busy -&gt; return and not accept command\nIF _Busy THEN\n    // Trace Message Command was not accepted\n    TRACE('MyCommand1 rejected, component busy!');\n    RETURN;\nEND_IF\n\n// Execute MyCommand1.....\n//\n//\n//\nMyCommand1 := TRUE;\n</code></pre> </p> <p>Wait for Done or Error:</p> <p>Once the command has been accepted, the component is expected to be <code>Busy</code> indicated by <code>MyComponent.Busy</code> equals <code>True</code> . At successful completion of the command the <code>Busy</code> turns back to <code>False</code>.</p> <p>In cases where the component command fails execution the <code>Busy</code> bit is expected to turn <code>False</code> and the <code>Error</code>,<code>ErrorId</code> indicate an error. Further an alarm is expected to be raised. (Explained in the following paragraph.)</p> Example Command Sequence for a Component <pre><code>    CASE SequenceState OF\n        0: // Trigger Command\n            IF MyComponent.MyCommand1() THEN\n                SequenceState := SequenceState + 10;\n            END_IF\n\n        10: // Wait for Done\n            IF NOT MyComponent.Busy AND NOT MyComponent.Error THEN\n                SequenceState := SequenceState + 10;\n            END_IF\n\n        20: // Next Command\n            ...\n    END_CASE\n</code></pre> <p>This is the default handling of component commands if not documented otherwise.</p>"},{"location":"SPT_Components/ComponentGuide.html#errors-and-warnings","title":"Errors and Warnings","text":"<p>In case the component fails an error is expected. The SPT framework uses the TwinCat Eventlogger</p>"},{"location":"SPT_Components/ComponentGuide.html#create-an-alarm","title":"Create an Alarm","text":"<p>To create Alarms, each component has an array of <code>FB_TcAlarm</code> along with a .tmc file which contains the event class.</p> <pre><code>// Alarms\n    MyComponentAlarms : ARRAY[1..MY_COMPONENT_ALARMS_COUNT] OF FB_TcAlarm;\n</code></pre> <p>Create the Event Class in the TMC Editor.</p> Create Event Class <p> </p> <p>The method <code>CreateEvents()</code> is called during initialization from the base class and needs to be overwritten to initialize the MyComponent Events.</p> <p>The first event in the custom created event class is reserved for the initialization message. <pre><code>    SUPER^.CreateEvents();\n    F_CreateAllEventsInClass(Alarms     := MyComponentAlarms,\n                            ClassSize   := SIZEOF(TC_EVENTS.MyComponentAlarms),\n                            pInitEvent := ADR(TC_EVENTS.MyComponentAlarms.InitReferenceEvent),\n                            Prefix      := _Name);\n</code></pre></p>"},{"location":"SPT_Components/ComponentGuide.html#trigger-an-alarm","title":"Trigger an Alarm","text":"<p>After the alarms have been initialized they can be raised in <code>Monitoring()</code>.</p> <pre><code>    SUPER^.Monitoring();\n    {error 'raise custom alarms here'}\n    IF TRUE AND NOT MyComponentAlarms[E_MyComponentAlarms.MyExampleError].bRaised THEN\n        RaiseAlarmWithStrings(MyComponentAlarms[E_MyComponentAlarms.MyExampleError], '', '');\n    END_IF\n</code></pre> <p>The reset of the alarm is expected in <code>Reset()</code>.  <pre><code>    // Clear Component Alarms\n    F_ClearAllEventsInClass(MyComponentAlarms);\n\n    // Call Super\n    Reset := Super^.Reset();\n</code></pre></p> Note Reset <p>If <code>FB_PackML_BaseModule</code> is used as Equipment Module or Machine Module the state <code>Clearing()</code> is calling the <code>Reset()</code> of the registered component when the bit <code>Error</code> is <code>True</code>.</p> <p>The component is cyclicly determining the highest <code>CurrentAlarmSeverity</code> in <code>CyclicLogic()</code>. The Equipment Module which the Component is part of will read the <code>CurrentAlarmSeverity</code> and determine along with the <code>ParentFaultResponseDefinitions</code> the error reaction. </p> <p>By default the error reaction is set in the base class <code>FB_ComponentBase</code> but may be adjusted by the component developer.</p> <pre><code>    _ParentFaultResponseDefinitions : ARRAY[0..4] OF E_AlarmResponse := [   E_AlarmResponse.NoResponse, \n                                                                            E_AlarmResponse.NoResponse, \n                                                                            E_AlarmResponse.NoResponse, \n                                                                            E_AlarmResponse.Abort_ImmediateError, \n                                                                            E_AlarmResponse.Abort_ImmediateError];\n</code></pre> <p>In the default case any alarm with severity <code>error</code> or <code>critical</code> will lead the controlling EM to an Abort_ImmediateError.</p> <p>The error reaction can be changed via property <code>ParentResponseDefinitions</code>.</p> <p></p> Tip Error Reaction <p>Example case to change the error reaction is the failure of a stack light fuse. The alarm can have severity error, however the error reaction is set to <code>E_AlarmResponse.NoResponse</code>.</p>"},{"location":"SPT_Components/ComponentGuide.html#hmi","title":"HMI","text":"<p>For communication with the HMI/UI the structure ending with <code>_HMI</code> will be used. This structure consists of three Parts - config, command and status. <pre><code>    // HMI\n    MyComponent_HMI         : ST_ComponentMyComponent_HMI;\n    HMICommandDescendant_RT : R_TRIG;\n</code></pre> <pre><code>TYPE ST_ComponentMyComponent_HMI :\n    STRUCT\n        Config  : ST_ComponentMyComponent_Config;\n        Command : ST_ComponentMyComponent_Command;\n        Status  : ST_ComponentMyComponent_Status;\n    END_STRUCT\nEND_TYPE\n</code></pre></p> <p><code>FB_ComponentBase</code> contains <code>ComponentBase_HMI</code> for the config, command and status from the Base Class to be used in HMI. E.g. Busy, Error, ErrorID.</p> <p>Code for Hmi communication will be placed in the overwritten method of <code>HMICommunication()</code>.</p> <p>First section ensures commands are triggered with positive edge. <pre><code>HMICommandDescendant_RT(CLK := (ComponentBase_HMI.Status.HMIControlAvailable AND NOT HMICommandActive_Base) AND (MyComponent_HMI.Command.MyCommand1 XOR MyComponent_HMI.Command.MyCommand2));\n</code></pre></p> <p>Allow and Block HMI Control</p> <p><code>ComponentBase_HMI.Status.HMIControlAvailable</code> is provided by the <code>FB_ComponentBase</code>. The Equipment Module can influence HMI operability by using the Methods <code>AllowHmiControl()</code> and <code>BlockHmiControl()</code>.</p> <p>Second section provides feedback to the base class if command is currently active to ensure one command at a time. <pre><code>HMICommandActive_Descendant := ComponentBase_HMI.Status.HMIControlAvailable AND (MyComponent_HMI.Command.MyCommand1 OR MyComponent_HMI.Command.MyCommand2);\n</code></pre></p> <p>The third section updates the status to the HMI. <pre><code>//Update HMI status info\nMyComponent_HMI.Status.MyVarProperty1 := _MyVarProperty1;\nMyComponent_HMI.Status.MyVarProperty2 := _MyVarProperty2;\n</code></pre></p>"},{"location":"SPT_Components/ComponentGuide.html#documentation","title":"Documentation","text":"<p>In any case it is necessary to document the intent and functionality of your custom component.</p> <p>To release the component via the SPT Framework platform the following documentation points are required.</p> <p>Rules for Documentation</p> <ul> <li> Class Diagram </li> <li> Flow charts of operation and commands</li> <li> User Guide with quick start and example code</li> <li> Interface documentation explaining all Methods and Properties</li> <li> Function Blocks, intended use and functions</li> <li> Data Types</li> <li> Parameter</li> <li> Change Log</li> </ul>"},{"location":"SPT_Components/ComponentGuide.html#template","title":"Template","text":"<p>This guide to write a component provides a template component to find here.</p> <p>The compiler errors will guide along with this document to develop a custom component. </p>"},{"location":"SPT_Components/PackMLEvent.html","title":"PackML Event Handler","text":"<p>Note</p> <p>This function block is only included in SPT V3</p>"},{"location":"SPT_Components/PackMLEvent.html#overview","title":"Overview","text":"<p>This function block is used as a component usually at the machine level.  This component will listen to the TcEvents and add them to the Pack ML Admin tags as needed.</p>"},{"location":"SPT_Components/PackMLEvent.html#function-block","title":"Function Block","text":"<pre><code>FUNCTION_BLOCK FB_Component_PackML_EventHandler EXTENDS FB_ListenerBase2 IMPLEMENTS I_ComponentBase\n</code></pre>"},{"location":"SPT_Components/PackMLEvent.html#methods","title":"Methods","text":"Name Return Type Description Initialize BOOL This will subscribe the instance of the FB to the Monitor TcAlarms CyclicLogic This is the method called by the list of components Execute HRESULT This is the work to monitor errors, time zone and event changes.  This is called in CyclicLogic once it is InitComplete EventListener HRESULT This is called to subscribe and unsubscribe to Monitor TcAlarms OnAlarmCleared HRESULT Callback for when TcAlarms are cleared OnAlarmConfirmed HRESULT Callback for when TcAlarms are confirmed OnAlarmRaised HRESULT Callback for when TcAlarms are raised Reset BOOL Clear all alarms in PackMLEventHandlerAlarms GetMsgInfos ST_PackML_aEventInfo This returns the statistics about Alarm events AllowHMIControl Not Used only a part of I_ComponenetBase BlockHMIControl Not Used only a part of I_ComponenetBase"},{"location":"SPT_Components/PackMLEvent.html#properties","title":"Properties","text":"Name Type Access Description AdminTag REFERENCE TO Tc3_PackML_V2.ST_PMLa W This is a reference to the admin tag of the Pack ML tags AlarmToStopReason BOOL W Busy BOOL R Busy if subscribed CurrentAlarmSeverity SPT_BaseTypes.TcEventSeverity R Error BOOL R ErrorID UDINT R InitComplete BOOL R This is set true once the Component is subscribed to the events InSimulation BOOL R This component does not use simulation.  This is just part of the Interface InternalErrorAck BOOL R/W Name STRING R/W Name of component ParentResponseDefinitions ARRAY [0..4] OF SPT_BaseTypes.E_AlarmResponse R/W WarningToStopReason BOOL W"},{"location":"SPT_Components/PackMLEvent.html#duts","title":"DUTs","text":""},{"location":"SPT_Components/PackMLEvent.html#st_eventinfo","title":"ST_EventInfo","text":"<pre><code>TYPE ST_EventInfo :\n    STRUCT\n        eSeverity           : TCEVENTSEVERITY;\n        EventClass          : GUID;\n        EventId             : UDINT;\n        ipArguments         : I_TcArguments;\n        fbRequestEventText  : FB_RequestEventText;\n        EventText           : STRING;\n        Source              : STRING;\n        TimeRaised          : ARRAY[0..6] OF DINT;\n        TimeConfirmed       : ARRAY[0..6] OF DINT;\n        TimeCleared         : ARRAY[0..6] OF DINT;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/PackMLEvent.html#st_packml_aeventinfo","title":"ST_PackML_aEventInfo","text":"<pre><code>TYPE ST_PackML_aEventInfo :\n    STRUCT\n        Warning       : ST_PackML_aMsgState; // Warning Informatins\n        Alarm         : ST_PackML_aMsgState; // Alarm Informations\n        StopReason    : ST_PackML_aMsgState; // StopReason Informations\n        HistorizedMsg : UDINT;           // Number of historized Messages\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/PackMLEvent.html#st_packml_amsgstate","title":"ST_PackML_aMsgState","text":"<pre><code>TYPE ST_PackML_aMsgState :\n    STRUCT\n        Active          : BOOL;  // a unconfirmed Message is pending\n        NumberActive    : UDINT; // Number of active Messages\n        NumberConfirmed : UDINT; // Number of confirmed Messages            \n        NumberCleared   : UDINT; // Number of Cleared Messages in History\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/PackMLEvent.html#fb_listenerbase2","title":"FB_ListenerBase2","text":"<p>Beckhoff Infosys FB_ListenerBase2</p>"},{"location":"SPT_Components/PackMLEvent.html#use-component","title":"Use Component","text":"<p>Since this function is a component, all that is needed to be done is declare it and initialize it.</p>"},{"location":"SPT_Components/PackMLEvent.html#declaration","title":"Declaration","text":"<p>Define the instance of the hanlder in the PackML module as needed.  You can name it anything you would like. <pre><code>//Components\nPackML_EventHandler : FB_Component_PackML_EventHandler := (Name := 'PackML Event Handler');\n</code></pre></p>"},{"location":"SPT_Components/PackMLEvent.html#initialization","title":"Initialization","text":"<p>Code like below must be used in the PackML module initialize routine that is using the FB_PackML_EventHandler. <pre><code>//Register your Sub modules and \nRegisterComponent(PackML_EventHandler);\nPackML_EventHandler.AdminTag REF= _PackTags.Admin;\n</code></pre></p>"},{"location":"SPT_Components/changelog.html","title":"Changelog","text":""},{"location":"SPT_Components/changelog.html#unreleased","title":"[Unreleased]","text":"<ul> <li>NC superimposed moves</li> <li>MDR component</li> <li>NC Torque Axis</li> </ul>"},{"location":"SPT_Components/changelog.html#403-2025-7-22","title":"[4.0.3] - 2025-7-22","text":""},{"location":"SPT_Components/changelog.html#fixed","title":"Fixed","text":"<ul> <li>FB_DigitalSensor When using the Inverted property, the Active signal was toggling on every cycle. This has been fixed to only toggle when the HardwareInput signal changes state, and any filtering has been applied.</li> </ul>"},{"location":"SPT_Components/changelog.html#402-2025-06-18","title":"[4.0.2] - 2025-06-18","text":""},{"location":"SPT_Components/changelog.html#added","title":"Added","text":"<ul> <li>Property for FB_Component_CamSlaveAxis<ul> <li>WaitingForCommand - Should be checked before calling: FindSlavePosition, FindSyncPosition, StartSync</li> </ul> <p>Dependency</p> <p>SPT_MotionControl v4.0.1 is required for this property to work correctly.</p> </li> </ul>"},{"location":"SPT_Components/changelog.html#401-2025-6-18","title":"[4.0.1] - 2025-6-18","text":""},{"location":"SPT_Components/changelog.html#added_1","title":"Added","text":"<ul> <li>FB_DigitalSensor now has properties for RisingEdge and Falling Edge detection of the Active signal (Simulation or Filtered Hardware Input).</li> </ul>"},{"location":"SPT_Components/changelog.html#fixed_1","title":"Fixed","text":"<ul> <li>FB_DigitalSensor EdgeFilter for falling edge. Set through E_DebounceMode.</li> </ul>"},{"location":"SPT_Components/changelog.html#40-2025-05-20","title":"[4.0] - 2025-05-20","text":""},{"location":"SPT_Components/changelog.html#replaced-dependencies","title":"Replaced Dependencies","text":"<ul> <li>Tc3_PackML_V2 with Tc3_PackML_V3</li> </ul>"},{"location":"SPT_Components/changelog.html#updated","title":"Updated","text":"<ul> <li>All references to Tc3_PackML_V2 have been updated to Tc3_PackML_V3</li> </ul>"},{"location":"SPT_Components/changelog.html#compiled","title":"Compiled","text":"<ul> <li>Using TwinCAT 3.1.4026</li> </ul>"},{"location":"SPT_Components/changelog.html#removed","title":"Removed","text":"<ul> <li>FB_Component_PackML_EventHandler</li> </ul>"},{"location":"SPT_Components/changelog.html#394-2025-7-23","title":"[3.9.4] - 2025-7-23","text":""},{"location":"SPT_Components/changelog.html#fixed_2","title":"Fixed","text":"<ul> <li>FB_DigitalSensor When using the Inverted property, the Active signal was toggling on every cycle. This has been fixed to only toggle when the HardwareInput signal changes state, and any filtering has been applied.</li> </ul>"},{"location":"SPT_Components/changelog.html#393-2025-6-19","title":"[3.9.3] - 2025-6-19","text":""},{"location":"SPT_Components/changelog.html#fixed_3","title":"Fixed","text":"<ul> <li>FB_DigitalSensor EdgeFilter for falling edge. Set through E_DebounceMode.</li> </ul>"},{"location":"SPT_Components/changelog.html#392-2025-05-29","title":"[3.9.2] - 2025-05-29","text":""},{"location":"SPT_Components/changelog.html#added_2","title":"Added","text":"<ul> <li>Property for FB_Component_CamSlaveAxis<ul> <li>WaitingForCommand - Should be checked before calling: FindSlavePosition, FindSyncPosition, StartSync</li> </ul> <p>Dependency</p> <p>SPT_MotionControl v3.9.2 is required for this property to work correctly.</p> </li> </ul>"},{"location":"SPT_Components/changelog.html#391-2025-04-21","title":"[3.9.1] - 2025-04-21","text":""},{"location":"SPT_Components/changelog.html#removed_1","title":"Removed","text":"<ul> <li>References to TcUnit</li> </ul>"},{"location":"SPT_Components/changelog.html#39-2025-04-14","title":"[3.9] - 2025-04-14","text":""},{"location":"SPT_Components/changelog.html#finalizing","title":"Finalizing","text":"<ul> <li>Internal updates and cleanup</li> </ul>"},{"location":"SPT_Components/changelog.html#33-2025-04-11","title":"[3.3] - 2025-04-11","text":""},{"location":"SPT_Components/changelog.html#sync","title":"Sync","text":"<ul> <li>Implement same version number across all SPT libraries</li> </ul>"},{"location":"SPT_Components/changelog.html#added_3","title":"Added","text":"<ul> <li>Code formatting and comments</li> </ul>"},{"location":"SPT_Components/changelog.html#removed_2","title":"Removed","text":"<ul> <li>Test Code</li> </ul>"},{"location":"SPT_Components/changelog.html#327-2024-03-01","title":"[3.2.7] - 2024-03-01","text":""},{"location":"SPT_Components/changelog.html#added_4","title":"Added","text":"<ul> <li>NC Axis components now raise an event when DriveDeviceError is flagged</li> <li>MODBUS-RTU communication component</li> </ul>"},{"location":"SPT_Components/changelog.html#3261-2023-12-5","title":"[3.2.6.1] - 2023-12-5","text":""},{"location":"SPT_Components/changelog.html#removed_3","title":"Removed","text":"<ul> <li>Vision component moved to its own library</li> </ul>"},{"location":"SPT_Components/changelog.html#326-2023-12-1","title":"[3.2.6] - 2023-12-1","text":""},{"location":"SPT_Components/changelog.html#added_5","title":"Added","text":"<ul> <li>Added vision component documentation</li> </ul>"},{"location":"SPT_Components/changelog.html#325-2023-11-17","title":"[3.2.5] - 2023-11-17","text":""},{"location":"SPT_Components/changelog.html#changed","title":"Changed","text":"<ul> <li>Added OPC-UA access to _HMI structs</li> </ul>"},{"location":"SPT_Components/changelog.html#324-2023-11-13","title":"[3.2.4] - 2023-11-13","text":""},{"location":"SPT_Components/changelog.html#added_6","title":"Added","text":"<ul> <li>FB_Component_BasicAxis/BasicSlaveAxis/CamSlaveAxis now include <code>ReadParameterSet()</code> and <code>AxisParameters</code> (See SPT Motion Control v3.2.4)</li> </ul>"},{"location":"SPT_Components/changelog.html#fixed_4","title":"Fixed","text":"<ul> <li>I_DigitalSensorBase now includes an Active property as intended</li> </ul>"},{"location":"SPT_Components/changelog.html#changed_1","title":"Changed","text":"<ul> <li>Removed call_after_online_change_slot pragma from CreateEvents().  This should fix existing issue with online changes causing cycle exceeds.</li> </ul>"},{"location":"SPT_Components/changelog.html#323-2023-09-05","title":"[3.2.3] - 2023-09-05","text":""},{"location":"SPT_Components/changelog.html#added_7","title":"Added","text":"<ul> <li>Added getter for InhibitFeedPositive/Negative (BasicAxis, BasicSlaveAxis, CamSlaveAxis)</li> </ul>"},{"location":"SPT_Components/changelog.html#322-2023-08-31","title":"[3.2.2] - 2023-08-31","text":""},{"location":"SPT_Components/changelog.html#added_8","title":"Added","text":"<ul> <li>Added FB_Component_PackML_EventHandler</li> </ul>"},{"location":"SPT_Components/changelog.html#changed_2","title":"Changed","text":"<ul> <li>Added Active property to I_DigitalSensorBase</li> </ul>"},{"location":"SPT_Components/changelog.html#fixed_5","title":"Fixed","text":"<ul> <li>FB_DigitalSensor HMI struct was not synchronizing with local settings</li> </ul>"},{"location":"SPT_Components/changelog.html#321","title":"[3.2.1]","text":""},{"location":"SPT_Components/changelog.html#removed_4","title":"Removed","text":"<ul> <li>HMI Jog Velocities removed from structure</li> </ul>"},{"location":"SPT_Components/changelog.html#320-2023-06-02","title":"[3.2.0] - 2023-06-02","text":""},{"location":"SPT_Components/changelog.html#added_9","title":"Added","text":"<ul> <li>Added external sequence wrapper method/properties/event</li> <li>Added license file to project (MIT License)</li> </ul>"},{"location":"SPT_Components/changelog.html#fixed_6","title":"Fixed","text":"<ul> <li>I_MotionSequence errors were not generating events in motion components</li> </ul>"},{"location":"SPT_Components/changelog.html#311-2023-05-08","title":"[3.1.1] - 2023-05-08","text":""},{"location":"SPT_Components/changelog.html#changed_3","title":"Changed","text":"<ul> <li>Removed all references to Tc3_System library</li> </ul>"},{"location":"SPT_Components/changelog.html#310-2023-04-14","title":"[3.1.0] - 2023-04-14","text":""},{"location":"SPT_Components/changelog.html#added_10","title":"Added","text":"<ul> <li>Unit tests for cylinder components</li> <li>Cylinder events added to PLC external types</li> </ul>"},{"location":"SPT_Components/changelog.html#3051-2023-03-16","title":"[3.0.5.1] - 2023-03-16","text":""},{"location":"SPT_Components/changelog.html#changed_4","title":"Changed","text":"<ul> <li>Added InhibitFeedPositive/Negative to NC BasicSlave and CamSlave components</li> </ul>"},{"location":"SPT_Components/changelog.html#305-2023-03-15","title":"[3.0.5] - 2023-03-15","text":""},{"location":"SPT_Components/changelog.html#added_11","title":"Added","text":"<ul> <li>Added cylinder components</li> </ul>"},{"location":"SPT_Components/changelog.html#changed_5","title":"Changed","text":"<ul> <li>Added InhibitFeedPositive/Negative to NC BasicAxis component</li> </ul>"},{"location":"SPT_Components/changelog.html#304-2023-01-11","title":"[3.0.4] - 2023-01-11","text":""},{"location":"SPT_Components/changelog.html#added_12","title":"Added","text":"<ul> <li>Added translation texts to CamSlave events</li> </ul>"},{"location":"SPT_Components/changelog.html#303-2022-11-17","title":"[3.0.3] - 2022-11-17","text":""},{"location":"SPT_Components/changelog.html#added_13","title":"Added","text":"<ul> <li>Added FB_Component_CamSlaveAxis</li> <li>Added CONSTANTS GVL to contain alarm counts, etc.</li> </ul>"},{"location":"SPT_Components/changelog.html#fixed_7","title":"Fixed","text":"<ul> <li>Changed how HomeMethod and ResetMethod are called so that error status is correctly captured</li> </ul>"},{"location":"SPT_Components/changelog.html#removed_5","title":"Removed","text":"<ul> <li>Parameters_Components removed.</li> </ul>"},{"location":"SPT_Components/changelog.html#302-2022-11-11","title":"[3.0.2] - 2022-11-11","text":""},{"location":"SPT_Components/changelog.html#fixed_8","title":"Fixed","text":"<ul> <li>BasicSlaveAxis alarms were not evaluated for severity.</li> </ul>"},{"location":"SPT_Components/changelog.html#301-2022-10-05","title":"[3.0.1] - 2022-10-05","text":""},{"location":"SPT_Components/changelog.html#changed_6","title":"Changed","text":"<ul> <li>Removed check of gear ratio in FB_Component_BasicSlaveAxis.  Previously would not allow &lt;= 0.  This is allowed now.</li> </ul>"},{"location":"SPT_Components/changelog.html#300-2022-10-05","title":"[3.0.0] - 2022-10-05","text":""},{"location":"SPT_Components/changelog.html#added_14","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_Components/cylinders.html","title":"Cylinders","text":""},{"location":"SPT_Components/cylinders.html#interfaces","title":"Interfaces","text":""},{"location":"SPT_Components/cylinders.html#i_solenoid","title":"I_Solenoid","text":"<p>Defines basic required functionality of all cylinders.</p>"},{"location":"SPT_Components/cylinders.html#properties","title":"Properties","text":"Property Type Access Description Extended BOOL R Returns <code>TRUE</code> if cylinder is extended ExtendedOutput BOOL R Returns <code>TRUE</code> if extend is being commanded ExtendTime LREAL RW Get/Set timeout period for extending (in milliseconds) Retracted BOOL R Returns <code>TRUE</code> if cylinder is retracted RetractOutput BOOL RW Returns <code>TRUE</code> if retract is being commanded RetractTime LREAL RW Get/Set timeout period for retracting (in milliseconds)"},{"location":"SPT_Components/cylinders.html#methods","title":"Methods","text":"Method Return Type Description Extend null Command cylinder to extend Retract null Command cylinder to retract"},{"location":"SPT_Components/cylinders.html#function-blocks","title":"Function Blocks","text":""},{"location":"SPT_Components/cylinders.html#fb_doublesolenoid","title":"FB_DoubleSolenoid","text":"<p>(extends <code>FB_SingleSolenoid</code>)</p> <p>Wrapper function block representing a cylinder with two solenoids controlling extend/retract commands and no feedback.</p>"},{"location":"SPT_Components/cylinders.html#fb_doublesolenoidfeedback","title":"FB_DoubleSolenoidFeedback","text":"<p>(extends <code>FB_DoubleSolenoid</code>)</p> <p>Wrapper function block representing a cylinder with two solenoids controlling extend/retract commands and feedback devices indicating extended/retracted state.  Includes alarms which are thrown if actuator's actual state differs for longer than a timeout period.</p>"},{"location":"SPT_Components/cylinders.html#properties_1","title":"Properties","text":"Property Type Access Description ExtendedInput BOOL W Set the state of the EXTENDED feedback device RetractedInput BOOL W Set the state of the RETRACTED feedback device"},{"location":"SPT_Components/cylinders.html#fb_singlesolenoid","title":"FB_SingleSolenoid","text":"<p>(extends <code>FB_ComponentBase</code>, implements <code>I_Solenoid</code>)</p> <p>Wrapper function block representing a cylinder with single solenoid (on =&gt; extend command) and no feedback.</p>"},{"location":"SPT_Components/cylinders.html#fb_singlesolenoidfeedback","title":"FB_SingleSolenoidFeedback","text":"<p>(extends <code>FB_SingleSolenoid</code>)</p> <p>Wrapper function block representing a cylinder with single solenoid (on =&gt; extend command) and feedback devices indicating extended/retracted state.  Includes alarms which are thrown if actuator's actual state differs for longer than a timeout period.</p>"},{"location":"SPT_Components/cylinders.html#properties_2","title":"Properties","text":"Property Type Access Description ExtendedInput BOOL W Set the state of the EXTENDED feedback device RetractedInput BOOL W Set the state of the RETRACTED feedback device"},{"location":"SPT_Components/cylinders.html#fb_solenoidbankbase","title":"FB_SolenoidBankBase","text":"<p>(<code>ABSTRACT</code>, extends <code>FB_ComponentBase</code>)</p> <p>Example Code Available</p> <p>See How to use FB_SolenoidBank for example use case.</p>"},{"location":"SPT_Components/cylinders.html#methods_1","title":"Methods","text":"Method Return Type Access Description AddSolenoid UINT Add a <code>I_Solenoid</code> to the bank"},{"location":"SPT_Components/cylinders.html#addsolenoid","title":"AddSolenoid()","text":"<pre><code>METHOD PUBLIC AddSolenoid : UINT\nVAR_INPUT\n    ipCylinder   : I_Cylinder;\n    Number       : UINT; //This is the number in the IO tree.\n    SolenoidType : E_SolenoidType;\nEND_VAR\n</code></pre>"},{"location":"SPT_Components/cylinders.html#mapio","title":"MapIO()","text":"<p>This is an abstract method that will be used to map the needed IO to the Networked IO. <pre><code>METHOD ABSTRACT MapIO\nVAR\n    x : UINT;\nEND_VAR\n</code></pre></p>"},{"location":"SPT_Components/cylinders.html#duts","title":"DUTs","text":""},{"location":"SPT_Components/cylinders.html#e_solenoidtype","title":"E_SolenoidType","text":"<pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_SolenoidType : (\n        Single,\n        Double,\n        SingleFeedback,\n        DoubleFeedback\n    );\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/cylinders.html#st_cylinder_hmi","title":"ST_Cylinder_HMI","text":"<pre><code>TYPE ST_Cylinder_HMI :\n    STRUCT\n        Config  : ST_Cylinder_Config;\n        Command : ST_Cylinder_Command;\n        Status  : ST_Cylinder_Status;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/cylinders.html#st_cylinder_command","title":"ST_Cylinder_Command","text":"<pre><code>TYPE ST_Cylinder_Command :\n    STRUCT\n        Extend      : BOOL;\n        Retract     : BOOL;\n        ExtendTime  : LREAL;\n        RetractTime : LREAL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/cylinders.html#st_cylinder_config","title":"ST_Cylinder_Config","text":"<pre><code>TYPE ST_Cylinder_Config :\n    STRUCT\n        ExtendTime  : LREAL;\n        RetractTime : LREAL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/cylinders.html#st_cylinder_status","title":"ST_Cylinder_Status","text":"<pre><code>TYPE ST_Cylinder_Status :\n    STRUCT\n        Extended   : BOOL;\n        Retracted  : BOOL;\n        Extending  : BOOL;\n        Retracting : BOOL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/cylinders.html#st_solenoidbankconfig","title":"ST_SolenoidBankConfig","text":"<pre><code>TYPE ST_SolenoidBankConfig :\n    STRUCT\n        SolenoidType         : E_SolenoidType;\n        ipSolenoid           : I_Solenoid;\n        SolenoidOutputNumber : UINT;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/cylinders.html#globalsparameters","title":"Globals/Parameters","text":""},{"location":"SPT_Components/cylinders.html#parameters_cylinder","title":"Parameters_Cylinder","text":"Parameter Type Default Description MAX_NUMBER_OF_SOLENOIDS UINT 32 Number of solenoids to be allocated in <code>FB_SolenoidBankBase</code>"},{"location":"SPT_Components/modbusrtu.html","title":"MODBUS-RTU","text":""},{"location":"SPT_Components/modbusrtu.html#function-blocks","title":"Function Blocks","text":""},{"location":"SPT_Components/modbusrtu.html#fb_component_modbusrtumaster","title":"FB_Component_ModbusRTUMaster","text":"<pre><code>FUNCTION_BLOCK FB_Component_ModbusRTUMaster EXTENDS FB_ComponentBase IMPLEMENTS I_ModbusProvider\n</code></pre> <p>Contains required function blocks and logic to implement a Modbus-RTU master.  Single and multi-drop configurations are supported.</p> <p>Note</p> <ul> <li>This component contains function blocks that require a TF6255 license</li> <li>At this time, only KL/EL6xxx terminals implementing 22 byte buffers are supported</li> </ul>"},{"location":"SPT_Components/modbusrtu.html#design-notes","title":"Design Notes","text":"<ul> <li>Modbus slaves should implement <code>I_ModbusConsumer</code> and at a minimum provide a unique identifier for the slave via <code>SlaveID</code>.</li> <li>Modbus requests contain one or many operations.  Operations are further divided into R/W operations.  An R/W operation is defined by a start &amp; end register(s), as well as a pointer to where the master should read/write the data for the above register(s).</li> <li>Modbus requests are categorized as Sync or Async.  Sync operations are analagous to EtherCAT process data, with a notable exception that they are processed serially versus completed cyclically.  Async operations are meant to only be executed once (example a momentary pushbutton signal), and always take precedence over sync operations.</li> <li>Care should be taken to understand the relationship between the task cycle time, the hardware buffering mechanisms, and the inherent limitation on data throughput that this creates.  Note this is separate from baud rate.  See Transfer Rates.</li> <li>Process data links to/from the serial hardware are provided by the component.</li> </ul>"},{"location":"SPT_Components/modbusrtu.html#examples","title":"Examples","text":"Setting up sync requests in init <pre><code>CASE SequenceState OF\n    0:\n        //Housekeeping--event creation, etc.\n        IF SUPER^.Initialize() THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    10:\n        //Wait for Modbus master assigned\n        //**This is application-dependant.  In this example the slave FB has a property for passing in an interface to FB_Component_ModbusRTUMaster**\n        IF ipModbusMaster &lt;&gt; 0 AND _SlaveID &lt;&gt; 0 THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    20:\n        //Setup normal sync data reads\n        SyncData.ipRequestor             := THIS^;  //Allows master to call back after request complete\n        SyncData.ReadOps[1].StartAddress := 1000;\n        SyncData.ReadOps[1].EndAddress   := 1010;\n        SyncData.ReadOps[1].pAddress     := ADR(MySlaveStatusData); //This could be a DUT, group of vars, etc.\n\n        IF ipModbusMaster.RegisterSyncRequest(Request := SyncData, RequestID =&gt; SyncData.RequestID) THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    30:\n        //Setup async requests\n        //** In this case AsyncRequests is an array of ST_ModbusRequest **\n\n        FOR i := 1 TO MAX_ASYNC_REQUESTS DO\n            AsyncRequests[i].ipRequestor := THIS^;\n        END_FOR\n\n        // Stop Request - Write Stop Command\n        AsyncRequests[E_AsyncRequest.eAsyncRequest_Stop].WriteOps[1].StartAddress := 1023;\n        AsyncRequests[E_AsyncRequest.eAsyncRequest_Stop].WriteOps[1].EndAddress   := 1024;\n        AsyncRequests[E_AsyncRequest.eAsyncRequest_Stop].WriteOps[1].pAddress     := ADR(StopCommandFlag);\n\n        // Move Request - Write Move Command\n        AsyncRequests[E_AsyncRequest.eAsyncRequest_Move].WriteOps[1].StartAddress := 1020;\n        AsyncRequests[E_AsyncRequest.eAsyncRequest_Move].WriteOps[1].EndAddress   := 1021;\n        AsyncRequests[E_AsyncRequest.eAsyncRequest_Move].WriteOps[1].pAddress     := ADR(MoveCommandFlag);\n        SequenceState                                                             := SequenceState + 10;\n\n    40:\n        Trace('Init complete');\n        Initialize := TRUE;\nEND_CASE\n</code></pre> Register an async request <pre><code>IF ipModbusMaster\n    .RegisterAsyncRequest(Request := AsyncRequests[E_Bansbach_AsyncRequest.eBansbachAsyncRequest_Stop], RequestID =&gt; AsyncRequests[E_Bansbach_AsyncRequest.eBansbachAsyncRequest_Stop].RequestID) THEN\n    Trace('Stop commanded');\n    Stop := TRUE;\nEND_IF\n</code></pre> Handle request complete callback <pre><code>METHOD ModbusRequestComplete\nVAR_INPUT\n    RequestID : ULINT;\nEND_VAR\n\nVAR\n    i : UDINT;\nEND_VAR\n~~~~~~~~~~\n//If the completed request is an async request, reset the RequestID to signal completed\nCurrentCommsCount := CurrentCommsCount + 1;\nFOR i := 1 TO MAX_ASYNC_REQUESTS DO\n    IF AsyncRequests[i].RequestID = RequestID THEN\n        Trace('Async modbus request completed');\n        AsyncRequests[i].RequestID := 0;\n        EXIT;\n    END_IF\nEND_FOR\n</code></pre>"},{"location":"SPT_Components/modbusrtu.html#interfaces","title":"Interfaces","text":""},{"location":"SPT_Components/modbusrtu.html#i_modbusconsumer","title":"I_ModbusConsumer","text":"<p>Function blocks requiring R/W services from the master shall implement <code>I_ModbusConsumer</code>.  This interface provides mechanisms for corellating particular function block instances with the Modbus slaves they represent, as well as a callback mechanism for the master to notify slaves of status information.</p>"},{"location":"SPT_Components/modbusrtu.html#properties","title":"Properties","text":"Property Type Access Description SlaveID BYTE R Unique slave identifier on bus"},{"location":"SPT_Components/modbusrtu.html#methods","title":"Methods","text":"Method Return Type Description ModbusRequestComplete null Callback from <code>I_ModbusProvider</code> which signals that a particular request (sync/async) has been completed.  Input parameter <code>RequestID</code> is given by the master to indicate which request completed."},{"location":"SPT_Components/modbusrtu.html#i_modbusprovider","title":"I_ModbusProvider","text":"<p>Function blocks implementing <code>I_ModbusConsumer</code> register their R/W requests with the master via the methods provided by <code>I_ModbusProvider</code>. </p>"},{"location":"SPT_Components/modbusrtu.html#methods_1","title":"Methods","text":"Method Return Type Description RegisterAsyncRequest BOOL Register a set of asynchronous R/W operations to be executed as soon as possible RegisterSyncRequest BOOL Register a set of synchronous R/W operations to be executed cyclically, in order of registration"},{"location":"SPT_Components/modbusrtu.html#duts","title":"DUTs","text":""},{"location":"SPT_Components/modbusrtu.html#st_modbusoperation","title":"ST_ModbusOperation","text":"<pre><code>TYPE ST_ModbusOperation :\n    STRUCT\n        StartAddress : UINT;\n        EndAddress   : UINT;\n        pAddress     : PVOID;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/modbusrtu.html#st_modbusrequest","title":"ST_ModbusRequest","text":"<pre><code>TYPE ST_ModbusRequest :\n    STRUCT\n        ipRequestor : I_ModbusConsumer;\n        RequestID   : ULINT;\n        ReadOps     : ARRAY[1..Parameters_ModbusRTU.MAX_MODBUS_RW_OPS_PER_REQUEST] OF ST_ModbusOperation;\n        WriteOps    : ARRAY[1..Parameters_ModbusRTU.MAX_MODBUS_RW_OPS_PER_REQUEST] OF ST_ModbusOperation;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/modbusrtu.html#globalsparameters","title":"Globals/Parameters","text":""},{"location":"SPT_Components/modbusrtu.html#parameters_modbusrtu","title":"Parameters_ModbusRTU","text":"Parameter Type Default Description MAX_MODBUS_REQUESTS UDINT 100 Maximum sync &amp; async requests that can be registered with a master MAX_MODBUS_RW_OPS_PER_REQUEST UDINT 100 Maximum operations per request MODBUS_TIMEOUT TIME T#100MS Modbus-RTU communications timeout period"},{"location":"SPT_Components/motioncontrol.html","title":"Motion Control","text":""},{"location":"SPT_Components/motioncontrol.html#function-blocks","title":"Function Blocks","text":""},{"location":"SPT_Components/motioncontrol.html#fb_component_basicaxis","title":"FB_Component_BasicAxis","text":"<pre><code>FUNCTION_BLOCK FB_Component_BasicAxis EXTENDS FB_ComponentBase IMPLEMENTS I_BasicAxis\n</code></pre> <p>Wrapper function block adding <code>I_ComponentBase</code> properties and methods to <code>FB_BasicAxis</code>.  All motion method calls have the same signature as <code>FB_BasicAxis</code>.</p> <p>Note</p> <p>See also:     - I_ComponentBase     - I_BasicAxis</p>"},{"location":"SPT_Components/motioncontrol.html#fb_component_basicslaveaxis","title":"FB_Component_BasicSlaveAxis","text":"<pre><code>FUNCTION_BLOCK FB_Component_BasicSlaveAxis EXTENDS FB_ComponentBase IMPLEMENTS I_BasicAxis\n</code></pre> <p>Wrapper function block adding <code>I_ComponentBase</code> properties and methods to <code>FB_BasicSlaveAxis</code>.  All motion method calls have the same signature as <code>FB_BasicAxis</code> and <code>FB_BasicSlaveAxis</code>.</p> <p>Note</p> <p>See also:   - I_ComponentBase   - I_BasicAxis   - I_BasicSlaveAxis</p>"},{"location":"SPT_Components/motioncontrol.html#fb_component_camslaveaxis","title":"FB_Component_CamSlaveAxis","text":"<pre><code>FUNCTION_BLOCK FB_Component_CamSlaveAxis EXTENDS FB_ComponentBase IMPLEMENTS I_CamSlaveAxis\n</code></pre> <p>Wrapper function block adding <code>I_ComponentBase</code> properties and methods to <code>FB_CamSlaveAxis</code>.  All motion method calls have the same signature as <code>FB_BasicAxis</code> and <code>FB_CamSlaveAxis</code>.</p> <p>Note</p> <p>See also:   - I_ComponentBase   - I_BasicAxis   - I_CamSlaveAxis</p>"},{"location":"SPT_Components/motioncontrol.html#duts","title":"DUTs","text":""},{"location":"SPT_Components/motioncontrol.html#st_axisbase_hmi","title":"ST_AxisBase_HMI","text":"<pre><code>TYPE ST_AxisBase_HMI :\n    STRUCT\n        Config  : ST_AxisBase_Config;\n        Command : ST_AxisBase_Command;\n        Status  : ST_AxisBase_Status;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/motioncontrol.html#st_axisbase_command","title":"ST_AxisBase_Command","text":"<pre><code>TYPE ST_AxisBase_Command :\n    STRUCT\n        JogFast_Forward  : BOOL;\n        JogFast_Backward : BOOL;\n        JogSlow_Forward  : BOOL;\n        JogSlow_Backward : BOOL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/motioncontrol.html#st_axisbase_config","title":"ST_AxisBase_Config","text":"<pre><code>TYPE ST_AxisBase_Config :\n    STRUCT\n\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/motioncontrol.html#st_axisbase_status","title":"ST_AxisBase_Status","text":"<pre><code>TYPE ST_AxisBase_Status :\n    STRUCT\n        Enabled              : BOOL;\n        InPosition           : BOOL;\n        Stopped              : BOOL;\n        Coupled              : BOOL;\n        SetPosition          : LREAL;\n        SetPositionModulo    : LREAL;\n        SetVelocity          : LREAL;\n        SetAcceleration      : LREAL;\n        ActualPosition       : LREAL;\n        ActualPositionModulo : LREAL;\n        ActualVelocity       : LREAL;\n        ActualAcceleration   : LREAL;\n        ActualTorque         : LREAL;\n        PositionLag          : LREAL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/sensors.html","title":"Sensors","text":""},{"location":"SPT_Components/sensors.html#interfaces","title":"Interfaces","text":""},{"location":"SPT_Components/sensors.html#i_digitalsensorbase","title":"I_DigitalSensorBase","text":""},{"location":"SPT_Components/sensors.html#properties","title":"Properties","text":"Property Type Access Description Active BOOL RO Get the current state of the sensor DebounceMode E_DebounceMode RW Get/Set the filter to be applied to sensor input DebounceTime TIME RW Get/Set filter time to be used by <code>DebounceMode</code> Inverted BOOL RW Get/Set if output of sensor should be inverted with respect to its input SimulationInput BOOL RW Get/Set signal to use when component is in simulation mode SimulationMode E_SensorSimulationMode RW Get/Set type of simulation to be used in simulation mode TimeActive TIME RO Get time elapsed since last inactive state TimeInactive TIME RO Get time elapsed since last active state"},{"location":"SPT_Components/sensors.html#function-blocks","title":"Function Blocks","text":""},{"location":"SPT_Components/sensors.html#fb_digitalsensor","title":"FB_DigitalSensor","text":"<p><pre><code>FUNCTION_BLOCK FB_DigitalSensor EXTENDS FB_ComponentBase IMPLEMENTS I_DigitalSensorBase\n</code></pre> Basic digital input processor for digital signals.  Includes locally-defined <code>HardwareInput AT %I* : BOOL</code> for linking to hardware.</p>"},{"location":"SPT_Components/sensors.html#duts","title":"DUTs","text":""},{"location":"SPT_Components/sensors.html#e_debouncemode","title":"E_DebounceMode","text":"<pre><code>TYPE E_DebounceMode : (\n        RawInput,\n        SimpleFlickerFilter,\n        EdgeDetectFilter,\n        MovingAverage\n    ) DINT;\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/sensors.html#e_sensorsimulationmode","title":"E_SensorSimulationMode","text":"<pre><code>TYPE E_SensorSimulationMode : (\n        InputDriven, //Follows the state of the SimulationInput property\n        Periodic     //Follows a 50% duty cycle at the period specified in ms by SimulationInput);\n    );\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/sensors.html#st_digitalsensor_hmi","title":"ST_DigitalSensor_HMI","text":"<pre><code>TYPE ST_DigitalSensor_HMI :\n    STRUCT\n        Config  : ST_DigitalSensor_Config;\n        Command : ST_DigitalSensor_Command;\n        Status  : ST_DigitalSensor_Status;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/sensors.html#st_digitalsensor_command","title":"ST_DigitalSensor_Command","text":"<pre><code>TYPE ST_DigitalSensor_Command :\n    STRUCT\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/sensors.html#st_digitalsensor_config","title":"ST_DigitalSensor_Config","text":"<pre><code>TYPE ST_DigitalSensor_Config :\n    STRUCT\n        //Status information\n        DebounceMode       : E_DebounceMode;\n        DebounceTime       : TIME;\n        Inverted           : BOOL;\n        SimulationMode     : E_SensorSimulationMode;\n        SimulationTimebase : UINT;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/sensors.html#st_digitalsensor_status","title":"ST_DigitalSensor_Status","text":"<pre><code>TYPE ST_DigitalSensor_Status :\n    STRUCT\n        Active       : BOOL;\n        TimeActive   : LREAL;\n        TimeInactive : LREAL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/sensors.html#examples","title":"Examples","text":"<p>E_DebounceMode.EdgeDetectFilter  </p> <p></p> <p>The blue line represents the hardware input which bounces both when rising and falling. The green line is the output of the filter which detects the initial change and then ignores the bounces for the duration specified by <code>DebounceTime</code>. This is useful for preventing a 'double-tap' that could occur when a button is pressed.</p> <p>E_DebounceMode.SimpleFlickerFilter</p> <p></p> <p>The blue line represents the hardware input which bounces both when rising and falling. The green line is the output of the filter which monitors the input and only changes state when the input has been stable for the time specified by <code>DebounceTime</code>. This is useful for preventing false triggers from noise, dust or other rapid changes in the input signal.</p>"},{"location":"SPT_Components/Vision/VisionBlob.html","title":"VisionBlob","text":""},{"location":"SPT_Components/Vision/VisionBlob.html#code","title":"Code","text":"<pre><code>// Convert Images into the necessary color space\nhr := F_VN_GetPixelFormat(ipImageIn, PixelFormat, hr);\nIF PixelFormat.nChannels = 3 THEN\n    hr := F_VN_CopyImage(ipImageIn, ipImageRes, hr);\n    hr := F_VN_ConvertColorSpace(ipImageRes,\n                                 ipImageIn,\n                                 TCVN_CST_RGB_TO_GRAY,\n                                 hr);\nELSE\n    hr := F_VN_ConvertColorSpace(ipImageIn,\n                                 ipImageRes,\n                                 TCVN_CST_Gray_TO_RGB,\n                                 hr);\nEND_IF\n\n// Image Segementation\nhr := F_VN_Threshold(ipImageIn,\n                     ipImageWork,\n                     _BlobParams.fMinThreshold,\n                     255,\n                     TCVN_TT_Binary,\n                     hr);\n// Start Watchdog - DetectBlobs - Stop Watchdog\nhrWD   := F_VN_StartRelWatchdog(tStop, S_OK);\nhrFunc := F_VN_DetectBlobs(ipSrcImage     := ipImageWork,\n                           ipBlobContours := ipContourList,\n                           stParams       := _BlobParams,\n                           hrPrev         := hr);\n\nhrWD := F_VN_StopWatchdog(hrWD, tRest =&gt; tRest, nFractionProcessed =&gt; nFraction);\n\n\n//Clear Results and set new results-Number of Blobs\nMEMSET(ADR(Results), 0, SIZEOF(Results));\nulint_ref REF= (NumberOfBlobs);\nhr        := F_VN_GetNumberOfElements(ipContainer := ipContourList, nNumberOfElements := ulint_ref, hrPrev := hr);\nIF NumberOfBlobs &gt; 0 THEN\n    FOR i := 0 TO (NumberOfBlobs - 1) BY 1 DO\n        hr := F_VN_GetAt_ITcVnContainer(ipSrcContainer  := ipContourList,\n                                        ipDestContainer := ipResultContainer,\n                                        nIndex          := i,\n                                        hrPrev          := hr);\n\n        hr := F_VN_ContourArea(ipContour := ipResultContainer, fArea := Results[i + 1].Area, hrPrev := hr);\n        hr := F_VN_ContourCenterOfMass(ipContour := ipResultContainer, aCenterOfMass := Results[i+1].CenterOfMass, hrPrev := hr);\n\n        //More items\n        hr := F_VN_ContourCircularity(ipContour := ipResultContainer, fCircularity := Results[i + 1].Circularity, hrPrev := hr);\n        hr := F_VN_ContourConvexity(ipContour := ipResultContainer, fConvexity := Results[i + 1].Convexity, hrPrev := hr);\n        hr := F_VN_ContourEccentricity(ipContour := ipResultContainer, fEccentricity := Results[i + 1].Eccentricity, hrPrev := hr);\n        hr := F_VN_ContourInertiaRatio(ipContour := ipResultContainer, fInertiaRatio := Results[i + 1].InertiaRatio, hrPrev := hr);\n        hr := F_VN_ContourOrientation(ipContour := ipResultContainer, stOrientation := Results[i+1].Orientation, hrPrev := hr);\n        hr := F_VN_ContourPerimeter(ipContour  := ipResultContainer,\n                                    fPerimeter := Results[i + 1].Perimeter,\n                                    bClosed    := TRUE,\n                                    hrPrev     := hr);\n\n        hr := F_VN_ContourRoundness(ipContour := ipResultContainer, fRoundness := Results[i + 1].Roundness, hrPrev := hr);\n\n    END_FOR\nEND_IF\n\n(* Draw Result Image\n// --------------------------------------------------------------*)\nhr := F_VN_DrawContours(ipContourList,\n                        -1,\n                        ipImageRes,\n                        GVL_VisionColor.ColorGreen,\n                        3,\n                        hr);\n\nIF NumberOfBlobs &gt; 0 THEN\n    FOR i := 0 TO (NumberOfBlobs - 1) DO\n        hr := F_VN_GetAt_ITcVnContainer(ipSrcContainer  := ipContourList,\n                                        ipDestContainer := ipResultContainer,\n                                        nIndex          := i,\n                                        hrPrev          := hr);\n\n        //hr     := F_VN_UprightBoundingRectangle(ipResultContainer, Rect, hr);\n        Text := TO_STRING(i + 1);\n        hr   := F_VN_PutText(Text,\n                             ipImageRes,\n                             TO_UDINT(Results[i + 1].CenterOfMass[0]) - 20,\n                             TO_UDINT(Results[i + 1].CenterOfMass[1]) + 20,\n                             TCVN_FT_HERSHEY_DUPLEX,\n                             2,\n                             GVL_VisionColor.ColorMagenta,\n                             hr);\n    END_FOR\nEND_IF\n\n// Display Input Image\nhr := F_VN_TransformIntoDisplayableImage(ipImageIn, ipImageInDisp, hr);\n\n// Display Result Image\nhr := F_VN_TransformIntoDisplayableImage(ipImageRes, ipImageResDisp, hr);\n\n// Display Threshold Image\nhr := F_VN_TransformIntoDisplayableImage(ipImageWork, ipImageThresholdDisp, hr);\n</code></pre>"},{"location":"SPT_Components/Vision/VisionBlob.html#blob-parameters","title":"Blob Parameters","text":"Name Type Default Description FilterByArea BOOL TRUE Enable filtering by area (fMinArea &lt;= area &lt;= fMaxArea); strongly recommended to activate for filtering noise with fMinArea. FilterByCircularity BOOL FALSE Enable filtering by circularity (fMinCircularity &lt;= circularity(4pi * area / perimeter^2) &lt;= fMaxCircularity). FilterByConvexity BOOL FALSE Enable filtering by convexity (fMinConvexity &lt;= convexity(area / hullArea) &lt;= fMaxConvexity). FilterByEccentricity BOOL FALSE Enable filtering by eccentricity (fMinEccentricity &lt;= eccentricity &lt;= fMaxEccentricity). FilterByInertiaRatio BOOL FALSE Enable filtering by inertia ratio (fMinInertiaRatio &lt;= inertia ratio &lt;= fMaxInertiaRatio). MinArea REAL 10 Min estimated blob area in pixel MaxArea REAL 100000000 Max estimated blob area in pixel MinCircularity REAL 0 Min circularity (1.0: ideal circle, &lt; 1: less circular, 0: not circular at all) MaxCircularity REAL 1 Max circularity (1.0: ideal circle, &lt; 1: less circular, 0: not circular at all) MinConvexity REAL 0 Min convexity (1.0: blob fully convex, &lt; 1: less convex) MaxConvexity REAL 1 Max convexity (1.0: blob fully convex, &lt; 1: less convex) MinEccentricity REAL 0 Min eccentricity (0.0: circular, 1.0: linear) MaxEccentricity REAL 1 Max eccentricity (0.0: circular, 1.0: linear) MinInertiaRatio REAL 0 Min inertia ratio (1.0: equal width and height, 0.0: linear) MinInertiaRatio REAL 0 Max inertia ratio (1.0: equal width and height, 0.0: linear) ThresholdType ETcVnThresholdType TCVN_TT_BINARY Threshold type for internally applied threshold method (OTSU_XXX only supported for USINT images). MinThreshold REAL 30 Threshold to start with (if fThresholdStep &gt; 0, otherwise this is the only threshold used). MaxThreshold REAL 225 MinThreshold : REAL := 30 ThresholdStep REAL 0 Sets to 0 if only 1 threshold should be used (much faster than multiple thresholds and combining the results). MinBlobDistance REAL 5 Minimum distance between the center points of two different blobs (only used if fThresholdStep &gt; 0; if distance &lt; fMinBlobDistance, the blobs are treated as the same). MinRepeatability UDINT 2 Minimum number of threshold steps, for which the same contour has to be detected (only used if fThresholdStep &gt; 0; same means center point distance &lt; fMinBlobDistance). BlobCombination ETcVnBlobCombination TCVN_BC_MEDIAN_THRESHOLD Selects, which of the multi-threshold blob contours should be returned."},{"location":"SPT_Components/Vision/VisionBlob.html#results","title":"Results","text":"<pre><code>TYPE ST_BlobResults :\n    STRUCT\n        Area           : LREAL;\n        CenterOfMass   : TcVnPoint2_LREAL;\n        Circularity    : LREAL;\n        Convexity      : LREAL;\n        Eccentricity   : LREAL;\n        ExtremePoint   : TcVnPoint2_LREAL;\n        InertiaRatio   : LREAL;\n        Moments        : TcVnMoments;\n        Orientation    : TcVnRotatedRectangle;\n        OrientationExp : TcVnRotatedRectangle;\n        Perimeter      : LREAL;\n        Roundness      : LREAL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Components/Vision/VisionConcept.html","title":"VisionConcept","text":"<p>This is the documentation on the SPT Vision Library objects.   </p> <p>The vision process takes some time, so there will be another Task seperate from the PLC Task.  A good name for this can be VisionMain.  In this task, there will be an instance of the vision process type you choose (see further documentation).  In the PLC task under the machine module or equipment module you will have an instance of the FB_PLCTask.  Together these components will communicate by using the TwinCAT Process data space and linking variables.</p>"},{"location":"SPT_Components/Vision/VisionConcept.html#block-diagram","title":"Block Diagram","text":""},{"location":"SPT_Components/Vision/VisionConcept.html#process-data","title":"Process Data","text":"Name Type Output From Description RunVision BOOL PLC Task This will run the vision to aquiring when high and stop the aquiring when low SoftwareTrigger BOOL PLC Task This will software trigger the camera to take an image Reset BOOL PLC Task This is used to reset vision system when under error CameraState ETcVnCameraState Vision Task This is a status of the camera's state ResultsAvailable BOOL Vision Task This will let the PLC task know that there are results NumberOfResults UDINT Vision Task This is the number of elements found in the results Results ARRAY[1..MAX_BUFFER_BYTES] of BYTE Vision Task The data type that is put into buffer will be decided at application time from the process of analysis.  Each side will have to define the structure of results needed for PLC task to function Error BOOL Vision Task This is set when there is an error ErrorID UDINT Vision Task This is the value of the Alarm when one is set"},{"location":"SPT_Components/Vision/VisionConcept.html#global-parameter-list","title":"Global Parameter List","text":"<p>This list can be edited in the Library references for your project to be the size needed for your application.</p> <pre><code>{attribute 'qualified_only'}\nVAR_GLOBAL CONSTANT\n    MAX_BUFFER_BYTES : UDINT := 1000;\nEND_VAR\n</code></pre>"},{"location":"SPT_Components/Vision/VisionConcept.html#typical-flow-diagram-software-trigger","title":"Typical Flow Diagram Software Trigger","text":"<pre><code>sequenceDiagram\n\nparticipant plc as PlcApp\nparticipant plctask as PlcTaskComponent\nparticipant visiontask as VisionTaskComponent\nparticipant c as Camera\nplc-&gt;&gt;plctask: Run Vision\nplctask-&gt;&gt;visiontask: RunVision\nloop Get to acquire\nvisiontask-&gt;&gt;c: Initialize,open,acquire\nc-&gt;&gt;visiontask: Camera States\nend\nvisiontask-&gt;&gt;plctask: Camera State(acquire)\nplctask-&gt;&gt;plc: Camera State(acquire)\nloop vision cylce\nplc-&gt;&gt;plctask: Software Trigger\nplctask-&gt;&gt;visiontask: SoftwareTrigger\nvisiontask-&gt;&gt;c: Trigger\nc-&gt;&gt;c: Capture Image\nc-&gt;&gt;visiontask: Image\nvisiontask-&gt;&gt;visiontask: Process the Image\nvisiontask-&gt;&gt;plctask:Results\nplctask-&gt;&gt;plc:Results\nNote over plc: Copy Results \nend</code></pre>"},{"location":"SPT_Components/Vision/VisionDetection.html","title":"VisionDetection","text":"<p>The concept is that this FB and its methods will use the base class to take a picture and the process it and return elements that fit the processing with the following Results as a minimum:</p> <ol> <li>Center of Mass (x,y)</li> <li>Orientation (a)</li> </ol>"},{"location":"SPT_Components/Vision/VisionDetection.html#fb_visiondetection","title":"FB_VisionDetection","text":""},{"location":"SPT_Components/Vision/VisionDetection.html#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\nclass FB_VisionBase{\n    &lt;&lt;ABSTRACT&gt;&gt;\n    eState : ETcVnCameraState;\n    VisionBaseAlarms : ARRAY[1..x] of FB_TcAlarm\n    ProcessImage()\n    CyclicLogic()\n    Reset()\n    CreateEvents()\n    GetResults()\n}   \n\nclass FB_VisionDetection{\n    ProcessImage()\n    ProcessImage_Blob()\n    ProcessImage_Color()\n    ProcessImage_Contour()\n}\n\n\nFB_VisionBase&lt;|--FB_VisionDetection</code></pre>"},{"location":"SPT_Components/Vision/VisionDetection.html#process-image","title":"Process Image","text":"<pre><code>CASE VisionTool OF\n    E_VisionTools.Blob:\n        ProcessImage_Blob();\n    E_VisionTools.Contour:\n        ProcessImage_Contour();\n    E_VisionTools.Color:\n        ProcessImage_Color();\nEND_CASE\n</code></pre>"},{"location":"SPT_Components/Vision/VisionDetection.html#e_visiontools","title":"E_VisionTools","text":"<pre><code>classDiagram\nclass E_VisionTools{\n    &lt;&lt;Enumeration&gt;&gt;\n    Blob\n    Contour\n    Color\n}</code></pre>"},{"location":"SPT_Components/Vision/VisionDetection.html#alarms","title":"Alarms","text":"<p> These still need to be defined from what can happen with this process image</p>"},{"location":"SPT_Components/Vision/VisionDetection.html#to-do","title":"To Do","text":"<ol> <li>Decide on all of the analysis tools we want to use</li> <li>HMI user object to setup these things</li> </ol>"},{"location":"SPT_Components/Vision/VisionPLC.html","title":"VisionPLC","text":""},{"location":"SPT_Components/Vision/VisionPLC.html#plc-task","title":"PLC Task","text":"<p>The PLC Camera Base handles the PLC to Camera interaction. By separating the PLC task and Vision task, the PLC task is allowed to run at a faster clock cycle than the Vision task so that other PLC functions are not affected by the slower processing of images. The PLC task is used to run the vision jobs that are setup in the vision task. It also has access to vision results so that it may be used in a PLC process. </p>"},{"location":"SPT_Components/Vision/VisionPLC.html#fb_plccamerabase","title":"FB_PlcCameraBase","text":"<pre><code>FUNCTION_BLOCK FB_PlcCameraBase EXTENDS FB_ComponentBase\n</code></pre>"},{"location":"SPT_Components/Vision/VisionPLC.html#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\n\n\nclass FB_PlcCameraBase{\n    CreateEventsI()\n    CyclicLogic()\n    GetResults()\n    Reset()\n\n    RunVision\n    TriggerImage\n    VisionAlarms\n}\n\nFB_PlcCameraBase--|&gt;FB_ComponentBase</code></pre>"},{"location":"SPT_Components/Vision/VisionPLC.html#outputs","title":"Outputs","text":"Name Type Description RunVision BOOL This will run the vision to aquiring when high and stop the aquiring when low SoftwareTrigger BOOL This will software trigger the camera to take an image Reset BOOL This is used to reset vision system when under error"},{"location":"SPT_Components/Vision/VisionPLC.html#inputs","title":"Inputs","text":"Name Type Description CameraState ETcVnCameraState This is a status of the camera's state ResultsAvailable BOOL This will let the PLC task know that there are results NumberOfResults UDINT This is the number of elements found in the results Results ARRAY[1..MAX_RESULTS_BUFFER_BYTES] of BYTE The data type that is put into buffer will be decided at application time from the process of analysis.  Each side will have to define the structure of results needed for PLC task to function VisionError BOOL This is set when there is an error VisionErrorID UDINT This is the value of the Alarm when one is set VisionAlarms ARRAY[1..5] of FB_TcAlarm Alarm object used with Event Logger"},{"location":"SPT_Components/Vision/VisionPlayback.html","title":"VisionPlayback","text":""},{"location":"SPT_Components/Vision/VisionPlayback.html#fb_videoplaybackcontrol","title":"FB_VideoPlaybackControl","text":"<p>This is a function block to add the feature of buffering the images from a vision system and then stitch them together to create a video.  In order to do this, the PLC will communicate with a C# application.  The C# application will connect as a client to the ADS of the PLC on Local and at port 851. The C# App has the ability to work on multiple cameras from one PLC.</p>"},{"location":"SPT_Components/Vision/VisionPlayback.html#parameters","title":"Parameters","text":"<p>The Parameters_Vision are adjustable per application and have the following defaults</p> <pre><code>{attribute 'qualified_only'}\nVAR_GLOBAL CONSTANT\n    MAX_RESULTS_BUFFER_BYTES   : UDINT := 1000;\n    MAX_NUMBER_CAMERAS : USINT := 1;\n    MAX_NUMBER_IMAGES_2_VIDEO : UINT := 200;\nEND_VAR\n</code></pre>"},{"location":"SPT_Components/Vision/VisionPlayback.html#gvl_images2video","title":"GVL_Images2Video","text":"<p>In order to make a C# application with as little configuration as possible, the following GVL data was created so the program can run easily.  The first thing the C# app does is ask how many cameras and then it creates the ability to connect to the data of each camera.</p> <pre><code>{attribute 'qualified_only'}\nVAR_GLOBAL\n    NumberOfCameras    : UINT := Parameters_Vision.MAX_NUMBER_CAMERAS;\n    CameraData         : ARRAY[1..Parameters_Vision.MAX_NUMBER_CAMERAS] OF ST_Image2Video;\nEND_VAR\n</code></pre>"},{"location":"SPT_Components/Vision/VisionPlayback.html#definition","title":"Definition","text":"<p><code>FUNCTION_BLOCK FB_VideoPlaybackControl EXTENDS FB_ListenerBase2 IMPLEMENTS I_CyclicFB</code></p>"},{"location":"SPT_Components/Vision/VisionPlayback.html#fb_listenerbase2","title":"FB_ListenerBase2","text":"Name Return Type Input Description Execute HRESULT none This is called to run the listening code OnAlarmRaised HRESULT fbEvent : REFERENCE TO FB_TcEvent This gets called when an alarm with this filtering happens <p>This is the subscription to the Events and the JSONString is:</p> <p><code>JSONString       : T_MaxString := '{\"CreateVideo\": 1}';</code> <pre><code>IF _Subscribe THEN\n    _Subscribe := FALSE;\n    JSONFilter.Clear().JsonAttribute.Value.EqualTo(JSONString); //define all events (messages and alarms) from this eventclass   \n    hr := Subscribe2(JSONFilter);                               //subscribe to retrieve defined events\n    IF SUCCEEDED(hr) THEN\n        _Subscribed := TRUE;\n    END_IF\nEND_IF\n</code></pre></p>"},{"location":"SPT_Components/Vision/VisionPlayback.html#i_cyclicfb-i_basefb","title":"I_CyclicFB &amp; I_BaseFB","text":"<pre><code>    //Base FB\n    _Busy    : BOOL := TRUE;\n    _Error   : BOOL;\n    _ErrorID : UDINT;\n\n    //Cyclic FB\n    _InitComplete : BOOL;\n</code></pre>"},{"location":"SPT_Components/Vision/VisionPlayback.html#methods","title":"Methods","text":"Name Return Type Input Description AddImage BOOL ipImageIn : ITcVnImage This method will add images the ring buffer.  If it is processing the images to files then it does not add them WriteImage BOOL BufferImageSaveNameIndex : INTIndex : INT This method will write a single file to the name 'ImageXXX.png'  Where XXX is the Index and the image comes from BufferImageSaveNameIndex loacation in the buffer. It is called in the CyclicLogic up to Parameters_Vision.MAX_NUMBER_IMAGES_2_VIDEO times. CyclicLogic None None This method calls the Execute for the FB_ListenerBase2, Subscribes/Unsubscribes and runs logic for Image to Video"},{"location":"SPT_Components/Vision/VisionPlayback.html#flowchart","title":"Flowchart","text":"<p>This is the flow of the Camera state engine and what happens once an image has been received (VisionTask VisionCamera.CyclicLogic ) <pre><code>flowchart\nb{AcquiringImage State&lt;br&gt;If Image Received}\nc[ProcessImage Method]\nc1{Buffer Enabled}\nb--\"Yes\"--&gt;c\nc--&gt;d[Make Displayable]\nd--&gt;c1--\"Yes\"--&gt;d1\nd1[Add Image to VideoPlayback Buffer]\nc1--\"No\"--&gt;b\nd1--&gt;b</code></pre></p> <p>This is the VideoPlayBack.CyclicLogic (Vision Task VisionCamera.CyclicLogic-&gt;VideoPlayback.CyclicLogic)</p> <pre><code>flowchart\ne{If an alarm}\ne1{If delay Passed}\nf[Trigger Video&lt;br&gt;Disable Image buffer]\ng[Write buffer Images to files]\nh[set bit for C# to make Video]\ni{Video Made}\nj[Enable Image Buffer]\n\ne--\"Yes\"--&gt;e1--\"Yes\"--&gt;f--&gt;g--&gt;h--&gt;i--\"Yes\"--&gt;j--&gt;e</code></pre>"},{"location":"SPT_Components/Vision/VisionPlayback.html#data-tofrom-c-app-st_image2video","title":"Data To/From C# App (ST_Image2Video)","text":"Name Type Description VideoPathSource STRING Location on PLC for the Video to be written ImagePathSource STRING Location on PLC for the images to be found VideoFilename STRING File name for the video source VideoCreate BOOL Create the Video from images in the ImagePathSource VideoCreated BOOL Video is created VideoFPS UINT Video Frames Per Second Heartbeat BOOL Heartbeat between PLC and C# app"},{"location":"SPT_Components/Vision/VisionTask.html","title":"Vision Task","text":"<p>The design is to have a Vision Base object that can have all things needed to setup and run a camera and take a picture.  Then the extended classes would be implement the ProcessImage in order to handle the processing as needed.   From the base class, three types of vision handling are given to use:</p> <ol> <li>Object Detection - Results at a minimum are x,y,a relative to origin of image</li> <li> Measurement - Results are Pass fail or Offset or distance value</li> <li> Inspection - Results are Pass fail</li> <li>  Combo of Tools - Array of method pointers to choose the tools you want to use</li> <li>Video Playback - Images are put together to create a AVI file when a fault occurs</li> </ol> <p>NOTE: You can create an extended FB and handle vision as you need if our 3 components do not fit your solution.</p>"},{"location":"SPT_Components/Vision/VisionTask.html#fb_visionbase","title":"FB_VisionBase","text":"<pre><code>FUNCTION_BLOCK ABSTRACT FB_VisionBase EXTENDS FB_ComponentBase IMPLEMENTS I_VisionBase\n</code></pre>"},{"location":"SPT_Components/Vision/VisionTask.html#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\nclass FB_ComponentBase\nclass FB_VisionBase{\n    &lt;&lt;ABSTRACT&gt;&gt;\n    Camera : FB_VN_SimpleCameraControl\n    ABSRACT ProcessImage()\n    CyclicLogic()\n    Reset()\n    CreateEvents()\n    GetResults()\n    ReadParamDINT()\n    SetParamDINT()\n}   \nFB_ComponentBase&lt;|--FB_VisionBase</code></pre>"},{"location":"SPT_Components/Vision/VisionTask.html#hmi","title":"HMI","text":"<p>The HMI tag will be connected to the Vision Task component since this is where all the status and commands will go directly.  The PLC task will not have HMI tags.</p> Name Type HMI Type Description Trigger BOOL Command If the vision is in Aquisition with mode trigger on and source software, it will trigger camera to take picture StartAquisition BOOL Command This will start the camera state engine for taking pictures and processing StopAquistion BOOL Command This will stop the camera from taking pictures and processing Running BOOL Status Is the Camera state engin running CameraState ETcVnCmaeraState Status This will show the actual state of the camera ElementsFound ULINT Status This is the number of elements found in last image/processing"},{"location":"SPT_Components/Vision/VisionTask.html#processimage-function","title":"ProcessImage Function","text":"<p><pre><code>METHOD PUBLIC ABSTRACT ProcessImage\n</code></pre> This method needs to be overriden in the Extended function block.  </p>"},{"location":"SPT_Components/Vision/VisionTask.html#readparamdint","title":"ReadParamDINT","text":""},{"location":"SPT_Components/Vision/VisionTask.html#setparamdint","title":"SetParamDINT","text":""},{"location":"SPT_Components/Vision/VisionTask.html#alarms","title":"Alarms","text":"<p>The alarms array will be in the PLC Task so that the framework can handle them correclty for the machine.  The Vision Task will have to send Error and ErrorID over the TwinCAT Process Image.</p>"},{"location":"SPT_Components/Vision/VisionTask.html#to-do","title":"To Do","text":"<ol> <li>Switch between real camera and simulation</li> <li>Define a results Structure that fits the given solutions<ol> <li>Position (x,y,a)</li> <li>Pass/fail</li> <li>Measurement<ol> <li>Offset</li> <li>distance</li> <li>roundness</li> </ol> </li> <li>Other result types</li> </ol> </li> <li>HMI user object for this component.  Still use the TcVision HMI items, but a quick user control for layout in SPT HMI</li> </ol>"},{"location":"SPT_Components/Vision/VisionTask.html#overall-diagram","title":"Overall Diagram","text":"<pre><code>classDiagram\n\nclass FB_ComponentBase\n\nclass FB_VisionBase{\n    &lt;&lt;ABSTRACT&gt;&gt;\n    eState : ETcVnCameraState;\n    VisionBaseAlarms : ARRAY[1..x] of FB_TcAlarm\n    ProcessImage()\n    CyclicLogic()\n    Reset()\n    CreateEvents()\n    GetResults()\n}   \n\nclass FB_VisionDetection{\n    ProcessImage()\n    ProcessImage_Blob()\n    ProcessImage_Color()\n    ProcessImage_Contour()\n}\n\nclass FB_VisionMeasurement{\n    ProcessImage()\n}\n\nclass FB_VisionInspection{\n    ProcessImage()\n}\n\nFB_ComponentBase&lt;|--FB_VisionBase\nFB_VisionBase&lt;|--FB_VisionDetection\nFB_VisionBase&lt;|--FB_VisionMeasurement\nFB_VisionBase&lt;|--FB_VisionInspection\n\nclass E_VisionTools{\n    &lt;&lt;Enumeration&gt;&gt;\n    Blob\n    Contour\n    Color\n}\n\nclass I_VisionBase{\n    &lt;&lt;Interface&gt;&gt;\n\n\n\n    ProcessImage()\n    GetResults()\n}</code></pre>"},{"location":"SPT_Components/examples/solenoidbankbase.html","title":"How to use FB_SolenoidBank","text":""},{"location":"SPT_Components/examples/solenoidbankbase.html#overview","title":"Overview","text":"<p>This function block will allow you to use a network and any number of cylinders to write to the memory as needed.  In this sample, we will use a Festo CPX-FB38 64Byte.  This module from Festo can have many kinds of IO modules, but in this sample, it is only solenoids.</p>"},{"location":"SPT_Components/examples/solenoidbankbase.html#function-block","title":"Function Block","text":"<p>The FB_Festo function block extends from the FB_SolenoidBankBase function block.  Then it adds 64 bytes of input data and 64 bytes of output data.</p> <pre><code>FUNCTION_BLOCK FB_Festo EXTENDS FB_SolenoidBankBase\nVAR\n    //Initial array of cylinders\n    Inputs  AT %I*   : ARRAY[0..63] OF USINT;\n    Outputs AT %Q*   : ARRAY[0..63] OF USINT;\nEND_VAR\n</code></pre>"},{"location":"SPT_Components/examples/solenoidbankbase.html#methods","title":"Methods","text":""},{"location":"SPT_Components/examples/solenoidbankbase.html#mapio","title":"MapIO()","text":"<p>The MapIO method will set the extended output and if there is a retracted output, it will set that one too.  It assumes that the retracted output is the IO point after the extended.</p> <pre><code>SetOutput(Configuration[x].SolenoidOutputNumber,Configuration[x].ipSolenoid.ExtendOutput);\nIF Configuration[x].SolenoidType = E_SolenoidType.Double OR Configuration[x].SolenoidType = E_SolenoidType.DoubleFeedback THEN\n    SetOutput(Configuration[x].SolenoidOutputNumber+1,Configuration[x].ipSolenoid.RetractOutput);\nEND_IF\n</code></pre>"},{"location":"SPT_Components/examples/solenoidbankbase.html#setoutput","title":"SetOutput()","text":"<p>This method will take the number and map it into the correct byte and bit of that byte.  It is called from the <code>MapIO</code> method multiple times.</p> <pre><code>METHOD SetOutput\nVAR_INPUT\n    Output : UINT;\n    Value  : BOOL;\nEND_VAR\n\nVAR\n    myByte    : WORD;\n    myBit     : WORD;\n    myBitMask : USINT;\n    pOutput   : POINTER TO USINT;\nEND_VAR\n</code></pre> <pre><code>// Find the Byte and the Bit of that Byte\nmyByte := Output / 8;\nmyBit  := Output MOD 8;\n\n//Create the mask for to use for turning on/off\nmyBitMask := TO_USINT(EXPT(2, myBit));\n\n//Set the pointer to the byte\npOutput := ADR(Outputs[myByte]);\n\n// Turn on or off as needed the bit of the byte\nIF Value THEN\n    pOutput^ := pOutput^ OR myBitMask;\nELSE\n    pOutput^ := pOutput^ AND (NOT myBitMask);\nEND_IF\n</code></pre>"},{"location":"SPT_Components/examples/solenoidbankbase.html#main-pou","title":"MAIN POU","text":"<p>The main program has all the cylinder variables and the FestoBank.</p> <pre><code>PROGRAM MAIN\nVAR\n    SimpleCylinder  : FB_SingleSolenoid         := (Name := 'Simple Cylinder');\n    SimpleCylinder2 : FB_SingleSolenoid         := (Name := 'Simple Cylinder2');\n    SimpleCylinder3 : FB_SingleSolenoid         := (Name := 'Simple Cylinder3');\n    SimpleCylinder4 : FB_SingleSolenoid         := (Name := 'Simple Cylinder4');\n    SimpleCylinder5 : FB_SingleSolenoid         := (Name := 'Simple Cylinder5');\n    SimpleCylinder6 : FB_SingleSolenoid         := (Name := 'Simple Cylinder6');\n    SimpleCylinder7 : FB_SingleSolenoid         := (Name := 'Simple Cylinder7');\n    SimpleCylinder8 : FB_SingleSolenoid         := (Name := 'Simple Cylinder8');\n    DoubleSolenoid  : FB_DoubleSolenoid         := (Name := 'Dobule Solendoid Cylinder');\n    SingleFeedback  : FB_SingleSolenoidFeedback := (Name := 'Single with Feedback');\n    DoubleFeedback  : FB_DoubleSolenoidFeedback := (Name := 'Double with Feedback');\n\n    //Bank\n    FestoBank : FB_Festo;\n\n    //Init\n    Init : BOOL;\nEND_VAR\n</code></pre>"},{"location":"SPT_Components/examples/solenoidbankbase.html#initialize","title":"Initialize","text":"<p>Here is the cylinder HMI control being allowed and adding the solenoids to the bank.  In the AddSolenoid method, it takes the interface to a cylinder function block, the bit number of the Output and the type of solenoid.  The bit number in this example must be between 0-511 since it is 64 bytes of data.  If the solenoid type is of Double then the retract output is assumed to be right after the extend output.  The AllowHMIControl just give the visualization the ability to extend and retract the cylinders.</p> <p><pre><code>IF NOT Init THEN\n    FestoBank.AddSolenoid(ipCylinder := SimpleCylinder, Number := 0, SolenoidType := E_SolenoidType.Single);\n    FestoBank.AddSolenoid(ipCylinder := SimpleCylinder2, Number := 1, SolenoidType := E_SolenoidType.Single);\n    FestoBank.AddSolenoid(ipCylinder := SimpleCylinder3, Number := 2, SolenoidType := E_SolenoidType.Single);\n    FestoBank.AddSolenoid(ipCylinder := SimpleCylinder4, Number := 3, SolenoidType := E_SolenoidType.Single);\n    FestoBank.AddSolenoid(ipCylinder := SimpleCylinder5, Number := 4, SolenoidType := E_SolenoidType.Single);\n    FestoBank.AddSolenoid(ipCylinder := SimpleCylinder6, Number := 5, SolenoidType := E_SolenoidType.Single);\n    FestoBank.AddSolenoid(ipCylinder := SimpleCylinder7, Number := 6, SolenoidType := E_SolenoidType.Single);\n    FestoBank.AddSolenoid(ipCylinder := SimpleCylinder8, Number := 7, SolenoidType := E_SolenoidType.Single);\n    FestoBank.AddSolenoid(ipCylinder := DoubleSolenoid, Number := 8, SolenoidType := E_SolenoidType.Double);\n    FestoBank.AddSolenoid(ipCylinder := SingleFeedback, Number := 16, SolenoidType := E_SolenoidType.SingleFeedback);\n    FestoBank.AddSolenoid(ipCylinder := DoubleFeedback, Number := 24, SolenoidType := E_SolenoidType.DoubleFeedback);\n    SimpleCylinder.AllowHMIControl();\n    SimpleCylinder2.AllowHMIControl();\n    SimpleCylinder3.AllowHMIControl();\n    SimpleCylinder4.AllowHMIControl();\n    SimpleCylinder5.AllowHMIControl();\n    SimpleCylinder6.AllowHMIControl();\n    SimpleCylinder7.AllowHMIControl();\n    SimpleCylinder8.AllowHMIControl();\n    DoubleSolenoid.AllowHMIControl();\n    SingleFeedback.AllowHMIControl();\n    DoubleFeedback.AllowHMIControl();\n    Init := TRUE;\nEND_IF\n</code></pre> This is where the cyclicLogic is being called to do the work for the cylinder and the bank of cylinders.  If this was using the full PackML code, these would be in a component array in either the machine module or an equipment module.  </p> <pre><code>SimpleCylinder.CyclicLogic();\nSimpleCylinder2.CyclicLogic();\nSimpleCylinder3.CyclicLogic();\nSimpleCylinder4.CyclicLogic();\nSimpleCylinder5.CyclicLogic();\nSimpleCylinder6.CyclicLogic();\nSimpleCylinder7.CyclicLogic();\nSimpleCylinder8.CyclicLogic();\nDoubleSolenoid.CyclicLogic();\nSingleFeedback.CyclicLogic();\nDoubleFeedback.CyclicLogic();\nFestoBank.CyclicLogic();\n</code></pre>"},{"location":"SPT_Components/examples/solenoidbankbase.html#ethercat-setup","title":"EtherCAT Setup","text":"<p>In this setup, there is one box that is a CPX-FB38 module. </p> <p>It has the following Process Data. 64 bytes Input and 64 bytes Output </p> <p>Input Mapping (IB0-IB63) </p> <p>Output Mapping (QB0-QB63) </p>"},{"location":"SPT_Components/examples/solenoidbankbase.html#notes","title":"Notes","text":"<p>This example was only tested in simulation and the memory checked to see it function.  Once it is tested with real hardware, there may be some slight modifications needed. </p>"},{"location":"SPT_Diagnostic/index.html","title":"Overview","text":"<p>This collection of Function Blocks targets the evaluation of the TwinCat Systems which provide extended Diagnostic information. </p> <p>With the provided information the user can react in a coordinated manner to system anomalies and failure.</p> <p>See the specific FBs for detailed description and usage. </p> <p></p> <p>Warning</p> <p>Code in this Framework is provided under the MIT-license agreement.</p> <p>Furthermore Software sections with designator <code>Safety</code> do not provide any recommendation to setup Safety related functions in your PLC/Safety PLC application.</p> <p>All Diagnostic Function Blocks are for diagnostic purposes only!</p> <p>For Safety related programming guidance please see TwinSAFE Application Guide</p> <p>THE SAMPLE CODE CONTAINED IN THIS PUBLICATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY  OF ANY KIND, EITHER EXPRESSED, IMPLIED OR STATUTORY, INCLUDING WITHOUT LIMITATION,  ANY WARRANTY WITH RESPECT TO NON-INFRINGEMENT, FREEDOM FROM PROPRIETARY RIGHTS  OF THIRD PARTIES OR FITNESS FOR ANY PARTICULAR PURPOSE.</p>"},{"location":"SPT_Diagnostic/changelog.html","title":"SPT Diagnostic","text":""},{"location":"SPT_Diagnostic/changelog.html#changelog","title":"Changelog","text":""},{"location":"SPT_Diagnostic/changelog.html#40-2025-05-20","title":"[4.0] - 2025-05-20","text":""},{"location":"SPT_Diagnostic/changelog.html#compiled","title":"Compiled","text":"<ul> <li>Using TwinCAT 3.1.4026</li> </ul>"},{"location":"SPT_Diagnostic/changelog.html#39-2025-04-14","title":"[3.9] - 2025-04-14","text":""},{"location":"SPT_Diagnostic/changelog.html#finalizing","title":"Finalizing","text":"<ul> <li>Internal updates and cleanup</li> </ul>"},{"location":"SPT_Diagnostic/changelog.html#339-2025-04-11","title":"[3.3.9] - 2025-04-11","text":""},{"location":"SPT_Diagnostic/changelog.html#sync","title":"Sync","text":"<ul> <li>Implement same version number across all SPT libraries</li> </ul>"},{"location":"SPT_Diagnostic/changelog.html#added","title":"Added","text":"<ul> <li>Code formatting and comments</li> </ul>"},{"location":"SPT_Diagnostic/changelog.html#338-2024-20-08","title":"[3.3.8] - 2024-20-08","text":""},{"location":"SPT_Diagnostic/changelog.html#added_1","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_Diagnostic/changelog.html#spt-ethercat","title":"SPT EtherCat","text":""},{"location":"SPT_Diagnostic/changelog.html#changelog_1","title":"Changelog","text":""},{"location":"SPT_Diagnostic/changelog.html#330-2024-05-07","title":"[3.3.0] - 2024-05-07","text":""},{"location":"SPT_Diagnostic/changelog.html#added_2","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_Diagnostic/duts.html","title":"DUTs","text":""},{"location":"SPT_Diagnostic/duts.html#spt-diagnostic","title":"SPT Diagnostic","text":""},{"location":"SPT_Diagnostic/duts.html#st_safetystatediag","title":"ST_SafetyStateDiag","text":"<pre><code>{attribute 'pack_mode' := '1'}\nTYPE ST_SafetyStateDiag :\n    STRUCT\n        State : USINT;\n        Diag  : UINT; // **NOT PRESENT ON AND/OR FBs ** For components with USINT as Diag connection, connect first 8 Bit of UINT Diag. Inherited FB is evaluating correct length.\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Diagnostic/duts.html#e_componentsafetyconnection_state","title":"E_ComponentSafetyConnection_State","text":"<pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_ComponentSafetyConnection_State : (\n        Reset      := 100,\n        Session    := 101,\n        Connection := 102,\n        Parameter  := 103,\n        Data       := 104,\n        Shutdown   := 105,\n        Deactive   := 106\n    ) USINT;\nEND_TYPE\n</code></pre>"},{"location":"SPT_Diagnostic/duts.html#e_componentsafetyedm_state","title":"E_ComponentSafetyEdm_State","text":"<pre><code>{attribute 'qualified_only'}\nTYPE E_ComponentSafetyEdm_State : (\n        Invalid := 0,\n        Stop    := 2,\n        Error   := 4,\n        Reset   := 5,\n        MonOff  := 14,\n        MonOn   := 15\n    ) USINT;\nEND_TYPE\n</code></pre>"},{"location":"SPT_Diagnostic/duts.html#e_componentsafetyestop_state","title":"E_ComponentSafetyEStop_State","text":"<pre><code>{attribute 'qualified_only'}\nTYPE E_ComponentSafetyEStop_State : (\n        Invalid  := 0,\n        Run      := 1,\n        Stop     := 2,\n        Safe     := 3,\n        Error    := 4,\n        Reset    := 5,\n        Start    := 6,\n        DelayOut := 7\n    ) USINT;\nEND_TYPE\n</code></pre>"},{"location":"SPT_Diagnostic/duts.html#e_componentsafetygroup_diag","title":"E_ComponentSafetyGroup_Diag","text":"<pre><code>{attribute 'qualified_only'}\nTYPE E_ComponentSafetyGroup_Diag : (\n        NoError       := 0,\n        FbError       := 1,\n        ComError      := 2,\n        ModuleError   := 3,\n        CmpError      := 4,\n        DeactiveError := 5,\n        RestartError  := 6\n    ) UINT;\nEND_TYPE\n</code></pre>"},{"location":"SPT_Diagnostic/duts.html#e_componentsafetygroup_state","title":"E_ComponentSafetyGroup_State","text":"<pre><code>{attribute 'qualified_only'}\nTYPE E_ComponentSafetyGroup_State : (\n        Invalid      := 0,\n        Run          := 1,\n        Stop         := 2,\n        Error        := 4,\n        Reset        := 5,\n        Start        := 6,\n        StopError    := 7,\n        Deactive     := 16,\n        WaitComError := 17\n    ) USINT;\nEND_TYPE\n</code></pre>"},{"location":"SPT_Diagnostic/duts.html#e_componentsafetymon_state","title":"E_ComponentSafetyMon_State","text":"<pre><code>{attribute 'qualified_only'}\nTYPE E_ComponentSafetyMon_State : (\n        Invalid    := 0,\n        Run        := 1,\n        Stop       := 2,\n        Safe       := 3,\n        Error      := 4,\n        Reset      := 5,\n        Start      := 6,\n        ErrorDelay := 7,\n        DelayOut   := 8,\n        FuncTest   := 9\n    ) USINT;\nEND_TYPE\n</code></pre>"},{"location":"SPT_Diagnostic/duts.html#e_componentsafetyorand_state","title":"E_ComponentSafetyOrAnd_State","text":"<pre><code>{attribute 'qualified_only'}\nTYPE E_ComponentSafetyOrAnd_State : (\n        Invalid := 0,\n        Run     := 1,\n        Stop    := 2,\n        Safe    := 3\n    ) USINT;\nEND_TYPE\n</code></pre>"},{"location":"SPT_Diagnostic/duts.html#spt-ethercat","title":"SPT EtherCat","text":""},{"location":"SPT_Diagnostic/duts.html#st_ethercatmasterinfo","title":"ST_EtherCatMasterInfo","text":"<pre><code>TYPE ST_EtherCatMasterInfo :\n    STRUCT\n        AmsNetID      AT %I* : AMSNETID;\n        DevID         AT %I* : UINT;\n        DevState      AT %I* : UINT;\n        ChangeCount   AT %I* : UINT;\n        SlaveCount    AT %I* : UINT;\n        CfgSlaveCount AT %I* : UINT;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Diagnostic/duts.html#st_ethercatsyncunittaskinfo","title":"ST_EtherCatSyncUnitTaskInfo","text":"<pre><code>TYPE ST_EtherCatSyncUnitTaskInfo :\n    STRUCT\n        WcState    AT %I* : BIT;\n        ObjectId   AT %I* : OTCID;\n        State      AT %I* : UINT;\n        SlaveCount AT %I* : UINT;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Diagnostic/duts.html#st_ethercatmaster_hmi","title":"ST_EtherCatMaster_HMI","text":"<pre><code>TYPE ST_EtherCatMaster_HMI :\n    STRUCT\n        Config  : ST_EtherCatMaster_Config;\n        Command : ST_EtherCatMaster_Command;\n        Status  : ST_EtherCatMaster_Status;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Diagnostic/duts.html#st_ethercatmaster_status","title":"ST_EtherCatMaster_Status","text":"<pre><code>TYPE ST_EtherCatMaster_Status :\n    STRUCT\n        AmsNetID            : T_AMSNETID;\n        CfgSlaveCount       : UINT;\n        EcSlavesState       : ARRAY[0..EC_MAX_SLAVES] OF ST_EcSlaveState;\n        ConfiguredSlaveInfo : ARRAY[0..EC_MAX_SLAVES] OF ST_EcSlaveConfigData;\n        EcSlaveTopologyInfo : ARRAY[0..EC_MAX_SLAVES] OF ST_TopologyDataEx;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Diagnostic/functionblocks.html","title":"Function Blocks","text":""},{"location":"SPT_Diagnostic/functionblocks.html#spt-diagnostic","title":"SPT Diagnostic","text":""},{"location":"SPT_Diagnostic/functionblocks.html#fb_component_safety_base","title":"FB_Component_Safety_Base","text":"<p>(extends <code>FB_ComponentBase</code>, implements <code>I_SafetyBase</code>, <code>I_SafetySimulation</code>)</p> <p>This FB provides the Basis for each Safety Diagnostic function block thereafter.  Each Safety Diagnosis FB is a Component within the Framework and can be registered in EMs or Machine Modules.</p> <p>By assigning <code>SafetyReset</code> the auxiliary function is triggered by executing the Method <code>.Reset()</code>.</p> Quickstart <ol> <li> <p>Create instances for Safety Diagnostic FB on appropriate level, EM or Machine.      <pre><code>SafetyGroupAutoReset    : FB_SafetyResetPulse;\nSafetyReset             : FB_SafetyResetPulse;\nSafetyGroup_Main        : FB_Component_Safety_Group       := (Name := 'Safety Group Main', SafetyReset := SafetyGroupAutoReset, AutoResetConnectionFaults := TRUE);\nSafetyEstop             : FB_Component_Safety_EstopFB     := (Name := 'E-Stop', DependenceFB := SafetyGroup_Main, SafetyReset := SafetyReset);\n</code></pre></p> </li> <li> <p>Link <code>Run</code>/<code>ErrorAcknowledgement</code> for Safety Groups.</p> <p></p> </li> <li> <p>Link <code>State</code>/<code>Diag</code>.</p> <p></p> <p></p> <p>The process image to link to will be shown under the selected Safety PLC Device (EL6910, EL2911,...) in the EtherCat Master.</p> </li> </ol>"},{"location":"SPT_Diagnostic/functionblocks.html#fb_component_safety_group","title":"FB_Component_Safety_Group","text":"<p>(extends <code>FB_Component_Safety_Base</code>)</p> <p>Evaluate Safety Group status and provide <code>Run</code> bit required for each Safety Group.</p> <p>This FB requires a <code>SafetyReset</code> assignment during initialization. </p> <p>When property <code>AutoResetConnectionFaults</code> is set, the FB will trigger reset function continuously in case of error state. </p>"},{"location":"SPT_Diagnostic/functionblocks.html#fb_component_safety_andorfb","title":"FB_Component_Safety_AndOrFB","text":"<p>(extends <code>FB_Component_Safety_Base</code>)</p>"},{"location":"SPT_Diagnostic/functionblocks.html#fb_component_safety_connectionfb","title":"FB_Component_Safety_ConnectionFB","text":"<p>(extends <code>FB_Component_Safety_Base</code>)</p>"},{"location":"SPT_Diagnostic/functionblocks.html#fb_component_safety_edmfb","title":"FB_Component_Safety_EdmFB","text":"<p>(extends <code>FB_Component_Safety_Base</code>)</p>"},{"location":"SPT_Diagnostic/functionblocks.html#fb_component_safety_estopfb","title":"FB_Component_Safety_EstopFB","text":"<p>(extends <code>FB_Component_Safety_Base</code>)</p> <p>Property <code>ActiveName</code> can be used to change Alarm message from default <code>pressed!</code>.</p>"},{"location":"SPT_Diagnostic/functionblocks.html#fb_component_safety_monfb","title":"FB_Component_Safety_MonFB","text":"<p>(extends <code>FB_Component_Safety_Base</code>)</p> <p>Property <code>ActiveName</code> can be used to change Alarm message from default <code>pressed!</code>.</p> <p>Property <code>ActiveAlarm</code> can be used to suppress the Alarm for Safety FB not OK.</p>"},{"location":"SPT_Diagnostic/functionblocks.html#fb_component_devices","title":"FB_Component_Devices","text":"<p>(extends <code>FB_ComponentBase</code>, implements <code>I_Diagnostic</code>)</p> <p>Reads all Devices available in runtime and assigns correct evaluating FB.</p> <p>Each set amount of time the Diagnostic information is evaluated from e.g. EtherCat Masters.</p> <p>This FB is required to be parameterized by the following Parameter <code>Parameter_Diagnostic</code>:</p> Parameter Function UPDATE_TIME Start Diagnostic Run every xxx ms, T#0s = deactivated, update needs to manually occur via I_Diagnostic.Update() DEVICES_MAX Max Devices in this System ETHERCAT_MASTER_START_UP_TIME Time to Startup EtherCat Master Diagnostic at initial startup ETHERCAT_MASTER_MAX Max EtherCat Masters ETHERCAT_MASTER_SLAVE_MAX Max Slaves per EtherCat Master ETHERCAT_MASTER_SYNC_UNIT_MAX Max Count of Sync Units per Master ETHERCAT_MASTER_SYNC_UNIT_SLAVE_MAX Max Count of Slaves per Sync Unit"},{"location":"SPT_Diagnostic/functionblocks.html#spt-ethercat","title":"SPT EtherCat","text":""},{"location":"SPT_Diagnostic/functionblocks.html#fb_component_ethercatmaster","title":"FB_Component_EtherCatMaster","text":"<p>(extends <code>FB_ComponentBase</code>, implements <code>I_EtherCatMaster</code>)</p> <p>Function Block to diagnose connected EtherCat Master. The FB will read the Master configuration, evaluate the states of each slave and the master itself. In case of an anomaly or fault it will be displayed as an Event. </p> <p>Connection to the SPT Framework implementation is done via standard component handling <code>ParentResponseDefinition</code> and <code>CurrentAlarmSeverity</code>.</p> Quickstart <ol> <li> <p>Create instance of <code>FB_Component_EtherCatMaster</code> for each Master. E.g. EBus and X001.     <pre><code>    // EtherCat Diagnostics\n    {attribute 'TcLinkTo' := '.EtherCatMaster.AmsNetID     := TIID^X001^InfoData^AmsNetId;\n                            .EtherCatMaster.DevID        := TIID^X001^InfoData^DevId;\n                            .EtherCatMaster.DevState     := TIID^X001^Inputs^DevState;\n                            .EtherCatMaster.ChangeCount  := TIID^X001^InfoData^ChangeCount;\n                            .EtherCatMaster.SlaveCount   := TIID^X001^Inputs^SlaveCount;\n                            .EtherCatMaster.CfgSlaveCount:= TIID^X001^InfoData^CfgSlaveCount;\n                            .FrmXWcState[0]              := TIID^X001^Inputs^Frm0WcState;\n                            .FrmXWcState[1]              := TIID^X001^Inputs^Frm1WcState;\n                            .FrmXWcState[2]              := TIID^X001^Inputs^Frm2WcState;\n                            .FrmXWcState[3]              := TIID^X001^Inputs^Frm3WcState;\n                            .FrmXWcState[4]              := TIID^X001^Inputs^Frm4WcState;\n                            .FrmXWcState[5]              := TIID^X001^Inputs^Frm5WcState;\n                            .FrmXWcState[6]              := TIID^X001^Inputs^Frm6WcState;\n                            .FrmXWcState[7]              := TIID^X001^Inputs^Frm7WcState;\n                            .FrmXWcState[8]              := TIID^X001^Inputs^Frm8WcState;\n                            .FrmXWcState[9]              := TIID^X001^Inputs^Frm9WcState'}\n    EtherCatMasterX001 : FB_Component_EtherCatMaster := (Name := 'X001');\n</code></pre></p> </li> <li> <p>Link FB to the Master by replacing the automatic link attribute with the correct Master Name. </p> <p></p> </li> <li> <p>Create an instance of <code>FB_SyncUnitTask</code> for each SyncUnit. </p> <p></p> <p>If SyncUnit is servicing multiple Tasks, an instance is required for each sub section. </p> <pre><code>    {attribute 'TcLinkTo' := '.SyncUnitTaskInfo.WcState    := TIID^X000^SyncUnits^IO^PlcTask^WcState^WcState;\n                            .SyncUnitTaskInfo.ObjectId   := TIID^X000^SyncUnits^IO^PlcTask^InfoData^ObjectId;\n                            .SyncUnitTaskInfo.State      := TIID^X000^SyncUnits^IO^PlcTask^InfoData^State;\n                            .SyncUnitTaskInfo.SlaveCount := TIID^X000^SyncUnits^IO^PlcTask^InfoData^SlaveCount'}\n    SyncUnitStandardSlowTask : FB_SyncUnitTask(EtherCatMaster := EtherCatMasterX001);\n    {attribute 'TcLinkTo' := '.SyncUnitTaskInfo.WcState    := TIID^X000^SyncUnits^HotConnect [Term 20 (EK1100)]^PlcTask^WcState^WcState;\n                            .SyncUnitTaskInfo.ObjectId   := TIID^X000^SyncUnits^HotConnect [Term 20 (EK1100)]^PlcTask^InfoData^ObjectId;\n                            .SyncUnitTaskInfo.State      := TIID^X000^SyncUnits^HotConnect [Term 20 (EK1100)]^PlcTask^InfoData^State;\n                            .SyncUnitTaskInfo.SlaveCount := TIID^X000^SyncUnits^HotConnect [Term 20 (EK1100)]^PlcTask^InfoData^SlaveCount'}\n    SyncUnitHotConnect : FB_SyncUnitTask(EtherCatMaster := EtherCatMasterX001) := (IsHotConnect := TRUE);\n</code></pre> </li> </ol>"},{"location":"SPT_Diagnostic/functionblocks.html#fb_syncunittask","title":"FB_SyncUnitTask","text":"<p>(extends <code>FB_CyclicFB</code>, implements <code>I_SyncUnitTask</code>)</p> <p>This FB evaluates the SyncUnit assigned by the linked inputs. In case of the SyncUnit not providing valid input Data an event will be displayed with the affected Slaves.</p> <p>The default event is displayed as Error. With parameter <code>IsHotConnect</code> the event will be a warning as disconnection is expected.</p> <p>This FB can only be used along with <code>FB_Component_EtherCatMaster</code> which instance is passed into <code>FB_SyncUnitTask</code> via the constructor. </p>"},{"location":"SPT_Diagnostic/interfaces.html","title":"Interfaces","text":""},{"location":"SPT_Diagnostic/interfaces.html#spt-diagnostic","title":"SPT Diagnostic","text":""},{"location":"SPT_Diagnostic/interfaces.html#i_safetybase","title":"I_SafetyBase","text":""},{"location":"SPT_Diagnostic/interfaces.html#properties","title":"Properties","text":"Property Type Access Description OK BOOL GET Indicator for Safety Function Block OK, see specific FB for interpretation. SafetyReset I_SafetyReset SET Interface Pointer to Reset Function. DependenceFB I_BaseFB GET/SET FB which is one level up, Error messages of this FBs are blocked if upper level is errored."},{"location":"SPT_Diagnostic/interfaces.html#i_safetyreset","title":"I_SafetyReset","text":"<p>(extends <code>I_CyclicFB</code>)</p>"},{"location":"SPT_Diagnostic/interfaces.html#properties_1","title":"Properties","text":"Property Type Access Description PulseDuration TIME SET Pulse duration high of Reset-Bit."},{"location":"SPT_Diagnostic/interfaces.html#methods","title":"Methods","text":"Method Return Type Description Execute BOOL Execute Reset on this FB."},{"location":"SPT_Diagnostic/interfaces.html#i_safetysimulation","title":"I_SafetySimulation","text":"<p>(extends <code>I_SafetyBase</code>)</p>"},{"location":"SPT_Diagnostic/interfaces.html#methods_1","title":"Methods","text":"Method Return Type Description SimulateSafetyDiag none Simulate of Diag Variable. SimulateSafetyState none Simulate of State Variable."},{"location":"SPT_Diagnostic/interfaces.html#i_diagnostic","title":"I_Diagnostic","text":""},{"location":"SPT_Diagnostic/interfaces.html#methods_2","title":"Methods","text":"Method Return Type Description Update none Update Diagnostic information."},{"location":"SPT_Diagnostic/interfaces.html#spt-ethercat","title":"SPT EtherCat","text":""},{"location":"SPT_Diagnostic/interfaces.html#i_ethercatmaster","title":"I_EtherCatMaster","text":"<p>(extends <code>I_ComponentBase</code>)</p> <p>Interface for basic EtherCat Master information.</p>"},{"location":"SPT_Diagnostic/interfaces.html#properties_2","title":"Properties","text":"Property Type Access Description AmsNetIdEcMaster T_AMSNETID GET Master AmsNet-Id ConfiguredSlaveCount UINT GET Count of Slaves on this Master ConfiguredSlaveInfo Reference to ARRAY[0..EC_MAX_SLAVES] OF ST_EcSlaveConfigData GET Slave information read from Master"},{"location":"SPT_Diagnostic/interfaces.html#methods_3","title":"Methods","text":"Method Return Type Description RegisterSyncUnit BOOL Used in SyncUnit FB to register SyncUnit Diagnostic to Master - not for customer use."},{"location":"SPT_Diagnostic/interfaces.html#i_syncunittask","title":"I_SyncUnitTask","text":"<p>(extends <code>I_CyclicFB</code>)</p>"},{"location":"SPT_Diagnostic/interfaces.html#properties_3","title":"Properties","text":"Property Type Access Description IsHotConnect BOOL GET/SET Defines this SyncUnit as Hot Connect Group. Error messages for \"offline\" will be displayed as warning. NumberOfSlaves UINT GET Number of Slaves assigned to this sync unit SyncUnitName STRING(63) GET Assigned Name of this Sync Unit."},{"location":"SPT_Event_Logger/index.html","title":"Overview","text":"<p>Contain helper functions for interacting with the Tc3_EventLogger library.</p>"},{"location":"SPT_Event_Logger/changelog.html","title":"Changelog","text":""},{"location":"SPT_Event_Logger/changelog.html#unreleased","title":"[Unreleased]","text":""},{"location":"SPT_Event_Logger/changelog.html#40-2025-05-20","title":"[4.0] - 2025-05-20","text":""},{"location":"SPT_Event_Logger/changelog.html#added","title":"Added","text":"<ul> <li>Events Function Block</li> </ul>"},{"location":"SPT_Event_Logger/changelog.html#compiled","title":"Compiled","text":"<ul> <li>Using TwinCAT 3.1.4026</li> </ul>"},{"location":"SPT_Event_Logger/changelog.html#39-2025-04-14","title":"[3.9] - 2025-04-14","text":""},{"location":"SPT_Event_Logger/changelog.html#finalizing","title":"Finalizing","text":"<ul> <li>Internal updates and cleanup</li> </ul>"},{"location":"SPT_Event_Logger/changelog.html#33-2025-04-11","title":"[3.3] - 2025-04-11","text":""},{"location":"SPT_Event_Logger/changelog.html#sync","title":"Sync","text":"<ul> <li>Implement same version number across all SPT libraries</li> </ul>"},{"location":"SPT_Event_Logger/changelog.html#added_1","title":"Added","text":"<ul> <li>Code formatting and comments</li> </ul>"},{"location":"SPT_Event_Logger/changelog.html#320-2023-06-02","title":"[3.2.0] - 2023-06-02","text":""},{"location":"SPT_Event_Logger/changelog.html#added_2","title":"Added","text":"<ul> <li>Added license file to project (MIT License)</li> </ul>"},{"location":"SPT_Event_Logger/changelog.html#310-2023-05-08","title":"[3.1.0] - 2023-05-08","text":""},{"location":"SPT_Event_Logger/changelog.html#changed","title":"Changed","text":"<ul> <li>Removed all references to Tc3_System library</li> </ul>"},{"location":"SPT_Event_Logger/changelog.html#300-2022-10-05","title":"[3.0.0] - 2022-10-05","text":""},{"location":"SPT_Event_Logger/changelog.html#added_3","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_Event_Logger/functions.html","title":"Functions","text":""},{"location":"SPT_Event_Logger/functions.html#f_clearalleventsinclass","title":"F_ClearAllEventsInClass","text":"<pre><code>FUNCTION F_ClearAllEventsInClass\nVAR_IN_OUT\n    Alarms : ARRAY[*] OF FB_TcAlarm; //! Array of Alarms to be defined\nEND_VAR\n</code></pre> <p>Clears any events within <code>Alarms</code> that may have been raised.</p>"},{"location":"SPT_Event_Logger/functions.html#f_createalleventsinclass","title":"F_CreateAllEventsInClass","text":"<p><pre><code>FUNCTION F_CreateAllEventsInClass\nVAR_IN_OUT\n    Alarms : ARRAY[*] OF FB_TcAlarm; //! Array of Alarms to be defined\nEND_VAR\n\nVAR_INPUT\n    ClassSize  : UDINT;                   //! Size in bytes of the event class\n    pInitEvent : POINTER TO TcEventEntry; //! Address of first event in Event Class (Should be the InitReferenceEvent)\n    Prefix     : STRING;                  //! String Prefix for the Event Message -- Usually the Module ID and Name\nEND_VAR\n</code></pre> Initializes all instances of <code>FB_TcAlarm</code> within <code>Alarms</code>.</p>"},{"location":"SPT_Event_Logger/functions.html#f_getmaxseverityraised","title":"F_GetMaxSeverityRaised","text":"<pre><code>FUNCTION F_GetMaxSeverityRaised : TcEventSeverity //! Maximum severity\nVAR_IN_OUT\n    Alarms : ARRAY[*] OF FB_TcAlarm; //! Events to compare against\nEND_VAR\n\nVAR_INPUT\n    CurrentSeverity : TcEventSeverity; //! Current severity of module alarm\nEND_VAR\n</code></pre> <p>Returns the highest severity level of any events currently raised within <code>Alarms</code>.</p>"},{"location":"SPT_Event_Logger/functions.html#f_raisealarm","title":"F_RaiseAlarm","text":"<pre><code>FUNCTION F_RaiseAlarm\nVAR_IN_OUT\n    Alarm : FB_TcAlarm; //! Alarm to be raised\nEND_VAR\n</code></pre> <p>Raises event associated with <code>Alarm</code>.</p>"},{"location":"SPT_Event_Logger/functions.html#f_raisealarmandsetflags","title":"F_RaiseAlarmAndSetFlags","text":"<pre><code>FUNCTION F_RaiseAlarmAndSetFlags\nVAR_IN_OUT\n    Alarm     : FB_TcAlarm; //! Alarm to be raised\n    ErrorFlag : BOOL;       //! Error flag to set (VAR_IN_OUT, put the variable you want the function to SET here)\n    ErrorID   : UDINT;      //! Error ID to set (VAR_IN_OUT, put the variable you want the function to SET here) - Will be set using the ID of the given fbAlarm\nEND_VAR\n</code></pre> <p>Raises event associated with <code>Alarm</code>, sets <code>ErrorFlag</code> to <code>TRUE</code>, and copies the eventID associated with <code>Alarm</code> into <code>ErrorID</code>. </p>"},{"location":"SPT_Event_Logger/functions.html#f_raisealarmwithstringparameters","title":"F_RaiseAlarmWithStringParameters","text":"<pre><code>FUNCTION F_RaiseAlarmWithStringParameters\nVAR_IN_OUT\n    Alarm : FB_TcAlarm; //! Alarm to be raised\nEND_VAR\n\nVAR_INPUT\n    String_1 : STRING; //! First string parameter\n    String_2 : STRING; //! Second string parameter\n    String_3 : STRING; //! Third string parameter\nEND_VAR\n</code></pre> <p>Raises event associated with <code>Alarm</code> and passes <code>String_n</code> as arguments for contextual information. </p>"},{"location":"SPT_Event_Logger/functions.html#f_raisealarmwithstringsandflags","title":"F_RaiseAlarmWithStringsAndFlags","text":"<pre><code>FUNCTION F_RaiseAlarmWithStringsAndFlags\nVAR_IN_OUT\n    Alarm     : FB_TcAlarm; //! Alarm to be raised\n    ErrorFlag : BOOL;       //! Error flag to set (VAR_IN_OUT, put the variable you want the function to SET here)\n    ErrorID   : UDINT;      //! Error ID to set (VAR_IN_OUT, put the variable you want the function to SET here) - Will be set using the ID of the given fbAlarm\nEND_VAR\n\nVAR_INPUT\n    String_1 : STRING; //! First string parameter\n    String_2 : STRING; //! Second string parameter\n    String_3 : STRING; //! Third string parameter\nEND_VAR\n</code></pre> <p>Raises event associated with <code>Alarm</code>, sets <code>ErrorFlag</code> to <code>TRUE</code>, and copies the eventID associated with <code>Alarm</code> into <code>ErrorID</code>.  <code>String_n</code> are passed as arguments for contextual information. </p>"},{"location":"SPT_Kinematic/index.html","title":"Overview","text":"<p>Integration of Beckhoff Kinematic Transformation TF511x into SPT-Framework.</p> <p>Implementation of kinematic possible from DOF=2 to DOF=6.</p> <p>The Kinematic implementation consists of 3 Parts:</p> <p>Kinematic Group - Connects ACS (Physical drives, J1,J2,..) through the Kinematic transformation Objects to the MCS (virtual drives X,Y,Z,...)</p> <p>Component Kinematic Base - The Kinematic base component contains the framework implementation in addition to basic functions of the kinematic. Here is also where the connected Kinematic is defined e.g. Delta or Scara.</p> <p>Kinematic Motion Amp - Amp (Advanced Motion Package) Implements extended  motion functions for the selected kinematic - uses the Beckhoff Amp for XYZ+(A or B or C) coordinated movements. </p> Warning <p>This Object is limited to DOF=4. For DOF&gt;4 Object Camming has to be used.</p> Info <p>DOF = Degrees of Freedom</p> <p>AMP = Advanced Motion Package</p> <p>CM  = Coordinated Motion</p> <p>ACS = Axis Coordinate System (Joint 1, Joint 2,..)</p> <p>MCS = Machine Coordinate System (X,Y,Z,Rotation Axis 1,..)</p> <p>Kinematic Motion Camming - The introduction of Camming <code>TF5050 - Tc2_MC2_Camming</code> enables the Coordinated motion of all ACS Joint axes and the coordinated Motion of MCS for DOF&gt;=5 incl. 6-Axis-Kinematics. </p>"},{"location":"SPT_Kinematic/index.html#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\n    FB_KinematicCamming &lt;|.. I_KinematicCamming\n    FB_ComponentKinematicMotionCamming &lt;|.. I_KinematicCamming\n    FB_ComponentKinematicMotionCamming *-- FB_KinematicCamming\n    FB_ComponentKinematicBase &lt;|-- FB_KinematicGroup\n    FB_ComponentKinematicBase &lt;|.. I_Kinematic\n    FB_ComponentKinematicBase *-- FB_KinematicAxisRef\n    FB_KinematicAxisRef &lt;|.. I_KinematicAxisRef\n    FB_KinematicGroup &lt;|.. I_KinematicGroup\n    FB_KinematicGroup &lt;|-- FB_ComponentBase\n    FB_ComponentKinematicMotionCamming &lt;|-- FB_ComponentKinematicBase\n    FB_ComponentKinematicMotionAmp &lt;|-- FB_ComponentKinematicBase\n    FB_KinematicMotionAmpBase &lt;|-- FB_CyclicFB\n    FB_KinematicMotionAmpBase &lt;|.. I_KinematicCm\n    FB_ComponentKinematicMotionAmp &lt;|.. I_KinematicCm\n    FB_ComponentKinematicMotionAmp *-- FB_KinematicMotionAmpBase\n    class I_KinematicAxisRef{\n        DegreesOfFreedomConfigured\n        AcsAxis \n        McsAxis \n    }\n    class FB_KinematicGroup{\n            KinematicAxisIds\n\n            ResetKinGroup()\n        }\n    class I_KinematicGroup{\n        &lt;&lt;Interface&gt;&gt;\n        KinematicStatus\n        KinMetaInfo\n        OidKinTrafo\n\n        SetKinematicParameter()\n\n        BuildKinGroup()\n        DissolveKInGroup()\n    }\n    class FB_ComponentKinematicBase{\n            iAxisRef : I_KinematicAxisRef;\n        }\n    class I_Kinematic{\n        &lt;&lt;Interface&gt;&gt;\n            Override\n            Enabled\n            InPosition\n            Moving\n            ActPosition\n            DegreesOfFreedomConfigured\n\n            Disable()\n            Enable()\n            JogCartesianAxis(Axisx,Forward,Backward,JogMode)\n            JogJoint(Jointx,Forward,Backward,JogMode)\n            Stop()\n        }\n    class I_KinematicCm{\n        &lt;&lt;Interface&gt;&gt;\n\n        CmIdentGroup\n        CmState\n\n        DisableCmGroup()\n        EnableCmGroup()\n        StartMovePath()\n        BuildCmGroup()\n        UngroupCmGroup()\n        ClearPath()\n\n    }\n    class FB_KinematicMotionAmpBase{\n        CmAxisCount\n        CmAxisRef\n        CmIdentGroup\n\n        AddCircularMoveToPath()\n        AddLinearMoveToPath()\n        Reset()\n        SetOverride()\n        Stop()\n    }\n    class FB_ComponentKinematicMotionAmp{\n        ChangeOccurred\n        Points\n\n        MoveToPointCartesian()\n        AddCircularMoveToPath()\n        AddLinearMoveToPath()\n        GetPoint()\n        SetPoint()\n    }\n    class I_KinematicCamming{\n        CammingActive\n\n        CamClearPath()\n        CamIn()\n        CamOut()\n        CamStartMovePath()\n    }\n    class FB_KinematicCamming{\n        CamAxisCount\n        CamAxisRef\n\n        CamAddPointToPath()\n        Disable()\n        Enable()\n        Reset()\n        SetOverride()\n        Stop()\n    }\n    class FB_ComponentKinematicMotionCamming{\n        ChangeOccurred\n        Points\n\n        CamAddPointToPath()\n        GetPoint()\n        SetPoint()\n    }</code></pre>"},{"location":"SPT_Kinematic/index.html#state-diagrams","title":"State Diagrams","text":"<p>Joint Operations <pre><code>stateDiagram-v2\n    [*] --&gt; Robot\n\n    Robot --&gt; Enabled : Enable()\n    Enabled --&gt; Robot : Disable()\n    Enabled --&gt; JointMoving : JogJointAxis()\n</code></pre> Cartesian Operations with Advanced Motion Package for DOF=2 to DOF=4 <pre><code>stateDiagram-v2\n    [*] --&gt; Robot\n\n    Robot --&gt; Enabled_JointMode_ACS : Enable()\n    Enabled_JointMode_ACS --&gt; Robot : Disable()\n\n\n    Robot --&gt; Enabled_CartesianMode_MCS : Enable()\n\n    Enabled_JointMode_ACS --&gt; Enabled_CartesianMode_MCS : BuildKinGroup()\n    Enabled_CartesianMode_MCS --&gt; Enabled_JointMode_ACS : DissolveKinGroup()\n\n    Enabled_CartesianMode_MCS --&gt; Robot : Disable()\n\n    Enabled_CartesianMode_MCS --&gt; CartesianAxisMoving : JogCartesianAxis()\n\n    Enabled_CartesianMode_MCS --&gt; CartesianModeCoordinatedMotionXYZC : BuildCmGroup() &amp; EnableCmGroup()\n    CartesianModeCoordinatedMotionXYZC --&gt; Enabled_CartesianMode_MCS : DisableCmGroup() &amp; UngroupCmGroup()\n\n    CartesianModeCoordinatedMotionXYZC --&gt; PreparedPath : AddLinearMoveToPath() OR AddCircularMoveToPath()\n\n    PreparedPath --&gt; CartesianModeCoordinatedMotionXYZC: ClearPath()\n\n    PreparedPath --&gt; Moving : StartMovePath()\n    Moving --&gt; PreparedPath : Stop()\n</code></pre></p> <p>Joint/Cartesian Operations Camming for DOF=2 to DOF=6 <pre><code>stateDiagram-v2\n    [*] --&gt; Robot\n\n    Robot --&gt; Enabled_JointMode_ACS : Enable()\n    Enabled_JointMode_ACS --&gt; Robot : Disable()\n\n\n    Robot --&gt; Enabled_CartesianMode_MCS : Enable()\n\n    Enabled_JointMode_ACS --&gt; Enabled_CartesianMode_MCS : BuildKinGroup()\n    Enabled_CartesianMode_MCS --&gt; Enabled_JointMode_ACS : DissolveKinGroup()\n\n    Enabled_CartesianMode_MCS --&gt; Robot : Disable()\n\n    Enabled_CartesianMode_MCS --&gt; CartesianAxisMoving : JogCartesianAxis()\n\n\n    Enabled_JointMode_ACS --&gt; CammingActive_JointMode_ACS : CamAddPointToPath() &amp; CamIn()\n    CammingActive_JointMode_ACS --&gt; Enabled_JointMode_ACS : CamOut() &amp; ClearPath()\n\n    Enabled_CartesianMode_MCS --&gt; CammingActive_CartesianMode_MCS : CamAddPointToPath() &amp; CamIn()\n    CammingActive_CartesianMode_MCS --&gt; Enabled_CartesianMode_MCS : CamOut() &amp; ClearPath()\n\n    CammingActive_CartesianMode_MCS --&gt; MCS_Moving : CamStartMovePath()\n    MCS_Moving --&gt; CammingActive_CartesianMode_MCS : Stop()\n\n    CammingActive_JointMode_ACS --&gt; ACS_Moving : CamStartMovePath()\n    ACS_Moving --&gt; CammingActive_JointMode_ACS : Stop()</code></pre></p> <p>Open Objects</p> <p>The Kinematic Objects are by design fully accessible for the numerous applications possible with the Beckhoff Package. This requires manual handling of the CM/AMP-States along with the Kinematic States by the user. You can see this in the states-diagrams above.</p> <p>**This Boot or shutdown sequences can be programmed by extension of the Object in a separate Method if desired. ** E.g. PackML implementation.</p>"},{"location":"SPT_Kinematic/changelog.html","title":"Changelog","text":""},{"location":"SPT_Kinematic/changelog.html#40-2025-05-20","title":"[4.0] - 2025-05-20","text":""},{"location":"SPT_Kinematic/changelog.html#compiled","title":"Compiled","text":"<ul> <li>Using TwinCAT 3.1.4026</li> </ul>"},{"location":"SPT_Kinematic/changelog.html#39-2025-04-14","title":"[3.9] - 2025-04-14","text":""},{"location":"SPT_Kinematic/changelog.html#finalizing","title":"Finalizing","text":"<ul> <li>Internal updates and cleanup</li> </ul>"},{"location":"SPT_Kinematic/changelog.html#339-2025-04-11","title":"[3.3.9] - 2025-04-11","text":""},{"location":"SPT_Kinematic/changelog.html#sync","title":"Sync","text":"<ul> <li>Implement same version number across all SPT libraries</li> </ul>"},{"location":"SPT_Kinematic/changelog.html#added","title":"Added","text":"<ul> <li>Code formatting and comments</li> </ul>"},{"location":"SPT_Kinematic/changelog.html#336-2024-22-08","title":"[3.3.6] - 2024-22-08","text":""},{"location":"SPT_Kinematic/changelog.html#changed","title":"Changed","text":"<ul> <li>Correct return values of AMP add points to path</li> </ul>"},{"location":"SPT_Kinematic/changelog.html#335-2024-20-08-breaking-changes","title":"[3.3.5] - 2024-20-08 - Breaking changes!","text":""},{"location":"SPT_Kinematic/changelog.html#added_1","title":"Added","text":"<ul> <li><code>AcsPositionAbsolute</code> to interpret ACS position linear or Modulo</li> <li><code>AcsAxisCount</code> ability to differ MCS and ACS Axes amount.</li> <li><code>OidKinTrafo</code> exposed from <code>FB_KinematicGroup</code></li> </ul>"},{"location":"SPT_Kinematic/changelog.html#changed_1","title":"Changed","text":"<ul> <li>Removed 'Kinematic - ' from Error Message detail</li> <li>Cleanup initialization sequences</li> </ul>"},{"location":"SPT_Kinematic/changelog.html#331-2023-12-13","title":"[3.3.1] - 2023-12-13","text":""},{"location":"SPT_Kinematic/changelog.html#changed_2","title":"Changed","text":"<ul> <li>MCS Rotation Axes display modulo values</li> </ul>"},{"location":"SPT_Kinematic/changelog.html#330-2023-12-12","title":"[3.3.0] - 2023-12-12","text":""},{"location":"SPT_Kinematic/changelog.html#changed_3","title":"Changed","text":"<ul> <li>Unique Cam Table Id for every Axis</li> </ul>"},{"location":"SPT_Kinematic/changelog.html#added_2","title":"Added","text":"<ul> <li><code>CammingFirstPointInTableByUser</code> to set cam table Point 1</li> <li>CamIn Options </li> <li>MC_ReadCamTableSlaveDynamics for each ACS and MCS Axis</li> </ul>"},{"location":"SPT_Kinematic/changelog.html#328-2023-11-13","title":"[3.2.8] - 2023-11-13","text":""},{"location":"SPT_Kinematic/changelog.html#added_3","title":"Added","text":"<ul> <li>CamAddMotionPointByAxis() to create separate Cam tables per Axis</li> <li>CamMasterZero() to set Cam Master to 0.0 Position</li> <li>Parameter <code>ExecuteCamPeriodically</code> for cyclic execution to Cam Table</li> <li>Parameter <code>CamMasterAbsolute</code> and <code>CamMasterAbsolute</code> to configure Cam Table</li> <li>Axis Reference to Camming Master Axis for MCS and ACS</li> </ul>"},{"location":"SPT_Kinematic/changelog.html#327-2023-07-11","title":"[3.2.7] - 2023-07-11","text":""},{"location":"SPT_Kinematic/changelog.html#added_4","title":"Added","text":"<ul> <li>Ring Buffer to Advanced Motion Package for on the fly path change</li> <li>Conveyor Tracking Advanced Motion Package</li> </ul>"},{"location":"SPT_Kinematic/changelog.html#320-2023-06-02","title":"[3.2.0] - 2023-06-02","text":""},{"location":"SPT_Kinematic/changelog.html#added_5","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_Kinematic/duts.html","title":"DUTs","text":""},{"location":"SPT_Kinematic/duts.html#enums","title":"ENUMs","text":""},{"location":"SPT_Kinematic/duts.html#e_kinematicdof","title":"E_KinematicDOF","text":"<pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_KinematicDOF :\n(\n    eKinematicDOF_2 := 2, //\n    eKinematicDOF_3 := 3, //\n    eKinematicDOF_4 := 4, // \n    eKinematicDOF_5 := 5, // \n    eKinematicDOF_6 := 6, //\n    eKinematicDOF_Max := 7 // \n);\nEND_TYPE\n</code></pre>"},{"location":"SPT_Kinematic/duts.html#e_acsjoint","title":"E_AcsJoint","text":"<pre><code>{attribute 'qualified_only'}\nTYPE E_AcsJoint :\n(\n    Joint_1 := 1,\n    Joint_2 := 2,\n    Joint_3 := 3,\n    Joint_4 := 4,\n    Joint_5 := 5,\n    Joint_6 := 6\n);\nEND_TYPE\n</code></pre>"},{"location":"SPT_Kinematic/duts.html#e_mcsaxis","title":"E_McsAxis","text":"<pre><code>{attribute 'qualified_only'}\nTYPE E_McsAxis :\n(\n    X := 1,\n    Y := 2,\n    Z := 3,\n    Rot1 := 4, // C1, Rx,..\n    Rot2 := 5, // C2, Ry,..\n    Rot3 := 6 // C3, Rz,..\n);\nEND_TYPE\n</code></pre>"},{"location":"SPT_Kinematic/duts.html#structs","title":"STRUCTs","text":""},{"location":"SPT_Kinematic/duts.html#st_kinematicposition","title":"ST_KinematicPosition","text":"<pre><code>TYPE ST_KinematicPosition :\nSTRUCT\n    ACS : ARRAY[1..8] OF LREAL;\n    MCS : ARRAY[1..8] OF LREAL;\nEND_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Kinematic/duts.html#st_kinematicmotionparameter","title":"ST_KinematicMotionParameter","text":"<pre><code>TYPE ST_KinematicMotionParameter :\nSTRUCT\n    Acs : ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM] OF ST_KinematicMotionParameterValues;\n    Mcs : ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM] OF ST_KinematicMotionParameterValues;\nEND_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Kinematic/duts.html#st_kinematicmotionparametervalues","title":"ST_KinematicMotionParameterValues","text":"<pre><code>TYPE ST_KinematicMotionParameterValues :\nSTRUCT\n    Position            : LREAL;\n    Acceleration        : LREAL;\n    Deceleration        : LREAL;\n    Jerk                : LREAL;\nEND_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Kinematic/duts.html#st_basepoint","title":"ST_BasePoint","text":"<pre><code>TYPE ST_BasePoint :\nSTRUCT\n    AcsPosition : ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX] OF LREAL;\nEND_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Kinematic/duts.html#st_kinematiccomponentamp_cmgroupstate","title":"ST_KinematicComponentAmp_CmGroupState","text":"<pre><code>TYPE ST_KinematicComponentAmp_CmGroupState :\n    STRUCT\n            McToPlcCm                   : CDT_MCTOPLC_GROUP_CM;\n            GroupBuilt                  : BOOL;\n            GroupMoving                 : BOOL;\n            GroupHoming                 : BOOL;\n            GroupErrorStop              : BOOL;\n            GroupNotReady               : BOOL;\n            GroupStandby                : BOOL;\n            GroupStopping               : BOOL;\n            GroupDisabled               : BOOL;\n            GroupTrackingInSync         : BOOL;\n            GroupTrackingActive         : BOOL;\n            GroupTrackingCommandAborted : BOOL;\n            AllAxesStanding             : BOOL;\n            ConstantVelocity            : BOOL;\n            Accelerating                : BOOL;\n            Decelerating                : BOOL;\n            InPosition                  : BOOL;\n            Error                       : BOOL;\n            ErrorId                     : UDINT;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Kinematic/duts.html#st_amppoint","title":"ST_AmpPoint","text":"<p>Advanced Motion Pack Space Point incl. required parameter for move. This struct can be used to create Machine Point Management System (e.g. Teaching).</p> <pre><code>TYPE ST_AmpPoint EXTENDS ST_BasePoint :\nSTRUCT\n    CircularMove            : ST_AmpPointCircular;                                                      \n    Velocity                : MC_LREAL := MC_INVALID;\n    Acceleration            : MC_LREAL := MC_DEFAULT;\n    Deceleration            : MC_LREAL := MC_DEFAULT;\n    Jerk                    : MC_LREAL := MC_DEFAULT;\n    BufferMode              : MC_BUFFERMODE := MC_BUFFER_MODE.mcAborting;\n    TransitionMode          : MC_TRANSITION_MODE := mcTransModeNone; \n    TransitionParameter     : ARRAY[1..2] OF LREAL;\n    TransitionParameterCount: UDINT;\n    InvokeId                : UDINT;\nEND_STRUCT\nEND_TYPE\n\nTYPE ST_AmpPointCircular :\nSTRUCT\n    CircMode                : MC_CIRC_MODE;\n    AuxPoint                : ARRAY[1..3] OF MC_LREAL;\n    PathChoice              : MC_CIRC_PATHCHOICE;\nEND_STRUCT\nEND_TYPE\n</code></pre> Warning <p>BufferMode and TransitionMode are dependent on each other. </p> <p>Information</p> <p>Linear Parameter Detail:</p> <p></p> <p>Circular Parameter Detail:</p> <p></p>"},{"location":"SPT_Kinematic/duts.html#st_camtableslavedynamics","title":"ST_CamTableSlaveDynamics","text":"<pre><code>TYPE ST_CamTableSlaveDynamics :\n    STRUCT\n        SlavePosition     : LREAL;\n        SlaveVelocity     : LREAL;\n        SlaveAcceleration : LREAL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Kinematic/exampleCode.html","title":"Example Code","text":""},{"location":"SPT_Kinematic/exampleCode.html#advanced-motion-package","title":"Advanced Motion Package","text":"<p>E.g. Scara or Delta. Can be used for Kinematics up to DOF=4.</p>"},{"location":"SPT_Kinematic/exampleCode.html#example-1-startup-coordinated-motion-with-amp","title":"Example 1 - Startup Coordinated Motion with AMP","text":"<p>Startup Sequence for System to reach ability for Coordinated Movement.</p> <pre><code>        CASE SequenceState OF\n            0: // Enable Kinematic\n                NoStateTasksToComplete := FALSE;\n\n                IF DeltaKinematic.Enable() THEN\n                    SequenceState := 5;\n                END_IF\n\n            5: // Wait for enabled\n                IF DeltaKinematic.Enabled AND NOT DeltaKinematic.Busy THEN\n                    SequenceState := 10;\n                END_IF\n\n            10: // Transition to cartesian mode - kinematic enable\n                IF DeltaKinematic.BuildKinGroup() THEN\n                    SequenceState := 15;\n                END_IF\n\n            15: // Transition to cartesian mode - kinematic enable\n                IF DeltaKinematic.KinematicStatus = E_KinStatus.KinStatus_Ready AND NOT DeltaKinematic.Busy THEN\n                    SequenceState := 20;\n                END_IF\n\n            20: // Create CM Group for Advanced Motion - Coordinated Path Motion\n                IF DeltaKinematic.BuildCmGroup() THEN\n                    SequenceState := 25;\n                END_IF\n\n            25: // NO Error -&gt; Axis added to Group\n                IF NOT DeltaKinematic.CmState.Error THEN\n                    StateComplete();\n                END_IF  \n        END_CASE\n</code></pre>"},{"location":"SPT_Kinematic/exampleCode.html#example-2-execute-movement-coordinated-motion-with-amp","title":"Example 2 - Execute Movement Coordinated Motion with AMP","text":"<pre><code>VAR\n    _idx : DINT;\n    DeltaPoints : ARRAY[0..Parameter_KinematicAmp.MaxPoints] OF ST_AmpPoint; // it is recommended to store points permanently in a recipe management system\nEND_VAR\n\n        CASE SequenceState OF\n            0: // Enable Motion Group\n                IF DeltaKinematic.EnableCmGroup() THEN\n                    SequenceState := 5;\n                END_IF\n\n            5: // Enabled -&gt; Coordinated Motion State Diagram\n                IF DeltaKinematic.CmState.GroupStandby THEN\n                    SequenceState := 10;\n                END_IF\n\n            10: // Create Path 1\n                DeltaKinematic.ClearPath();\n\n                // Start Point\n                _idx := 1;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.X] := 0;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Y] := 0;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Z] := -687;\n                //DeltaPoints[1].McsPosition[E_McsAxis.Rot1] := 0; // Not used in Delta!\n                DeltaPoints[_idx].Velocity := 50.0;\n                DeltaPoints[_idx].Acceleration := 150.0;\n                DeltaPoints[_idx].Deceleration := 25.0;\n                DeltaPoints[_idx].Jerk := 1500.0;\n                DeltaPoints[_idx].BufferMode := MC_BUFFER_MODE.mcAborting;\n                DeltaPoints[_idx].TransitionMode := MC_TRANSITION_MODE.mcTransModeNone;\n                DeltaPoints[_idx].TransitionParameter[1] := 0;\n                DeltaPoints[_idx].TransitionParameter[2] := 0;\n                DeltaPoints[_idx].TransitionParameterCount := 0;\n                DeltaPoints[_idx].InvokeId := 10;\n\n                // Radius Point 1\n                _idx := 2;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.X] := 50;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Y] := 100;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Z] := -687;\n                //DeltaPoints[1].McsPosition[E_McsAxis.Rot1] := 0; // Not used in Delta!\n                DeltaPoints[_idx].Velocity := 50.0;\n                DeltaPoints[_idx].Acceleration := 150.0;\n                DeltaPoints[_idx].Deceleration := 25.0;\n                DeltaPoints[_idx].Jerk := 1500.0;\n                DeltaPoints[_idx].BufferMode := MC_BUFFER_MODE.mcBlendingPrevious;\n                DeltaPoints[_idx].TransitionMode := MC_TRANSITION_MODE.mcTransModeCornerDistanceAdvanced;\n                DeltaPoints[_idx].TransitionParameter[1] := 10;\n                DeltaPoints[_idx].TransitionParameter[2] := 20;\n                DeltaPoints[_idx].TransitionParameterCount := 2;\n                DeltaPoints[_idx].InvokeId := 20;\n\n                // Radius Point 2\n                _idx := 3;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.X] := 200;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Y] := 100;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Z] := -687;\n                //DeltaPoints[1].McsPosition[E_McsAxis.Rot1] := 0; // Not used in Delta!\n                DeltaPoints[_idx].Velocity := 50.0;\n                DeltaPoints[_idx].Acceleration := 150.0;\n                DeltaPoints[_idx].Deceleration := 25.0;\n                DeltaPoints[_idx].Jerk := 1500.0;\n                DeltaPoints[_idx].BufferMode := MC_BUFFER_MODE.mcBlendingPrevious;\n                DeltaPoints[_idx].TransitionMode := MC_TRANSITION_MODE.mcTransModeCornerDistanceAdvanced;\n                DeltaPoints[_idx].TransitionParameter[1] := 10;\n                DeltaPoints[_idx].TransitionParameter[2] := 20;\n                DeltaPoints[_idx].TransitionParameterCount := 2;\n                DeltaPoints[_idx].InvokeId := 30;\n\n                // Final Point\n                _idx := 4;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.X] := 300;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Y] := 0;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Z] := -687;\n                //DeltaPoints[1].McsPosition[E_McsAxis.Rot1] := 0; // Not used in Delta!\n                DeltaPoints[_idx].Velocity := 50.0;\n                DeltaPoints[_idx].Acceleration := 150.0;\n                DeltaPoints[_idx].Deceleration := 25.0;\n                DeltaPoints[_idx].Jerk := 1500.0;\n                DeltaPoints[_idx].BufferMode := MC_BUFFER_MODE.mcBuffered;\n                DeltaPoints[_idx].TransitionMode := MC_TRANSITION_MODE.mcTransModeNone;\n                DeltaPoints[_idx].TransitionParameter[1] := 0;\n                DeltaPoints[_idx].TransitionParameter[2] := 0;\n                DeltaPoints[_idx].TransitionParameterCount := 0;\n                DeltaPoints[_idx].InvokeId := 40;\n\n                // back to start circular\n                _idx := 5;\n                DeltaPoints[_idx].CircularMove.CircMode             := MC_CIRC_MODE.mcCircModeBorder;\n                DeltaPoints[_idx].CircularMove.AuxPoint[E_McsAxis.X]    := 150;\n                DeltaPoints[_idx].CircularMove.AuxPoint[E_McsAxis.Y]    := 150;\n                DeltaPoints[_idx].CircularMove.AuxPoint[E_McsAxis.Z]    := -687;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.X]  := 0; // End Point of Circle\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Y]  := 0;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Z]  := -687;\n                DeltaPoints[_idx].CircularMove.PathChoice           := MC_CIRC_PATHCHOICE.mcCircPathChoiceCounterClockwise;\n                DeltaPoints[_idx].Velocity := 50.0;\n                DeltaPoints[_idx].Acceleration := 150.0;\n                DeltaPoints[_idx].Deceleration := 25.0;\n                DeltaPoints[_idx].Jerk := 1500.0;\n                DeltaPoints[_idx].BufferMode := MC_BUFFER_MODE.mcBuffered;\n                DeltaPoints[_idx].TransitionMode := MC_TRANSITION_MODE.mcTransModeNone;\n                DeltaPoints[_idx].TransitionParameter[1] := 0;\n                DeltaPoints[_idx].TransitionParameter[2] := 0;\n                DeltaPoints[_idx].TransitionParameterCount := 0;\n                DeltaPoints[_idx].InvokeId := 50;\n\n                DeltaKInematic.Points := DeltaPoints;\n                DeltaKinematic.AddLinearMoveToPath(1);\n                DeltaKinematic.AddLinearMoveToPath(2);\n                DeltaKinematic.AddLinearMoveToPath(3);\n                DeltaKinematic.AddLinearMoveToPath(4);\n                DeltaKinematic.AddCircularMoveToPath(5);\n\n                SequenceState := 20;\n\n            20: // Execute Path 1\n                IF DeltaKinematic.StartMovePath() THEN\n                    SequenceState := 30;\n                END_IF\n\n            30: // Wait Moving\n                IF DeltaKinematic.CmState.GroupMoving AND DeltaKinematic.busy THEN\n                    SequenceState := 40;\n                END_IF\n\n            40: // Wait for Path Done   \n                IF NOT DeltaKinematic.CmState.GroupMoving AND NOT DeltaKinematic.busy THEN\n                    SequenceState := 10; // repeat path\n                END_IF\n\n            999: // Done\n                 ;\n        END_CASE\n</code></pre>"},{"location":"SPT_Kinematic/exampleCode.html#example-3-stop-and-shutdown-coordinated-motion-with-amp","title":"Example 3 - Stop and Shutdown Coordinated Motion with AMP","text":"<pre><code>        CASE SequenceState OF\n            0:  NoStateTasksToComplete := FALSE;\n                IF DeltaKinematic.Moving THEN     // Kinematic Moving\n                    IF DeltaKinematic.Stop(0,0) THEN\n                        SequenceState := 5;\n                    END_IF\n                ELSE\n                    SequenceState := 10;\n                END_IF\n\n            5: // Wait for not Moving\n                IF NOT DeltaKinematic.Moving THEN\n                    SequenceState := 10;\n                END_IF\n\n            10: // Check CM Group Enabled/Built\n                IF NOT DeltaKinematic.CmState.GroupDisabled THEN\n                    IF DeltaKinematic.DisableCmGroup() THEN\n                        SequenceState := 20;\n                    END_IF\n                ELSE\n                    SequenceState := 30;\n                END_IF\n\n            20: // When Disabled - ungroup\n                IF DeltaKinematic.CmState.GroupDisabled OR DeltaKinematic.CmState.GroupErrorStop THEN\n                    DeltaKinematic.UngroupCmGroup();\n                    SequenceState := 30;\n                END_IF\n\n            30: // Kinematic Group is Built -&gt; Dissolve before disable\n                IF DeltaKinematic.KinematicStatus = E_KinStatus.KinStatus_Ready THEN\n                    DeltaKinematic.DissolveKinGroup();\n                    SequenceState := 35;\n                ELSE\n                    SequenceState := 40;\n                END_IF\n\n            35: // Wait for Dissolved\n                IF DeltaKinematic.KinematicStatus = E_KinStatus.KinStatus_Empty THEN\n                    SequenceState := 40;\n                END_IF\n\n            40: // Disable ACS and MCS\n                IF DeltaKinematic.Disable() THEN\n                    SequenceState := 50;\n                END_IF\n\n            50: // Wait for Disabled\n                IF NOT DeltaKinematic.Enabled THEN\n                    SequenceState := 999;\n                END_IF\n\n            999:// Done\n                StateTasksComplete := TRUE;\n        END_CASE\n</code></pre>"},{"location":"SPT_Kinematic/exampleCode.html#example-4-execute-movement-coordinated-motion-with-amp-and-switch-path-during-motion","title":"Example 4 - Execute Movement Coordinated Motion with AMP and switch Path during motion","text":"<pre><code>        CASE SequenceState OF\n            0: // Enable Motion Group\n                IF DeltaKinematic.EnableCmGroup() THEN\n                    SequenceState := 5;\n                END_IF\n\n            5: // Enabled -&gt; Coordinated Motion State Diagram\n                IF DeltaKinematic.CmState.GroupStandby THEN\n                    SequenceState := 10;\n                END_IF\n\n            10: // Create Path 1\n                DeltaKinematic.ClearPath();\n\n                // Start Point\n                _idx                                       := 1;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.X] := 0;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Y] := 0;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Z] := -687;\n                DeltaPoints[_idx].Velocity                 := 50.0;\n                DeltaPoints[_idx].Acceleration             := 150.0;\n                DeltaPoints[_idx].Deceleration             := 25.0;\n                DeltaPoints[_idx].Jerk                     := 1500.0;\n                DeltaPoints[_idx].BufferMode               := MC_BUFFER_MODE.mcAborting;\n                DeltaPoints[_idx].TransitionMode           := MC_TRANSITION_MODE.mcTransModeNone;\n                DeltaPoints[_idx].TransitionParameter[1]   := 0;\n                DeltaPoints[_idx].TransitionParameter[2]   := 0;\n                DeltaPoints[_idx].TransitionParameterCount := 0;\n                DeltaPoints[_idx].InvokeId                 := 10;\n\n                // Radius Point 1\n                _idx                                       := 2;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.X] := 50;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Y] := 0;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Z] := -687;\n                DeltaPoints[_idx].Velocity                 := 50.0;\n                DeltaPoints[_idx].Acceleration             := 150.0;\n                DeltaPoints[_idx].Deceleration             := 25.0;\n                DeltaPoints[_idx].Jerk                     := 1500.0;\n                DeltaPoints[_idx].BufferMode               := MC_BUFFER_MODE.mcBlendingPrevious;\n                DeltaPoints[_idx].TransitionMode           := MC_TRANSITION_MODE.mcTransModeCornerDistanceAdvanced;\n                DeltaPoints[_idx].TransitionParameter[1]   := 10;\n                DeltaPoints[_idx].TransitionParameter[2]   := 20;\n                DeltaPoints[_idx].TransitionParameterCount := 2;\n                DeltaPoints[_idx].InvokeId                 := 20;\n\n                // Radius Point 2\n                _idx                                       := 3;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.X] := 200;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Y] := 0;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Z] := -687;\n                DeltaPoints[_idx].Velocity                 := 50.0;\n                DeltaPoints[_idx].Acceleration             := 150.0;\n                DeltaPoints[_idx].Deceleration             := 25.0;\n                DeltaPoints[_idx].Jerk                     := 1500.0;\n                DeltaPoints[_idx].BufferMode               := MC_BUFFER_MODE.mcBlendingPrevious;\n                DeltaPoints[_idx].TransitionMode           := MC_TRANSITION_MODE.mcTransModeCornerDistanceAdvanced;\n                DeltaPoints[_idx].TransitionParameter[1]   := 10;\n                DeltaPoints[_idx].TransitionParameter[2]   := 20;\n                DeltaPoints[_idx].TransitionParameterCount := 2;\n                DeltaPoints[_idx].InvokeId                 := 30;\n\n                // Final Point\n                _idx                                       := 4;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.X] := 300;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Y] := 0;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Z] := -687;\n                DeltaPoints[_idx].Velocity                 := 50.0;\n                DeltaPoints[_idx].Acceleration             := 150.0;\n                DeltaPoints[_idx].Deceleration             := 25.0;\n                DeltaPoints[_idx].Jerk                     := 1500.0;\n                DeltaPoints[_idx].BufferMode               := MC_BUFFER_MODE.mcBlendingPrevious;\n                DeltaPoints[_idx].TransitionMode           := MC_TRANSITION_MODE.mcTransModeCornerDistanceAdvanced;\n                DeltaPoints[_idx].TransitionParameter[1]   := 10;\n                DeltaPoints[_idx].TransitionParameter[2]   := 20;\n                DeltaPoints[_idx].TransitionParameterCount := 2;\n                DeltaPoints[_idx].InvokeId                 := 40;\n\n                // Build Path\n                DeltaKInematic.Points := DeltaPoints;\n                DeltaKinematic.AddLinearMoveToPath(1);\n                DeltaKinematic.AddLinearMoveToPath(2);\n                DeltaKinematic.AddLinearMoveToPath(3);\n                DeltaKinematic.AddLinearMoveToPath(4);\n                SequenceState := 20;\n\n            20: // Execute Path 1\n                IF DeltaKinematic.StartMovePath(ChangePath := TRUE) THEN\n                    SequenceState := 30;\n                END_IF\n\n            30: // Wait Moving\n                IF DeltaKinematic.CmState.GroupMoving AND DeltaKinematic.busy THEN\n                    SequenceState := 40;\n                END_IF\n\n            40: // Wait for Path Done   \n                IF NOT DeltaKinematic.CmState.GroupMoving AND NOT DeltaKinematic.busy THEN\n                    SequenceState := 10; // repeat path\n                END_IF\n\n                IF Interrupt AND DeltaKinematic.CmState.McToPlcCm.InvokeId = 30 THEN\n                    Interrupt     := FALSE;\n                    SequenceState := 50;\n                END_IF\n\n            50: //\n                DeltaKinematic.ClearPath();\n\n                // Redirect\n                _idx                                       := 5;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.X] := -55;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Y] := 0;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Z] := -687;\n                DeltaPoints[_idx].Velocity                 := 80.0;\n                DeltaPoints[_idx].Acceleration             := 150.0;\n                DeltaPoints[_idx].Deceleration             := 25.0;\n                DeltaPoints[_idx].Jerk                     := 1500.0;\n                DeltaPoints[_idx].BufferMode               := MC_BUFFER_MODE.mcAborting;\n                DeltaPoints[_idx].TransitionMode           := MC_TRANSITION_MODE.mcTransModeNone;\n                DeltaPoints[_idx].TransitionParameter[1]   := 0;\n                DeltaPoints[_idx].TransitionParameter[2]   := 0;\n                DeltaPoints[_idx].TransitionParameterCount := 0;\n                DeltaPoints[_idx].InvokeId                 := 50;\n\n                // Redirect\n                _idx                                       := 6;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.X] := -60;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Y] := 0;\n                DeltaPoints[_idx].McsPosition[E_McsAxis.Z] := -687;\n                DeltaPoints[_idx].Velocity                 := 5.0;\n                DeltaPoints[_idx].Acceleration             := 150.0;\n                DeltaPoints[_idx].Deceleration             := 25.0;\n                DeltaPoints[_idx].Jerk                     := 1500.0;\n                DeltaPoints[_idx].BufferMode               := MC_BUFFER_MODE.mcBlendingPrevious;\n                DeltaPoints[_idx].TransitionMode           := MC_TRANSITION_MODE.mcTransModeCornerDistanceAdvanced;\n                DeltaPoints[_idx].TransitionParameter[1]   := 10;\n                DeltaPoints[_idx].TransitionParameter[2]   := 20;\n                DeltaPoints[_idx].TransitionParameterCount := 2;\n                DeltaPoints[_idx].InvokeId                 := 60;\n\n                // Build Path\n                DeltaKInematic.Points := DeltaPoints;\n                DeltaKinematic.AddLinearMoveToPath(5);\n                DeltaKinematic.AddLinearMoveToPath(6);\n                SequenceState := 20;\n\n            999: // Done\n                ;\n        END_CASE\n</code></pre>"},{"location":"SPT_Kinematic/exampleCode.html#example-scope-for-amp","title":"Example Scope for AMP","text":""},{"location":"SPT_Kinematic/exampleCode.html#camming","title":"Camming","text":"<p>Can be used for all Kinematic Systems.</p>"},{"location":"SPT_Kinematic/exampleCode.html#example-1-startup-coordinated-motion-with-camming","title":"Example 1 - Startup Coordinated Motion with Camming","text":"<pre><code>            CASE SequenceState OF\n                0: // Enable Kinematic\n                    IF RobotKinematic.Enable() THEN\n                        SequenceState := 5;\n                    END_IF\n\n                5: // Wait for enabled\n                    IF RobotKinematic.Enabled AND NOT RobotKinematic.Busy THEN\n                        IF _Recipe.MoveAcsPoints THEN // Execute from here if ACS movements should be done\n                            // Done\n                        ELSE\n                            SequenceState := 10;\n                        END_IF\n\n                    END_IF\n\n                10: // Transition to cartesian mode - kinematic enable\n                    IF RobotKinematic.BuildKinGroup() THEN\n                        SequenceState := 15;\n                    END_IF\n\n                15: // Transition to cartesian mode - kinematic enable\n                    IF RobotKinematic.KinematicStatus = E_KinStatus.KinStatus_Ready AND NOT RobotKinematic.Busy THEN\n                        // Done\n                    END_IF  \n            END_CASE\n</code></pre>"},{"location":"SPT_Kinematic/exampleCode.html#example-2-execute-movement-coordinated-motion-with-camming","title":"Example 2 - Execute Movement Coordinated Motion with Camming","text":"<pre><code>VAR\n    _TempPointVelocity           : ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX] OF LREAL; \n    _TempPointAcceleration       : ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX] OF LREAL; \n    _TempPointJerk               : ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX] OF LREAL; \nEND_VAR\n\n            CASE SequenceState OF\n                0: // Add Point 1-4\n                    IF  RobotKinematic.CamAddPointToPath(   MotionFunctionFirstPoint    := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5, \n                                                            MotionFunctionThisPoint     := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5, \n                                                            PointNumber                 := 2, \n                                                            TotalPointsInTable          := 5, // Minimum of 2 (Start Point + End Point), Start Point is automatically set by FB internally\n                                                            PointVelocity               := _TempPointVelocity,      // at this Point in Cam Table\n                                                            PointAcceleration           := _TempPointAcceleration,  // at this Point in Cam Table\n                                                            PointJerk                   := _TempPointJerk,          // at this Point in Cam Table\n                                                            PointIndex                  := 1)                       // Index of Point in structure of ST_BasePoint\n                        AND\n                        RobotKinematic.CamAddPointToPath(   MotionFunctionFirstPoint    := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5, \n                                                            MotionFunctionThisPoint     := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5, \n                                                            PointNumber                 := 3, \n                                                            TotalPointsInTable          := 5, // Minimum of 2 (Start Point + End Point), Start Point is automatically set by FB internally\n                                                            PointVelocity               := _TempPointVelocity,      // at this Point in Cam Table\n                                                            PointAcceleration           := _TempPointAcceleration,  // at this Point in Cam Table\n                                                            PointJerk                   := _TempPointJerk,          // at this Point in Cam Table\n                                                            PointIndex                  := 2)                       // Index of Point in structure of ST_BasePoint  \n                        AND\n                        RobotKinematic.CamAddPointToPath(   MotionFunctionFirstPoint    := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5, \n                                                            MotionFunctionThisPoint     := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5, \n                                                            PointNumber                 := 4, \n                                                            TotalPointsInTable          := 5, // Minimum of 2 (Start Point + End Point), Start Point is automatically set by FB internally\n                                                            PointVelocity               := _TempPointVelocity,      // at this Point in Cam Table\n                                                            PointAcceleration           := _TempPointAcceleration,  // at this Point in Cam Table\n                                                            PointJerk                   := _TempPointJerk,          // at this Point in Cam Table\n                                                            PointIndex                  := 3)                       // Index of Point in structure of ST_BasePoint      \n                        AND\n                        RobotKinematic.CamAddPointToPath(   MotionFunctionFirstPoint    := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5, \n                                                            MotionFunctionThisPoint     := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5, \n                                                            PointNumber                 := 5, \n                                                            TotalPointsInTable          := 5, // Minimum of 2 (Start Point + End Point), Start Point is automatically set by FB internally\n                                                            PointVelocity               := _TempPointVelocity,      // at this Point in Cam Table\n                                                            PointAcceleration           := _TempPointAcceleration,  // at this Point in Cam Table\n                                                            PointJerk                   := _TempPointJerk,          // at this Point in Cam Table\n                                                            PointIndex                  := 4)                       // Index of Point in structure of ST_BasePoint  \n                    THEN\n                        SequenceState := 10;    \n                    END_IF\n\n                10: // Check for Points added successfully \n                    IF NOT RobotKinematic.Error AND NOT RobotKinematic.Busy THEN\n                        SequenceState := 20;\n                    END_IF\n\n                20: // Cam In\n                    IF RobotKinematic.CamIn() THEN\n                        SequenceState := 30;\n                    END_IF\n\n                30: // Check Cammed In\n                    IF RobotKinematic.CammingActive AND NOT RobotKinematic.Error AND NOT RobotKinematic.Busy THEN\n                        SequenceState := 40;\n                    END_IF\n\n                40: // Start move Kinematic\n                    IF RobotKinematic.CamStartMovePath( TargetMoveVelocity      := Parameter_Kinematic.CamDefaultMoveVelocity, // Move Velocity for Cam Table Master !!!Needs to consider all Slave dynamics, all Slaves try to follow Master setpoints!!!\n                                                        TargetMoveAcceleration  := Parameter_Kinematic.CamDefaultMoveAcceleration, // Move Acceleration for Cam Table Master !!!Needs to consider all Slave dynamics, all Slaves try to follow Master setpoints!!!\n                                                        TargetMoveDeceleration  := Parameter_Kinematic.CamDefaultMoveDeceleration, // Move Deceleration for Cam Table Master !!!Needs to consider all Slave dynamics, all Slaves try to follow Master setpoints!!!\n                                                        TargetMoveJerk          := Parameter_Kinematic.CamDefaultMoveJerk ) \n                    THEN\n                        SequenceState := 50; \n                    END_IF\n\n                50: // Kinematic Moving or Done \n                    IF RobotKinematic.Moving OR ( NOT RobotKinematic.Error AND NOT RobotKinematic.Busy AND NOT RobotKinematic.Moving ) THEN\n                        SequenceState := 60;\n                    END_IF\n\n                60: // Move Complete    \n                    IF NOT RobotKinematic.Error AND NOT RobotKinematic.Busy AND NOT RobotKinematic.Moving THEN\n                        SequenceState := 70;\n                    END_IF\n\n                70: // Cam Out\n                    IF RobotKinematic.CamOut() THEN\n                        SequenceState := 80;\n                    END_IF\n\n                80: // Check Cammed Out\n                    IF NOT RobotKinematic.CammingActive AND NOT RobotKinematic.Error AND NOT RobotKinematic.Busy THEN\n                        SequenceState := 90;\n                    END_IF\n\n                90: // Clear Path\n                    IF RobotKinematic.CamClearPath() THEN\n                        SequenceState := 0; // Repeat Path\n                    END_IF\n\n                999: // Done\n                     ;\n            END_CASE\n</code></pre> Note <p>Point Management is done via recipe.  Not visible in this example. </p>"},{"location":"SPT_Kinematic/exampleCode.html#example-3-stop-and-shutdown-coordinated-motion-with-camming","title":"Example 3 - Stop and Shutdown Coordinated Motion with Camming","text":"<pre><code>            CASE SequenceState OF\n                0:  IF RobotKinematic.Moving THEN     // Kinematic Moving\n                        IF RobotKinematic.Stop(0,0) THEN\n                            SequenceState := 5;\n                        END_IF\n                    ELSE\n                        SequenceState := 10;\n                    END_IF\n\n                5: // Wait for not Moving\n                    IF NOT RobotKinematic.Moving AND NOT RobotKinematic.Busy THEN\n                        SequenceState := 10;\n                    END_IF\n\n                10: // Check for system Cammed \n                    IF RobotKinematic.CammingActive THEN\n                        IF RobotKinematic.CamOut() THEN\n                            SequenceState := 20;\n                        END_IF\n                    ELSE\n                        SequenceState := 20;\n                    END_IF\n\n                20: // Check for system Cammed Out\n                    IF NOT RobotKinematic.CammingActive AND NOT RobotKinematic.Error AND NOT RobotKinematic.Busy THEN\n                        SequenceState := 30;\n                    END_IF\n\n                30: // Disable ACS and MCS\n                    IF RobotKinematic.Disable() THEN\n                        SequenceState := 40;\n                    END_IF\n\n                40: // Wait for Disabled\n                    IF NOT RobotKinematic.Enabled THEN\n                        SequenceState := 999;\n                    END_IF\n\n                999:// Done\n            END_CASE\n</code></pre>"},{"location":"SPT_Kinematic/exampleCode.html#example-scope-for-camming","title":"Example Scope for Camming","text":""},{"location":"SPT_Kinematic/functionblocks.html","title":"Function Blocks","text":""},{"location":"SPT_Kinematic/functionblocks.html#fb_kinematicaxisref","title":"FB_KinematicAxisRef","text":"<p>(implements <code>I_KinematicAxisRef</code>)</p> <p>Serves as basis to connect Kinematic to all ACS and MCS Axis. The FB is prepared to DOF=6. Configured DOF needs to be set in Property <code>DegreesOfFreedomConfigured</code>. Default is DOF=6.</p> <p>This FB decouples the ACS and MCS Axis from the Kinematic. This way it is possible ot interchange the Kinematic Transformation Objects without PLC Restart. </p>"},{"location":"SPT_Kinematic/functionblocks.html#fb_kinematicgroup","title":"FB_KinematicGroup","text":"<p>(extends <code>FB_ComponentBase</code>, implements <code>I_KinematicGroup</code>)</p> <p>Serves as manager for all Kinematic Group functions. Requires to be linked to desired kinematic transformation object via <code>NCTOPLC_NCICHANNEL_REF</code> and <code>PLCTONC_NCICHANNEL_REF</code>.</p> <p>Info</p> <p>Kinematic State Diagram applies for this Functionblock. </p>"},{"location":"SPT_Kinematic/functionblocks.html#properties","title":"Properties","text":"Property Type Access Description KinematicAxisIds ST_KinAxes R/W Get/Set Kinematic Axis Ids corresponding ot ACS and MCS Axis Objects KinematicStatus E_KinStatus R Get the current Kinematic Object Status KinMetaInfo U_KinMetaInfo R/W Get/Set the current Kinematic Object Configuration for Forward Transformation iAxisRef I_KinematicAxisRef R/W Sets ACS and MCS Axes to Base Object from <code>FB_KinematicAxisRef</code> <p>Info</p> <p>You select the OID from the Kinematic in \u201cSymbol Initialization\u201d of the PLC instance. </p>"},{"location":"SPT_Kinematic/functionblocks.html#methods","title":"Methods","text":"Method Return Type Access Description BuildKinGroup BOOL Public Returns <code>TRUE</code> Command was accepted DissolveKinGroup BOOL Public Returns <code>TRUE</code> Command was accepted ResetKinGroup BOOL Public Returns <code>TRUE</code> Command was accepted CalcKinPosition BOOL Protected Returns <code>TRUE</code> Command was accepted SetKinematicParameter BOOL Public Returns <code>TRUE</code> Command was accepted, Sets Parameter for Kinematic Object via OID and PID for Tool and Kinematic PresetRotationExtRotationRange BOOL The function block FB_KinPresetRotation sets the rotational state. The rotational state is not persistent and must be reset after a TwinCAT restart or if a path is started after an ACS axis movement (direct mode) ActivateExtRotationRange BOOL Returns <code>TRUE</code> Command was accepted. Extends the rotation of the Kinematic Object to full circle. DeactivateExtRotationRange BOOL Returns <code>TRUE</code> Command was accepted. Resets rotation behavior back to default."},{"location":"SPT_Kinematic/functionblocks.html#buildkingroup","title":"BuildKinGroup()","text":"<p><code>METHOD PUBLIC BuildKinGroup : BOOL</code></p> <p>Executes the build of the Kinematic object. ACS and MCS Axis Ids from <code>KinematicAxisIds</code> are applied to the kinematic object selected.</p> <p>Target State is Cartesian mode. <code>E_KinStatus.KinStatus_Ready</code></p>"},{"location":"SPT_Kinematic/functionblocks.html#dissolvekingroup","title":"DissolveKinGroup()","text":"<p><code>METHOD PUBLIC DissolveKinGroup : BOOL</code></p> <p>If Kinematic Group is built, by executing this command, the Kinematic connection will be dissolved. ACS Axis will be standalone. </p> <p>Target State is Joint mode. <code>E_KinStatus.KinStatus_Empty</code></p>"},{"location":"SPT_Kinematic/functionblocks.html#resetkingroup","title":"ResetKinGroup()","text":"<p><code>METHOD PUBLIC ResetKinGroup : BOOL</code></p> <p>Reset Kinematic Group in case of <code>E_KinStatus.KinStatus_Error</code>. This function can also be used to transfer the Kinematic from <code>E_KinStatus.KinStatus_Pending</code> to <code>E_KinStatus.KinStatus_Ready</code> in case the Kinematic was not enabled at Build.</p>"},{"location":"SPT_Kinematic/functionblocks.html#calckinposition","title":"CalcKinPosition()","text":"<pre><code>METHOD PROTECTED CalcKinPosition : BOOL\nVAR_INPUT\n    ACS : ARRAY[1..8] OF LREAL;\nEND_VAR\nVAR_OUTPUT\n    MCS : ARRAY[1..8] OF LREAL;\nEND_VAR\n</code></pre> <p>Calculates 4 times per second the MCS positions based on the configured Kinematic transformation, the current ACS positions and <code>KinMetaInfo</code>. </p> <p>Warning</p> <p>To receive correct forward transformation positions <code>KinMetaInfo</code> applies for Scara and 5D Type Robots.</p>"},{"location":"SPT_Kinematic/functionblocks.html#setkinematicparameter","title":"SetKinematicParameter()","text":"<pre><code>METHOD SetKinematicParameter : BOOL\nVAR_INPUT\n    KinPTCID        : PTCID;\n    (* PTCID given is Tool PTCID, If False Parameter change is requested in main Kinematic Object*)\n    isToolPTCID     : BOOL;\n    Length          : UDINT;\n    Value           : PVOID;\nEND_VAR\n</code></pre> <p>Set individual Kinematic or Tool Parameter via the OID and PTCID in the Kinematic Object.  The PTCID can be found in the Parameter View of your Kinematic Object. </p> Example <pre><code>VAR_INST\n    _ChangeToolParameter : BOOL;\n    _ChangeKinParameter  : BOOL;\n    _Parameter           : LREAL;\nEND_VAR\n\nIF _ChangeToolParameter THEN\n    DeltaKinematic.SetKinematicParameter(   KinPTCID    := KINEMATIC_PTCID.PTCID_TOOL_X_OFFSET,\n                                            isToolPTCID := TRUE,\n                                            Len         := SIZEOF(_Parameter),\n                                            Value       := ADR(_Parameter));\n    _ChangeToolParameter := FALSE;\nEND_IF\nIF _ChangeKinParameter THEN\n    DeltaKinematic.SetKinematicParameter(   KinPTCID    := KINEMATIC_PTCID.DELTA_INNER_ARM_LENGTH,\n                                            isToolPTCID := FALSE,\n                                            Len         := SIZEOF(_Parameter),\n                                            Value       := ADR(_Parameter));\n    _ChangeKinParameter := FALSE;\nEND_IF\n</code></pre>"},{"location":"SPT_Kinematic/functionblocks.html#presetrotationextrotationrange","title":"PresetRotationExtRotationRange()","text":"<pre><code>METHOD PresetRotationExtRotationRange : BOOL\nVAR_INPUT\n    Rotation                            : ARRAY[1..3] OF LREAL; // Relates to 3 rotations availabe e.g. Rx, Ry, Rz.\nEND_VAR\n</code></pre> <p>Information to extended Rotation Range to find here.</p>"},{"location":"SPT_Kinematic/functionblocks.html#activateextrotationrange","title":"ActivateExtRotationRange()","text":"<p><code>METHOD ActivateExtRotationRange : BOOL</code></p> <p>Activates <code>FB_KinExtendedRotationRange</code>. It is required to set Rotation with <code>PresetRotationExtRotationRange()</code> before calling this Method.</p> <p>Information to extended Rotation Range to find here.</p>"},{"location":"SPT_Kinematic/functionblocks.html#deactivateextrotationrange","title":"DeactivateExtRotationRange()","text":"<p><code>METHOD DeactivateExtRotationRange : BOOL</code></p> <p>Deactivates extended rotation back to default of your Kinematic. </p>"},{"location":"SPT_Kinematic/functionblocks.html#fb_componentkinematicbase","title":"FB_ComponentKinematicBase","text":"<p>(extends <code>FB_KinematicGroup</code>, implements <code>I_Kinematic</code>)</p> <p>Serves as Functionblock for basic Robotic functions such as moving Joint Axis and Cartesian Axis. This FB also manages the correct implementation of the Kinematic Boot-up and Enabling sequence. </p> <p>Errors are indicated by the AdsError</p>"},{"location":"SPT_Kinematic/functionblocks.html#properties_1","title":"Properties","text":"Property Type Access Description ActPosition ST_KinematicPosition R Returns current position of ACS and MCS Drives Enabled BOOL R Returns <code>True</code> if the Robotic System is enabled InPosition BOOL R Returns <code>True</code> if the Robotic System is at Target Position with all its Axis Moving BOOL R Returns <code>True</code> if one or more Axis is moving. Limits are set in the NC Axis Object Override LREAL W Set Override for Robotic System TargetMotionParameter ST_KinematicMotionParameter R/W Get/Set the motion Parameter of ACS and MCS Axis (Acceleration, Deceleration, Jerk, Position) iAxisRef I_KinematicAxisRef W Set interface to Axis Reference Object. Direct access to ACS and MCS axis configured in Motion"},{"location":"SPT_Kinematic/functionblocks.html#methods_1","title":"Methods","text":"Method Return Type Access Description Disable BOOL Returns <code>TRUE</code> Command was accepted, Disables the Robotic System MC_Power Enable BOOL Returns <code>TRUE</code> Command was accepted, Enables the Robotic System ACS and MCS Axes MC_Power JogCartesianAxis BOOL Returns <code>TRUE</code> Command was accepted, Jogs one Cartesian Axis JogJoint BOOL Returns <code>TRUE</code> Command was accepted, Jogs one Joint Axis Stop BOOL Returns <code>TRUE</code> Command was accepted, Stops all movement of the Robotic System MoveToPointJoint BOOL Returns <code>TRUE</code> Command was accepted, Moves to target System in Joint Mode via the ACS system"},{"location":"SPT_Kinematic/functionblocks.html#disable","title":"Disable()","text":"<p><code>METHOD PUBLIC Disable : BOOL</code></p> <p>Disable all Axes connected to Kinematic Object.</p>"},{"location":"SPT_Kinematic/functionblocks.html#enable","title":"Enable()","text":"<p><code>METHOD PUBLIC Enable : BOOL</code></p> <p>Enable all Axes connected to Kinematic Object. Trigger run of Enabling sequence if Kinematic Group was built before Kinematic was disabled. </p>"},{"location":"SPT_Kinematic/functionblocks.html#jogcartesianaxis","title":"JogCartesianAxis()","text":"<pre><code>METHOD JogCartesianAxis : BOOL\nVAR_INPUT\n    Axisx       : UDINT(1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM);\n    Forward     : BOOL;\n    Backward    : BOOL;\n    JogMode     : E_JogMode;\nEND_VAR\n</code></pre> <p>Individual Job of Cartesian Axis. Possible Jog Modes are <code>E_JogMode.MC_JOGMODE_STANDARD_FAST</code> and <code>E_JogMode.MC_JOGMODE_STANDARD_SLOW</code>.</p>"},{"location":"SPT_Kinematic/functionblocks.html#jogjoint","title":"JogJoint()","text":"<pre><code>METHOD JogJoint : BOOL\nVAR_INPUT\n    Jointx      : UDINT(1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM);\n    Forward     : BOOL;\n    Backward    : BOOL;\n    JogMode     : E_JogMode;\nEND_VAR\n</code></pre> <p>Individual Job of Joint Axis. Possible Jog Modes are <code>E_JogMode.MC_JOGMODE_STANDARD_FAST</code> and <code>E_JogMode.MC_JOGMODE_STANDARD_SLOW</code>.</p>"},{"location":"SPT_Kinematic/functionblocks.html#stop","title":"Stop()","text":"<pre><code>METHOD PUBLIC Stop : BOOL\nVAR_INPUT\n    (*In Kinematic Base FB deceleration Input and Jerk input for Stop() are not used. \n    Intention is that for each of the possible 6 Axis a different Dcc and Dcc-Jerk might be possible.\n    If the Inputs are needed, the function can be overloaded and programmed as desired. *)\n    Deceleration : LREAL;\n    Jerk         : LREAL;\nEND_VAR\n</code></pre> <p>Immediate Stop of all movement. Stop-Parameter set in <code>TargetMotionParameter</code>.  If <code>TargetMotionParameter</code> Deceleration for specific axis is 0, default value from last command active is used according to <code>MC_Halt</code>.</p>"},{"location":"SPT_Kinematic/functionblocks.html#movetopointjoint","title":"MoveToPointJoint()","text":"<p><code>METHOD MoveToPointJoint : BOOL</code></p> <p>Moves ACS System to Target Position - implementation pending!</p>"},{"location":"SPT_Kinematic/functionblocks.html#fb_kinematicmotionampbase","title":"FB_KinematicMotionAmpBase","text":"<p>(extends <code>FB_BaseFB</code>, implements <code>I_KinematicCm</code>)</p> <p>Manages functions of TF5420 Advanced Motion Package Pick-Place. Functions as add-on to Kinematic Module for Cartesian Coordinated Movements for Robot Systems up to DOF=4.</p> <p>Follows AMP state diagram: </p>"},{"location":"SPT_Kinematic/functionblocks.html#properties_2","title":"Properties","text":"Property Type Access Description CmState ST_KinematicComponentAmp_CmGroupState R Get current state of coordinated motion Group CmIdentAxis1 IDENT_IN_GROUP_REF W Set allocation of Group axes to the depending cartesian Axis e.g. <code>MCS_X</code> CmIdentAxis2 IDENT_IN_GROUP_REF W Set allocation of Group axes to the depending cartesian Axis e.g. <code>MCS_Y</code> CmIdentAxis3 IDENT_IN_GROUP_REF W Set allocation of Group axes to the depending cartesian Axis e.g. <code>MCS_Z</code> CmIdentAxis4 IDENT_IN_GROUP_REF W Set allocation of Group axes to the depending cartesian Axis e.g. <code>MCS_C1</code> CmGroupRef AXES_GROUP_REF W Access to Coordinated Motion Group Instance CmAxisCount UDINT W Set connected Axis, defined by Kinematic DOF CmAxisRef REFERENCE TO ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX] OF AXIS_REF W Set Axis Reference for Advanced Motion Package to FB"},{"location":"SPT_Kinematic/functionblocks.html#methods_2","title":"Methods","text":"Method Return Type Description AddCircularMoveToPath BOOL Returns <code>TRUE</code> when the move was added -&gt; up to 30 adds per cycle possible AddLinearMoveToPath BOOL Returns <code>TRUE</code> when the move was added -&gt; up to 30 adds per cycle possible DisableCmGroup BOOL Returns <code>TRUE</code> Command was accepted, Disables the Kinematic Motion Group EnableCmGroup BOOL Returns <code>TRUE</code> Command was accepted, Enables the Kinematic Motion Group StartMovePath BOOL Returns <code>TRUE</code> Command was accepted, Starts the move of the prepared Path UngroupCmGroup BOOL Returns <code>TRUE</code> Command was accepted, Dissolves the Motion Group BuildCmGroup Bool Returns <code>TRUE</code> Command was accepted, Add all DOF Axis to the Motion Group ClearPath Bool Returns <code>TRUE</code> Command was accepted, Clears CM Path to prepare for next motion path Stop BOOL Returns <code>TRUE</code> Command was accepted, Stops movement of CM Group or MCS/ACS System depending on Group/Kinematic State SetOverride Bool Set Override for CM Group Reset Bool Reset of CM Group MapStatus ST_KinematicComponentAmp_CmGroupState CM-Status read and map to property <code>CmState</code> TrackConveyorBelt Bool Returns <code>TRUE</code> Command was accepted, activates the tracking of a linear movement in space e.g. Conveyor SetCoordinateTransform Bool Returns <code>TRUE</code> Command was accepted, add Coordinate Transformation to Cm Group"},{"location":"SPT_Kinematic/functionblocks.html#addcircularmovetopath","title":"AddCircularMoveToPath","text":"<pre><code>METHOD AddCircularMoveToPath : BOOL\nVAR_INPUT\n    AmpPoint : REFERENCE TO ST_AmpPoint;\nEND_VAR\n</code></pre> <p>Add a Circular Path segment to the Move-Path.</p> <p>Closer description to the Path Parameter can be found here: Parameter</p>"},{"location":"SPT_Kinematic/functionblocks.html#addlinearmovetopath","title":"AddLinearMoveToPath","text":"<pre><code>METHOD AddLinearMoveToPath : BOOL\nVAR_INPUT\n    AmpPoint : REFERENCE TO ST_AmpPoint;\nEND_VAR\n</code></pre> <p>Add a Linear Path segment to the Move-Path.</p> <p>Closer description to the Path Parameter can be found here: Parameter</p>"},{"location":"SPT_Kinematic/functionblocks.html#clearpath","title":"ClearPath","text":"<p><code>METHOD ClearPath : BOOL</code></p> <p>Clears all movement segments from path.</p>"},{"location":"SPT_Kinematic/functionblocks.html#startmovepath","title":"StartMovePath","text":"<pre><code>METHOD StartMovePath : BOOL\nVAR_INPUT\n    ChangePath : BOOL;\nEND_VAR\n</code></pre> <p>Executes the movement of the prepared path. If change of Path is required or new path needs to be started ChangePath = TRUE switches path. </p> <p>Second Path can be prepared while first Path is executed by calling <code>AddCircularMoveToPath</code> or <code>AddLinearMoveToPath</code>.</p>"},{"location":"SPT_Kinematic/functionblocks.html#disablecmgroup","title":"DisableCmGroup","text":"<p><code>METHOD DisableCmGroup : BOOL</code></p> <p>Following the State Diagram, the CM group will be disabled.</p>"},{"location":"SPT_Kinematic/functionblocks.html#enablecmgroup","title":"EnableCmGroup","text":"<p><code>METHOD EnableCmGroup : BOOL</code></p> <p>Following the State Diagram, the CM group will be enabled.</p>"},{"location":"SPT_Kinematic/functionblocks.html#ungroupcmgroup","title":"UngroupCmGroup","text":"<p><code>METHOD UngroupCmGroup : BOOL</code></p> <p>All Axis grouped to the CM Group will be released.</p>"},{"location":"SPT_Kinematic/functionblocks.html#buildcmgroup","title":"BuildCmGroup","text":"<p><code>METHOD PUBLIC BuildCmGroup : BOOL</code></p> <p>CM Group will be built with the associated Axis_Ref in <code>CmAxisRef</code>.</p>"},{"location":"SPT_Kinematic/functionblocks.html#trackconveyorbelt","title":"TrackConveyorBelt","text":"<pre><code>METHOD TrackConveyorBelt : BOOL\nVAR_INPUT\n    ObjectParameter : REFERENCE TO ST_AmpPoint;\n    MasterRefPos    : LREAL;\n    McCoordRef      : MC_COORD_REF;\nEND_VAR\n</code></pre> <p>Track Conveyor Belt Description</p> <p>Track Conveyor Belt Configuration</p> <p>Motion Parameter to start tracking are defined via the variables of ST_AmpPoint.</p>"},{"location":"SPT_Kinematic/functionblocks.html#setcoordinatetransform","title":"SetCoordinateTransform","text":"<pre><code>VAR_INPUT\n    McCoordRef : MC_COORD_REF;\nEND_VAR\n</code></pre> <p>Configuration</p>"},{"location":"SPT_Kinematic/functionblocks.html#fb_componentkinematicmotionamp","title":"FB_ComponentKinematicMotionAmp","text":"<p>(extends <code>FB_ComponentKinematicBase</code>, implements <code>I_KinematicCm</code>)</p> <p>Wrapper to integrate Basic Kinematic functions with <code>FB_KinematicMotionAmpBase</code> Extends functions for movement with Teach Point Management.</p>"},{"location":"SPT_Kinematic/functionblocks.html#properties_3","title":"Properties","text":"Property Type Access Description CmState ST_KinematicComponentAmp_CmGroupState R Get current state of coordinated motion Group CmIdentAxis1 IDENT_IN_GROUP_REF W Set allocation of Group axes to the depending cartesian Axis e.g. <code>MCS_X</code> CmIdentAxis2 IDENT_IN_GROUP_REF W Set allocation of Group axes to the depending cartesian Axis e.g. <code>MCS_Y</code> CmIdentAxis3 IDENT_IN_GROUP_REF W Set allocation of Group axes to the depending cartesian Axis e.g. <code>MCS_Z</code> CmIdentAxis4 IDENT_IN_GROUP_REF W Set allocation of Group axes to the depending cartesian Axis e.g. <code>MCS_C1</code> CmGroupRef AXES_GROUP_REF W Access to Coordinated Motion Group Instance ChangeOccurred BOOL R/W Change to one or more Points in Buffer has been detected. User can by this indication update the recipe. User needs to reset this variable to detect next change. Points REFERENCE TO ARRAY[0..Parameter_Kinematic.MaxPoints] OF ST_AmpPoint R/W Access to Point Buffer"},{"location":"SPT_Kinematic/functionblocks.html#methods_3","title":"Methods","text":"Method Return Type Description AddCircularMoveToPath BOOL Returns <code>TRUE</code> when the move was added -&gt; up to 30 adds per cycle possible AddLinearMoveToPath BOOL Returns <code>TRUE</code> when the move was added -&gt; up to 30 adds per cycle possible DisableCmGroup BOOL Returns <code>TRUE</code> Command was accepted, Disables the Kinematic Motion Group EnableCmGroup BOOL Returns <code>TRUE</code> Command was accepted, Enables the Kinematic Motion Group StartMovePath BOOL Returns <code>TRUE</code> Command was accepted, Starts the move of the prepared Path UngroupCmGroup BOOL Returns <code>TRUE</code> Command was accepted, Dissolves the Motion Group BuildCmGroup Bool Returns <code>TRUE</code> Command was accepted, Add all DOF Axis to the Motion Group ClearPath Bool Returns <code>TRUE</code> Command was accepted, Clears CM Path to prepare for next motion path Stop BOOL Returns <code>TRUE</code> Command was accepted, Stops movement of CM Group or MCS/ACS System depending on Group/Kinematic State TrackConveyorBelt Bool Returns <code>TRUE</code> Command was accepted, activates the tracking of a linear movement in space e.g. Conveyor SetCoordinateTransform Bool Returns <code>TRUE</code> Command was accepted, add Coordinate Transformation to Cm Group SetOverride Bool Set Override for CM Group Reset Bool Reset of CM Group MoveToPointCartesian BOOL Moves to one single selected point via AMP functions GetPoint ST_AmpPoint Get Point Values for selected Point Index SetPoint BOOL Set Point to Point input Value"},{"location":"SPT_Kinematic/functionblocks.html#addcircularmovetopath_1","title":"AddCircularMoveToPath","text":"<pre><code>METHOD AddCircularMoveToPath : BOOL\nVAR_INPUT\n    PointIndex : UDINT;\nEND_VAR\n</code></pre> <p>Add a Circular Path segment to the Move-Path. Index for Point is Point Buffer accessible via Property <code>Points</code>, max count of points determined by <code>Parameter_Kinematic.MaxPoints</code>.</p> <p>Closer description to the Path Parameter can be found here: Parameter</p>"},{"location":"SPT_Kinematic/functionblocks.html#addlinearmovetopath_1","title":"AddLinearMoveToPath","text":"<pre><code>METHOD AddLinearMoveToPath : BOOL\nVAR_INPUT\n    PointIndex : UDINT;\nEND_VAR\n</code></pre> <p>Add a Linear Path segment to the Move-Path. Index for Point is Point Buffer accessible via Property <code>Points</code>, max count of points determined by <code>Parameter_Kinematic.MaxPoints</code>.</p> <p>Closer description to the Path Parameter can be found here: Parameter</p>"},{"location":"SPT_Kinematic/functionblocks.html#fb_kinematiccamming","title":"FB_KinematicCamming","text":"<p>(Extends <code>FB_CyclicFB</code> implements <code>I_KinematicCamming</code>)</p> <p>This FB provides the basic functionality for MC_Camming to move an axes system via cam tables. It implements and uses TF5050.</p>"},{"location":"SPT_Kinematic/functionblocks.html#properties_4","title":"Properties","text":"Property Type Access Description CammingActive BOOL R Connected Axes System is Cammed in to Cam Table CamAxisCount UDINT W Sets the amount of axes connected to the FB. Relates directly to the DOF of the Kinematic System CamAxisRef REFERENCE TO ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX] OF AXIS_REF R/W References the selected Axes of the Kinematic System CamMaster REFERENCE TO AXIS_REF R References the Cam Master Axis CamInOptions ST_CamInOptions R/W Set options for CamIn CamTableSlaveDynamics ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX] OF ST_CamTableSlaveDynamics R Slave dynamics read with <code>ReadCamTableSlaveDynamics()</code>"},{"location":"SPT_Kinematic/functionblocks.html#methods_4","title":"Methods","text":"Method Return Type Description CamClearPath BOOL Returns <code>TRUE</code> Command was accepted, Delete preset Cam Table Points CamIn BOOL Returns <code>TRUE</code> Command was accepted, Cam In connected axes to cam table CamOut BOOL Returns <code>TRUE</code> Command was accepted, Cam Out connected axes from cam table CamStartMovePath BOOL Returns <code>TRUE</code> Command was accepted, Delete preset Cam Table Points CamAddPointToPath BOOL Returns <code>TRUE</code> Command was accepted, this function will add one Point to the executing Cam Table CamAddMotionPointByAxis BOOL Returns <code>TRUE</code> Command was accepted, this function will add one Point to the executing Cam Table Disable BOOL Returns <code>TRUE</code> Command was accepted, this function will disable the Cam Virtual Master along with the Cammed In Slave Drives Enable BOOL Returns <code>TRUE</code> Command was accepted, this function will enable the Cam Virtual Master along with the Cammed In Slave Drives Reset BOOL Returns <code>TRUE</code> Command was accepted, this function will reset the Cam Virtual Master along with the Cammed In Slave Drives SetOverride BOOL Returns <code>TRUE</code> Command was accepted, Sets the override for the Virtual Master and therefore for the Cam Table movement Stop BOOL Returns <code>TRUE</code> Command was accepted, Stops all movement ReadCamTableSlaveDynamics BOOL Returns <code>TRUE</code> Reads the cam table slave dynamics at the Master Position and saves it in Property <code>CamTableSlaveDynamics</code>"},{"location":"SPT_Kinematic/functionblocks.html#camaddpointtopath","title":"CamAddPointToPath()","text":"<pre><code>METHOD CamAddPointToPath : BOOL\nVAR_INPUT\n    MotionFunctionFirstPoint : MC_MotionFunctionType := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5; // Motion Function Type of initial Point in Cam Table. Start Postion is defined by current Positon of Axes.\n    MotionFunctionThisPoint  : MC_MotionFunctionType := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5; // Motion Function Type of this Point to be added to Cam-Table\n    PointNumber              : UDINT(2..Parameter_Kinematic.MaxCammingPositionsPerTable); // Number of Point to be added to Cam Table, must be strictly increasing without gaps\n    TotalPointsInTable       : UDINT(2..Parameter_Kinematic.MaxCammingPositionsPerTable); // Total Number of Points in final Cam Table\n    Point                    : ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX] OF LREAL; // Slave Position at this Point in Cam Table\n    PointVelocity            : ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX] OF LREAL; // Slave Velocity at this Point in Cam Table\n    PointAcceleration        : ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX] OF LREAL; // Slave Acceleration at this Point in Cam Table\n    PointJerk                : ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX] OF LREAL; // Slave Jerk at this Point in Cam Table\nEND_VAR\n</code></pre> <p>Adds one Point to the cam table. Start Point in Table is always defined by the current position of the System. Subsequent added destination Points defined by the input values will be added to the cam table. Before starting to add points it needs to be clear by setting <code>TotalPointsInTable</code> to the final point number. </p> <p>The cam table will be built when <code>TotalPointsInTable</code> equals <code>PointNumber</code>, when last point was successfully added. </p> <p>As user the Motion Function of each point can be defined. This can be dangerous as it defines how the system moves! Read TF5050 carefully -&gt; MC_MotionFunctionType</p> <p>The start point is always defined. With <code>MotionFunctionFirstPoint</code> the motion function of the first point can be influenced. </p> <p>As default motion function <code>MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5</code> is recommended. Each point starts and ends with velocity zero.</p> <p>In case velocity/acceleration/deceleration is desired to be unequal zero, use PointVelocity,PointAcceleration and PointJerk to influence the derivatives of the velocity in this point of the cam table. </p>"},{"location":"SPT_Kinematic/functionblocks.html#camaddmotionpointbyaxis","title":"CamAddMotionPointByAxis()","text":"<pre><code>METHOD CamAddMotionPointByAxis : BOOL\nVAR_INPUT\n    Axis                     : UDINT(1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX);                   // Axis Number to add point to Cam table\n    MotionFunctionFirstPoint : MC_MotionFunctionType := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5; // Motion Function Type of initial Point in Cam Table. Start Postion is defined by current Positon of Axes.\n    MotionFunctionThisPoint  : MC_MotionFunctionType := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5; // Motion Function Type of this Point to be added to Cam-Table\n    PointNumber              : UDINT(1..Parameter_Kinematic.MaxCammingPositionsPerTable);              // Number of Point to be added to Cam Table, must be strictly increasing without gaps\n    TotalPointsInTable       : UDINT(2..Parameter_Kinematic.MaxCammingPositionsPerTable);              // Total Number of Points in final Cam Table\n    MasterPosition           : LREAL;                                                                  // Master Position for this Motion Point scaled to 1\n    SlavePosition            : LREAL;                                                                  // Slave Position at this Point in Cam Table\n    PointVelocity            : LREAL;                                                                  // Slave Velocity at this Point in Cam Table\n    PointAcceleration        : LREAL;                                                                  // Slave Acceleration at this Point in Cam Table\n    PointJerk                : LREAL;                                                                  // Slave Jerk at this Point in Cam Table\nEND_VAR\n</code></pre> <p><code>CamAddMotionPointByAxis()</code> differentiates from <code>CamAddPointToPath()</code> that it can create a cam table by Axis. </p> <p>With Parameter <code>CammingFirstPointInTableByUser</code> equals <code>TRUE</code> the first point in Cam table can be changed from Cam Master starting position to user defined. Therefore use <code>CamAddMotionPointByAxis()</code> to set Point 1 to the desired Master and Slave Position by Axis.</p> <p>The scaling of the Master is defined by 0.0 to 1.0 (no unit). Within this range for each Axis one cam table can be created with variable Point count <code>PointNumber</code>.</p> <p><code>CamAddPointToPath()</code> evenly divides the Master range 0.0 to 1.0 by the number of points <code>TotalPointsInTable()</code>. With <code>CamAddMotionPointByAxis()</code> the user must create the relationship between Master Positions and slave Positions by axis. The <code>TotalPointsInTable</code> is by Axis in <code>CamAddMotionPointByAxis()</code>.</p>"},{"location":"SPT_Kinematic/functionblocks.html#camin","title":"CamIn()","text":"<p><code>METHOD CamIn : BOOL</code></p> <p>Cam in Axes system from <code>CamAxisRef</code> to created Cam Tables.</p>"},{"location":"SPT_Kinematic/functionblocks.html#camstartmovepath","title":"CamStartMovePath()","text":"<pre><code>METHOD CamStartMovePath : BOOL\nVAR_INPUT\n    TargetMoveVelocity      : LREAL := Parameter_Kinematic.CamDefaultMoveVelocity; // Move Velocity for Cam Table Master !!!Needs to consider all Slave dynamics, all Slaves try to follow Master setpoints!!!\n    TargetMoveAcceleration  : LREAL := Parameter_Kinematic.CamDefaultMoveAcceleration; // Move Acceleration for Cam Table Master !!!Needs to consider all Slave dynamics, all Slaves try to follow Master setpoints!!!\n    TargetMoveDeceleration  : LREAL := Parameter_Kinematic.CamDefaultMoveDeceleration; // Move Deceleration for Cam Table Master !!!Needs to consider all Slave dynamics, all Slaves try to follow Master setpoints!!!\n    TargetMoveJerk          : LREAL := Parameter_Kinematic.CamDefaultMoveJerk; // Move Jerk for Cam Table Master !!!Needs to consider all Slave dynamics, all Slaves try to follow Master setpoints!!!\nEND_VAR\n</code></pre> <p>Move created Cam Table with the given motion parameter inputs of this method. The default values of Parameter_Kinematic can be used.</p> <p>All associated axes via <code>CamAxisRef</code> will try to follow the motion inputs of this method. It will result in a motion fault if they are selected incorrectly. E.g. if acceleration can not be achieved by one or more physical axes. </p>"},{"location":"SPT_Kinematic/functionblocks.html#camout","title":"CamOut ()","text":"<p><code>METHOD CamOut : BOOL</code></p> <p>Cam out Axes <code>CamAxisRef</code> system from Cam Tables.</p>"},{"location":"SPT_Kinematic/functionblocks.html#camclearpath","title":"CamClearPath()","text":"<p><code>METHOD CamClearPath : BOOL</code></p> <p>Clears cam table points set with <code>CamAddPointToPath()</code>.</p>"},{"location":"SPT_Kinematic/functionblocks.html#fb_componentkinematicmotioncamming","title":"FB_ComponentKinematicMotionCamming","text":"<p>(Extends <code>FB_ComponentKinematicBase</code> implements <code>I_KinematicCamming</code>)</p> <p>Functions as add-on to Kinematic Module for Joint and Cartesian Coordinated Movements in Robot Systems up to DOF=6. It uses the functions of Camming to create Cam Tables for movement paths and therefore enables coordinated movement for axes systems.</p> Warning <p>Selecting Cam Table Motion profile is fully accessible by the user and can lead to dangerous behavior of the Robotic System. Read TF5050 Documentation carefully!</p>"},{"location":"SPT_Kinematic/functionblocks.html#properties_5","title":"Properties","text":"Property Type Access Description CammingActive BOOL R Connected Axes System is Cammed in to Cam Table CamAxisCount UDINT W Sets the amount of axes connected to the FB. Relates directly to the DOF of the Kinematic System CamAxisRef REFERENCE TO ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX] OF AXIS_REF R/W References the selected Axes of the Kinematic System Points REFERENCE TO ARRAY[0..Parameter_Kinematic.MaxPoints] OF ST_BasePoint R/W Access to Point Buffer ChangeOccurred BOOL R/W Change to one or more Points in Buffer has been detected. User can by this indication update the recipe. User needs to reset this variable to detect next change. CamMasterAcs REFERENCE TO AXIS_REF R References the Cam Master Axis for ACS CamMasterMcs REFERENCE TO AXIS_REF R References the Cam Master Axis for MCS CamInOptionsACS ST_CamInOptions R/W Set options for CamIn ACS CamInOptionsMCS ST_CamInOptions R/W Set options for CamIn MCS CamTableSlaveDynamicsACS ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX] OF ST_CamTableSlaveDynamics R Slave dynamics read with <code>ReadCamTableSlaveDynamicsACS()</code> CamTableSlaveDynamicsMCS ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX] OF ST_CamTableSlaveDynamics R Slave dynamics read with <code>ReadCamTableSlaveDynamicsMCS()</code>"},{"location":"SPT_Kinematic/functionblocks.html#methods_5","title":"Methods","text":"Method Return Type Description CamClearPath BOOL Returns <code>TRUE</code> Command was accepted, Delete preset Cam Table Points CamIn BOOL Returns <code>TRUE</code> Command was accepted, Cam In connected axes to cam table CamOut BOOL Returns <code>TRUE</code> Command was accepted, Cam Out connected axes from cam table CamStartMovePath BOOL Returns <code>TRUE</code> Command was accepted, Delete preset Cam Table Points CamAddPointToPath BOOL Returns <code>TRUE</code> Command was accepted, this function will add one Point to the executing Cam Table CamAddMotionPointByAxis BOOL Returns <code>TRUE</code> Command was accepted, this function will add one Point to the executing Cam Table Disable BOOL Returns <code>TRUE</code> Command was accepted, Enable BOOL Returns <code>TRUE</code> Command was accepted, Reset BOOL Returns <code>TRUE</code> Command was accepted, SetOverride BOOL Returns <code>TRUE</code> Command was accepted, Stop BOOL Returns <code>TRUE</code> Command was accepted, GetPoint ST_BasePoint Get Point Values for selected Point Index SetPoint BOOL Set Point to Point input Value ReadCamTableSlaveDynamicsACS BOOL Returns <code>TRUE</code> Reads the cam table slave dynamics at the Master Position and saves it in Property <code>CamTableSlaveDynamicsACS</code> ReadCamTableSlaveDynamicsMCS BOOL Returns <code>TRUE</code> Reads the cam table slave dynamics at the Master Position and saves it in Property <code>CamTableSlaveDynamicsMCS</code> <p>Warning</p> <p>For description of this Methods see FB_KinematicCamming The implementation of those methods distinct between ACS (Joint Mode) and MCS (Cartesian Mode).</p> <p>Take for example CamIn. If the Kinematic System is in Cartesian Mode, it will CamIn the MCS axes to the cam table. If the Kinematic System is in Joint Mode it will Cam In the ACS axes and execute the movements on the ACS level.</p> <p>It is important to select the Joint Mode or Cartesian Mode before building the Points and execute the Cam In along with Start Move Path.</p>"},{"location":"SPT_Kinematic/globals.html","title":"Globals/Parameters","text":""},{"location":"SPT_Kinematic/globals.html#parameters","title":"Parameters","text":""},{"location":"SPT_Kinematic/globals.html#parameter_kinematic","title":"Parameter_Kinematic","text":"Parameter Type Default Description PathBufferSize DINT 4096 Byte Buffer for AMP Movement Path <code>MC_PATH_DATA_REF</code> MaxPoints UDINT 10 Maximum amount of Teach-Points for Kinematic Advanced Motion. DefaultStopDeceleration Lreal 1000 Deceleration in mm/s^2 or deg/s^2 depending on Axis used for default at Stop commands DefaultStopDecelerationJerk Lreal 10000 Jerk in mm/s^2 or deg/s^2 depending on Axis used for default at Stop commands CamDefaultMoveVelocity LREAL 100 Default Camming Master Velocity, this Velocity is used in manual mode CamDefaultMoveAcceleration LREAL 1000 Default Camming Master Acceleration, this Acceleration is used in manual mode CamDefaultMoveDeceleration LREAL 1000 Default Camming Master Deceleration, this Deceleration is used in manual mode CamDefaultMoveJerk LREAL 10000 Default Camming Master Jerk, this Jerk is used in manual mode ExecuteCamPeriodically Bool FALSE Used in Camming FBs to execute created cam table cyclically if set to <code>TRUE</code> CamMasterAbsolute Bool TRUE Cam Master Position is interpreted absolute CamSlaveAbsolute Bool TRUE Cam Slave Position is interpreted absolute CammingFirstPointInTableByUser Bool FALSE First Point in created cam table is defined by user"},{"location":"SPT_Kinematic/globals.html#gvls","title":"GVLs","text":""},{"location":"SPT_Kinematic/globals.html#kinematic_constants","title":"KINEMATIC_CONSTANTS","text":"<pre><code>{attribute 'qualified_only'}\nVAR_GLOBAL CONSTANT\n    DEGREES_OF_FREEDOM_MAX                          : UINT := (TO_UINT(E_KinematicDOF.eKinematicDOF_Max)-1);\nEND_VAR\n</code></pre>"},{"location":"SPT_Kinematic/interfaces.html","title":"Interfaces","text":""},{"location":"SPT_Kinematic/interfaces.html#i_kinematicaxisref","title":"I_KinematicAxisRef","text":"<p>Interface to access connection to ACS and MCS Axis Objects.</p>"},{"location":"SPT_Kinematic/interfaces.html#properties","title":"Properties","text":"Property Type Access Description ACS REFERENCE TO ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX] OF AXIS_REF Ref MCS REFERENCE TO ARRAY[1..KINEMATIC_CONSTANTS.DEGREES_OF_FREEDOM_MAX] OF AXIS_REF Ref DegreesOfFreedomConfigured E_KinematicDOF R/W Configure the Kinematic assigned, e.g. DOF=3= Delta Robot AcsAxisCount BOOL R/W Specifies the amount of ACX Axes on Kinematic. AcsPositionAbsolute BOOL R/W Interpretation of ACS Axes is absolute."},{"location":"SPT_Kinematic/interfaces.html#i_kinematicgroup","title":"I_KinematicGroup","text":"<p>The Kinematic Group manages the basic function of the Kinematic Transformations Library. It builds and manipulates the Kinematic Object.</p>"},{"location":"SPT_Kinematic/interfaces.html#properties_1","title":"Properties","text":"Property Type Access Description KinematicStatus E_KinStatus R Get the current Kinematic Object Status KinMetaInfo U_KinMetaInfo R/W Get/Set the current Kinematic Object Configuration for Forward Transformation OidKinTrafo OTCID R Object Id of Kinematic Group"},{"location":"SPT_Kinematic/interfaces.html#methods","title":"Methods","text":"Method Return Type Description BuildKinGroup BOOL Returns <code>TRUE</code> Command was accepted, Builds and configures the Kinematic Group DissolveKinGroup BOOL Returns <code>TRUE</code> Command was accepted, Dissolves the built Kinematic Group ResetKinGroup BOOL Returns <code>TRUE</code> Command was accepted, Resets the Kinematic Group SetKinematicParameter BOOL Returns <code>TRUE</code> Command was accepted, Sets Parameter for Kinematic Object via OID and PID for Tool and Kinematic PresetRotationExtRotationRange BOOL The function block FB_KinPresetRotation sets the rotational state. The rotational state is not persistent and must be reset after a TwinCAT restart or if a path is started after an ACS axis movement (direct mode) ActivateExtRotationRange BOOL Returns <code>TRUE</code> Command was accepted. Extends the rotation of the Kinematic Object to full circle. DeactivateExtRotationRange BOOL Returns <code>TRUE</code> Command was accepted. Resets rotation behavior back to default."},{"location":"SPT_Kinematic/interfaces.html#i_kinematic","title":"I_Kinematic","text":"<p>Interface implements basic robotic functions for the Kinematic Object.</p>"},{"location":"SPT_Kinematic/interfaces.html#properties_2","title":"Properties","text":"Property Type Access Description ActPosition ST_KinematicPosition R Returns current position of ACS and MCS Drives Enabled BOOL R Returns <code>True</code> if the Robotic System is enabled InPosition BOOL R Returns <code>True</code> if the Robotic System is at Target Position with all its Axis Moving BOOL R Returns <code>True</code> if one or more Axis is moving. Limits are set in the NC Axis Object Override LREAL W Set Override for Robotic System TargetMotionParameter ST_KinematicMotionParameter R/W Get/Set the motion Parameter of ACS and MCS Axis (Acceleration, Deceleration, Jerk, Position)"},{"location":"SPT_Kinematic/interfaces.html#methods_1","title":"Methods","text":"Method Return Type Description Disable BOOL Returns <code>TRUE</code> Command was accepted, Disables the Robotic System MC_Power Enable BOOL Returns <code>TRUE</code> Command was accepted, Enables the Robotic System ACS and MCS Axes MC_Power JogCartesianAxis BOOL Returns <code>TRUE</code> Command was accepted, Jogs one Cartesian Axis JogJoint BOOL Returns <code>TRUE</code> Command was accepted, Jogs one Joint Axis Stop BOOL Returns <code>TRUE</code> Command was accepted, Stops all movement of the Robotic System"},{"location":"SPT_Kinematic/interfaces.html#i_kinematiccm","title":"I_KinematicCm","text":"<p>Interface Implements Coordinated Motion functions.</p>"},{"location":"SPT_Kinematic/interfaces.html#properties_3","title":"Properties","text":"Property Type Access Description CmState ST_KinematicComponentAmp_CmGroupState R Get current state of coordinated motion Group CmIdentAxis1 IDENT_IN_GROUP_REF W Set allocation of Group axes to the depending cartesian Axis e.g. <code>MCS_X</code> CmIdentAxis2 IDENT_IN_GROUP_REF W Set allocation of Group axes to the depending cartesian Axis e.g. <code>MCS_Y</code> CmIdentAxis3 IDENT_IN_GROUP_REF W Set allocation of Group axes to the depending cartesian Axis e.g. <code>MCS_Z</code> CmIdentAxis4 IDENT_IN_GROUP_REF W Set allocation of Group axes to the depending cartesian Axis e.g. <code>MCS_C1</code> CmGroupRef AXES_GROUP_REF W Access to Coordinated Motion Group Instance"},{"location":"SPT_Kinematic/interfaces.html#methods_2","title":"Methods","text":"Method Return Type Description DisableCmGroup BOOL Returns <code>TRUE</code> Command was accepted, Disables the Kinematic Motion Group EnableCmGroup BOOL Returns <code>TRUE</code> Command was accepted, Enables the Kinematic Motion Group StartMovePath BOOL Returns <code>TRUE</code> Command was accepted, Starts the move of the prepared Path UngroupCmGroup BOOL Returns <code>TRUE</code> Command was accepted, Dissolves the Motion Group BuildCmGroup Bool Returns <code>TRUE</code> Command was accepted, Add all DOF Axis to the Motion Group ClearPath Bool Returns <code>TRUE</code> Command was accepted, Clears CM Path to prepare for next motion path TrackConveyorBelt Bool Returns <code>TRUE</code> Command was accepted, activates the tracking of a linear movement in space e.g. Conveyor SetCoordinateTransform Bool Returns <code>TRUE</code> Command was accepted, add Coordinate Transformation to Cm Group"},{"location":"SPT_Kinematic/interfaces.html#i_kinematiccamming","title":"I_KinematicCamming","text":"<p>Interface to implement all Cam Table related functions.</p>"},{"location":"SPT_Kinematic/interfaces.html#properties_4","title":"Properties","text":"Property Type Access Description CammingActive BOOL R Connected Axes System is Cammed in to Cam Table"},{"location":"SPT_Kinematic/interfaces.html#methods_3","title":"Methods","text":"Method Return Type Description CamClearPath BOOL Returns <code>TRUE</code> Command was accepted, Delete preset Cam Table Points CamIn BOOL Returns <code>TRUE</code> Command was accepted, Cam In connected axes to cam table CamOut BOOL Returns <code>TRUE</code> Command was accepted, Cam Out connected axes from cam table CamStartMovePath BOOL Returns <code>TRUE</code> Command was accepted, Delete preset Cam Table Points CamMasterZero BOOL Returns <code>TRUE</code> Command was accepted, With this Method the Cam Master can be set to 0.0 Position, needed when cyclic use of cam table"},{"location":"SPT_Kinematic/quickstart.html","title":"QuickStart","text":""},{"location":"SPT_Kinematic/quickstart.html#initial-setup","title":"Initial Setup","text":"<p>This manual requires a basic understanding of the SPT-Library functions. To utilize the SPT_Kinematic library, the Beckhoff Advanced Motion Package needs to be installed. The package is included in the below linked installer for Advanced Motion.</p> <p>Advanced Motion Package Download</p> <p>Note</p> <p>Kinematic transformation available up to L3. L4 which contains more than 4 Axis is available via your Beckhoff Sales contact upon request and Project.</p>"},{"location":"SPT_Kinematic/quickstart.html#step-by-step-setup","title":"Step By Step setup","text":""},{"location":"SPT_Kinematic/quickstart.html#1-add-the-required-libraries-to-an-spt-base-project","title":"1. Add the required Libraries to an SPT base project","text":"<p>After the installation of the Advanced Motion Package, open an empty base project with the SPT framework.  Add the <code>SPT Kinematics</code> library along with the <code>Tc3_McCoordinatedMotion</code> and <code>Tc2_NcKinematicTransformation</code> libraries to the project. </p> <p>IF the <code>FB_ComponentKinematicMotionCamming</code> is used, add <code>Tc2_MC2_Camming</code>.</p>"},{"location":"SPT_Kinematic/quickstart.html#2-add-a-desired-kinematic-to-the-project","title":"2. Add a desired Kinematic to the project","text":"<p>Add an NC-Channel for the Kinematic transformation to your project.</p> <p>Note</p> <p>The following pictures function as an example of how to implement a specific Kinematic, adjustment is needed if a different Kinematic is desired.</p> <p></p> <p>Add the desired Kinematic to the new NC-Channel that was added to your project. </p>"},{"location":"SPT_Kinematic/quickstart.html#3-insert-a-coordinated-motion-group-into-your-project-only-if-advanced-motion-is-used-fb_componentkinematicmotionamp","title":"3. Insert a Coordinated Motion Group into your project (only if Advanced Motion is used -&gt; <code>FB_ComponentKinematicMotionAmp</code>)","text":"<p>Verify the Coordinated Motion Group configuration matches the configuration of the Kinematic! </p>"},{"location":"SPT_Kinematic/quickstart.html#4-add-the-required-nc-axes-to-the-project","title":"4. Add the required NC Axes to the project","text":"<p>Add the appropriate number of ACS(Physical axes) and MCS(virtual axes) to your motion project. Organization in folders is recommended for the ACS and MCS axes.</p> <p></p> <p>Set this functions to <code>True</code> on all Axes: </p>"},{"location":"SPT_Kinematic/quickstart.html#5-create-a-component-of-fb_componentkinematicmotionamp-or-one-of-the-other-kinematic-fbs-available-eg-fb_componentkinematicmotioncamming","title":"5. Create a Component of <code>FB_ComponentKinematicMotionAmp</code> or one of the other Kinematic FBs available. E.g <code>FB_ComponentKinematicMotionCamming</code>","text":"<p>Create the component instance in the desired EM or Machine of the SPT Framework.</p> <p>Create an instance of FB_KinematicAxisRef to define the desired Degrees of Freedom. E.g. 3D-Delta Type 1 (P_3C) = <code>E_KinematicDOF.eKinematicDOF_3</code> This object will be passed to the <code>FB_ComponentKinematicMotionAmp</code> or <code>FB_ComponentKinematicMotionCamming</code> via parameter iAxisRef.</p> <p>Add the OID from the Kinematic object to the PLC Instance, also add a Tool OID if a Tool is used: </p>"},{"location":"SPT_Kinematic/quickstart.html#6-define-the-cartesian-coordinate-system-only-if-fb_componentkinematicmotionamp-is-used","title":"6. Define the Cartesian Coordinate System (only if <code>FB_ComponentKinematicMotionAmp</code> is used)","text":"<p>When using the Advanced Motion Package, the identification of the axes in the Cartesian system needs to be defined.  The parameters cmIdentAxis1, cmIdentAxis2, and cmIdentAxis3 of 'FB_ComponentKinematicMotionAmp' are assigned the constants MCS_X, MCS_Y, and MCS_Z respectively.  These constants are defined in the library <code>Tc3_McCoordinatedMotion</code>.</p> <p>FB_KinematicAxisRef creates an array of AXIS_REF objects in the PLC instance to link the MCS and ACS axes.  In the MCS array, McsAxis[1] corresponds to the Cartesian X axis, McsAxis[2] is the Y axis, and McsAxis[3] is the Z axis.</p> <p>You can find more to this definition here under IDENT_IN_GROUP_REF.</p> <p></p>"},{"location":"SPT_Kinematic/quickstart.html#7-camming-coordinated-joint-and-cartesian-movements","title":"7. Camming - Coordinated Joint and Cartesian Movements","text":"<p>This FB <code>FB_ComponentKinematicMotionCamming</code> can be used for all Kinematics offered by Beckhoff Kinematic Package with the SPT Framework. DOF=2 up to DOF=6.</p> <p>Declaration example for <code>FB_ComponentKinematicMotionCamming</code>: </p> <p>For Camming to ACS and MCS, each a Virtual Master needs to be added and linked to <code>FB_ComponentKinematicMotionCamming</code>. </p>"},{"location":"SPT_Kinematic/quickstart.html#8-link-nc-axes-and-kinematic-objects-to-the-plc-instance-objects-created-by-fb_componentkinematicmotionamp-or-fb_componentkinematicmotioncamming","title":"8. Link NC axes and Kinematic objects to the PLC Instance Objects created by <code>FB_ComponentKinematicMotionAmp</code> or <code>FB_ComponentKinematicMotionCamming</code>.","text":""},{"location":"SPT_Kinematic/quickstart.html#9-add-connections-to-spt-hmi-template","title":"9. Add Connections to SPT-HMI Template","text":"<p>Example HMIs are in the <code>SPT_BASE_HMI</code> to find. </p> <p>Use the following Templates for specific use:</p> <p><code>KinematicAmp_Monitor</code>: Used for <code>FB_ComponentKinematicMotionAmp</code>. Includes Status Overview, Jogging, Basic Point Teaching and AMP point movements. Setup for up to DOF=4</p> <p><code>Kinematic_Monitor</code>: Used for <code>FB_ComponentKinematicMotionCamming</code>. Includes Status Overview, Jogging, Basic Point Teaching and Coordinated movements via Camming (ACS and MCS). Setup for up to DOF=6.</p> <p><code>Kinematic_Monitor_Navigation</code>: Monitor for above named components in main overview page.</p> <p>The HMI examples allow basic full control over the Kinematic Objects. Modification for specific applications is encouraged. </p> Custom HMI <p>The final Hmi Structures have pre-held variables for user implementations. By overloading <code>HMICommunication();</code> in an extension you can set <code>KinematicComponentCam_HMI.Config.CustomOverride</code> to <code>True</code> and override all functions available in <code>KinematicComponentCam_HMI</code> or <code>KinematicComponentAmp_HMI</code>. Use <code>KinematicComponentCam_HMI.Config.CustomCommand</code> for all you custom commands.</p> Example HMI <p> </p> <p>Congratulations! You can now Enable and Jog your Kinematic via the Template HMI locally on your PC.</p>"},{"location":"SPT_MotionControl/index.html","title":"Overview","text":"<p>General-purpose NC axis wrapper function blocks.  This function block can be used without any PackML-related functions and does not by itself implement any of the component model interfaces.  Use FB_Component_BasicAxis, FB_Component_BasicSlaveAxis, FB_Component_CamSlaveAxisfor PackML-based projects.</p>"},{"location":"SPT_MotionControl/index.html#class-diagram","title":"Class Diagram","text":""},{"location":"SPT_MotionControl/index.html#basic-axis","title":"Basic Axis","text":"<pre><code>classDiagram\n\n    I_CyclicFB --|&gt; I_BaseFB\n    FB_BaseFB ..|&gt; I_BaseFB    \n    FB_CyclicFB --|&gt; FB_BaseFB\n    FB_CyclicFB ..|&gt; I_CyclicFB\n\n    I_BasicAxis --|&gt; I_CyclicFB   \n    I_BasicAxis --o I_MotionSequence\n    I_MotionSequence --o I_BasicAxis\n\n    I_MotionSequence --|&gt; I_BaseFB\n\n    FB_BasicAxis --|&gt; FB_CyclicFB\n    FB_BasicAxis ..|&gt; I_BasicAxis\n\n\n    class I_BasicAxis{\n        &lt;&lt;Interface&gt;&gt;\n        +LREAL Acceleration\n        +LREAL Deceleration\n        +LREAL Velocity\n        +LREAL Jerk\n        +LREAL ActualAcceleration\n        +LREAL ActualPosition\n        +LREAL ActualPositionModulo\n        +LREAL ActualTorque\n        +LREAL ActualVelocity\n        +LREAL PositionLag\n        +LREAL SetAcceleration\n        +LREAL SetPosition\n        +LREAL SetPositionModulo\n        +LREAL SetVelocity\n        +BOOL Enabled\n        +BOOL InPosition\n        +BOOL Stopped\n        +LREAL Override\n        +REFERENCE TO AXIS_REF Axis\n        +I_MotionSequence HomeMethod\n        +I_MotionSequence ResetMethod\n        +BOOL Disable()\n        +BOOL Enable()\n        +BOOL Home()\n        +BOOL Jog(BOOL JogFW, BOOL JogBW, E_JogMode JogMode, LREAL Position)\n        +BOOL MoveAbsolute(LREAL Position, BOOL AbortPrevious)\n        +BOOL MoveModulo(LREAL Position, MC_Direction Direction, BOOL AbortPrevious)\n        +BOOL MoveRelative(LREAL Distance, BOOL AbortPrevious)\n        +BOOL MoveVelocity(LREAL Velocity, BOOL AbortPrevious)\n        +BOOL Reset()\n        +BOOL Stop()\n        +BOOL WriteBoolParameter(MC_AxisParameter ParameterNumber, BOOL Value)\n        +BOOL WriteParameter(MC_AxisParameter ParameterNumber, LREAL Value)\n    }\n\n\n    class I_BaseFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n    class I_CyclicFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class I_MotionSequence{\n        &lt;&lt;Interface&gt;&gt;\n        +I_BasicAxis Axis\n        +BOOL Execute()\n    }\n\n    class FB_BaseFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class FB_CyclicFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class FB_BasicAxis{\n\n    }</code></pre>"},{"location":"SPT_MotionControl/index.html#basic-slave","title":"Basic Slave","text":"<pre><code>classDiagram\n\n    I_CyclicFB --|&gt; I_BaseFB\n    FB_BaseFB ..|&gt; I_BaseFB    \n    FB_CyclicFB --|&gt; FB_BaseFB\n    FB_CyclicFB ..|&gt; I_CyclicFB\n\n    I_BasicAxis --|&gt; I_CyclicFB   \n\n\n\n    FB_BasicAxis --|&gt; FB_CyclicFB\n    FB_BasicAxis ..|&gt; I_BasicAxis\n\n    I_BasicSlaveAxis --|&gt; I_BasicAxis\n    FB_BasicSlaveAxis --&gt; FB_BasicAxis\n    FB_BasicSlaveAxis ..|&gt; I_BasicSlaveAxis\n\n    class I_BasicSlaveAxis{\n        &lt;&lt;Interface&gt;&gt;\n        +BOOL InGear\n        +REFERENCE TO AXIS_REF Master1\n        +REFERENCE TO AXIS_REF Master2\n        +REFERENCE TO AXIS_REF Master3\n        +REFERENCE TO AXIS_REF Master4\n        +LREAL RatioMaster1\n        +LREAL RatioMaster2\n        +LREAL RatioMaster3\n        +LREAL RatioMaster4\n        BOOL GearIn()\n        BOOL GearOut()\n    }\n\n\n    class I_BasicAxis{\n        &lt;&lt;SPT NC Axis&gt;&gt;\n    }\n\n\n    class I_BaseFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n    class I_CyclicFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class FB_BaseFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class FB_CyclicFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class FB_BasicAxis{\n\n    }</code></pre>"},{"location":"SPT_MotionControl/index.html#cam-slave","title":"Cam Slave","text":"<pre><code>classDiagram\n\n    I_CyclicFB --|&gt; I_BaseFB\n    FB_BaseFB ..|&gt; I_BaseFB    \n    FB_CyclicFB --|&gt; FB_BaseFB\n    FB_CyclicFB ..|&gt; I_CyclicFB\n\n    I_BasicAxis --|&gt; I_CyclicFB   \n\n\n\n    FB_BasicAxis --|&gt; FB_CyclicFB\n    FB_BasicAxis ..|&gt; I_BasicAxis\n\n    I_CamSlaveAxis --|&gt; I_BasicAxis\n    FB_CamSlaveAxis --&gt; FB_BasicAxis\n    FB_CamSlaveAxis ..|&gt; I_CamSlaveAxis\n\n    class I_CamSlaveAxis{\n        &lt;&lt;Interface&gt;&gt;\n        +BOOL InSync\n        +REFERENCE TO AXIS_REF Master\n        +REFERENCE TO ST_CamParameters CamParameters\n        +UDINT RunningTable\n        +LREAL SyncPos\n        BOOL ChangeMode()\n        BOOL FindSlavePos()\n        BOOL FindSyncPos()\n        BOOL StartCouple() \n        BOOL StartSync()\n        BOOL UpdateTable()\n    }\n\n\n    class I_BasicAxis{\n        &lt;&lt;SPT NC Axis&gt;&gt;\n    }\n\n\n    class I_BaseFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n    class I_CyclicFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class FB_BaseFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class FB_CyclicFB{\n        &lt;&lt;SPT Base Types&gt;&gt;\n    }\n\n    class FB_BasicAxis{\n\n    }\n</code></pre>"},{"location":"SPT_MotionControl/changelog.html","title":"Changelog","text":""},{"location":"SPT_MotionControl/changelog.html#401-2025-06-18","title":"[4.0.1] - 2025-06-18","text":""},{"location":"SPT_MotionControl/changelog.html#added","title":"Added","text":"<ul> <li>Property for FB_CamSlaveAxis<ul> <li>WaitingForCommand - Should be checked before calling: FindSlavePosition, FindSyncPosition, StartSync</li> </ul> </li> </ul>"},{"location":"SPT_MotionControl/changelog.html#40-2025-05-20","title":"[4.0] - 2025-05-20","text":""},{"location":"SPT_MotionControl/changelog.html#compiled","title":"Compiled","text":"<ul> <li>Using TwinCAT 3.1.4026</li> </ul>"},{"location":"SPT_MotionControl/changelog.html#392-2025-05-29","title":"[3.9.2] - 2025-05-29","text":""},{"location":"SPT_MotionControl/changelog.html#added_1","title":"Added","text":"<ul> <li>Property for FB_CamSlaveAxis<ul> <li>WaitingForCommand - Should be checked before calling: FindSlavePosition, FindSyncPosition, StartSync</li> </ul> </li> </ul>"},{"location":"SPT_MotionControl/changelog.html#39-2025-04-14","title":"[3.9] - 2025-04-14","text":""},{"location":"SPT_MotionControl/changelog.html#finalizing","title":"Finalizing","text":"<ul> <li>Internal updates and cleanup</li> </ul>"},{"location":"SPT_MotionControl/changelog.html#33-2025-04-11","title":"[3.3] - 2025-04-11","text":""},{"location":"SPT_MotionControl/changelog.html#sync","title":"Sync","text":"<ul> <li>Implement same version number across all SPT libraries</li> </ul>"},{"location":"SPT_MotionControl/changelog.html#added_2","title":"Added","text":"<ul> <li>Code formatting and comments</li> </ul>"},{"location":"SPT_MotionControl/changelog.html#32x-2024-03-01","title":"[3.2.x] - 2024-03-01","text":""},{"location":"SPT_MotionControl/changelog.html#fixed","title":"Fixed","text":"<ul> <li>FB_CamSlaveAxis MoveModulo() command does not repeat at SlaveSyncMove.</li> <li>Axis.Status.DriveDeviceError now intergrated into monitoring/reset logic</li> </ul>"},{"location":"SPT_MotionControl/changelog.html#added_3","title":"Added","text":"<ul> <li>I_BasicAxis now includes ReadParameterSet()</li> <li>I_BasicAxis now includes AxisParameters</li> </ul>"},{"location":"SPT_MotionControl/changelog.html#changed","title":"Changed","text":"<ul> <li>Parameters Options is now used by FB_HomeRoutine_HardStop.  This allows certain settings for compatibility with non-Beckhoff drives</li> <li>ST_Home_Options now in all versions available in ST_StepBlockLagBasedParameters. </li> </ul>"},{"location":"SPT_MotionControl/changelog.html#327-2024-08-27","title":"[3.2.7] - 2024-08-27","text":""},{"location":"SPT_MotionControl/changelog.html#added_4","title":"Added","text":"<ul> <li>Added explicit library references </li> </ul>"},{"location":"SPT_MotionControl/changelog.html#326-2024-08-27","title":"[3.2.6] - 2024-08-27","text":""},{"location":"SPT_MotionControl/changelog.html#added_5","title":"Added","text":"<ul> <li>Added Axis.Status.Error to error detection</li> </ul>"},{"location":"SPT_MotionControl/changelog.html#323-2023-09-05","title":"[3.2.3] - 2023-09-05","text":""},{"location":"SPT_MotionControl/changelog.html#added_6","title":"Added","text":"<ul> <li>Added getter for InhibitFeedPositive/Negative</li> </ul>"},{"location":"SPT_MotionControl/changelog.html#322-2023-08-31","title":"[3.2.2] - 2023-08-31","text":""},{"location":"SPT_MotionControl/changelog.html#fixed_1","title":"Fixed","text":"<ul> <li>MoveVelocity method now properly references correct velocity input</li> </ul>"},{"location":"SPT_MotionControl/changelog.html#321-2023-07-27","title":"[3.2.1] - 2023-07-27","text":""},{"location":"SPT_MotionControl/changelog.html#fixed_2","title":"Fixed","text":"<ul> <li>MC_Jog now resets properly.</li> </ul>"},{"location":"SPT_MotionControl/changelog.html#320-2023-06-02","title":"[3.2.0] - 2023-06-02","text":""},{"location":"SPT_MotionControl/changelog.html#added_7","title":"Added","text":"<ul> <li>Added library parameter ALWAYS_CALL_IPRESETMETHOD_ON_RESET</li> <li>Added method/property for external motion sequences </li> </ul>"},{"location":"SPT_MotionControl/changelog.html#changed_1","title":"Changed","text":"<ul> <li>Axis will now thrown an error (16#A000) if NC is not linked and <code>ALLOW_UNLINKED_NC_AXES = FALSE</code></li> <li>Setting the velocity property outside of the NC parameter limits will generate messages in the trace log</li> </ul>"},{"location":"SPT_MotionControl/changelog.html#311-2022-04-25","title":"[3.1.1] - 2022-04-25","text":""},{"location":"SPT_MotionControl/changelog.html#fixed_3","title":"Fixed","text":"<ul> <li>GetNewFB() in all FB_RingBuffer_xxx function blocks were returning POINTER TO MC_MoveAbsolute</li> </ul>"},{"location":"SPT_MotionControl/changelog.html#310-2022-04-06","title":"[3.1.0] - 2022-04-06","text":""},{"location":"SPT_MotionControl/changelog.html#added_8","title":"Added","text":"<ul> <li>Initial release</li> <li>Added contents of SPT_NC_Homing library as part of consolidation effort</li> <li>Added contents of SPT_NC_Drives library as part of consolidation effort</li> <li>Added contents of SPT_NC_Axis library as part of consolidation effort</li> <li>Added contents of SPT_NC_Basic_Slave library as part of consolidation effort</li> <li>Added contents of SPT_NC_CamSlave library as part of consolidation effort</li> </ul>"},{"location":"SPT_MotionControl/duts.html","title":"DUTs","text":""},{"location":"SPT_MotionControl/duts.html#enums","title":"ENUMs","text":""},{"location":"SPT_MotionControl/duts.html#e_camaxisstate","title":"E_CamAxisState","text":"<pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_CamAxisState : (\n        eCamAxisState_Disabled := 0,\n        eCamAxisState_ReadMasterParameters,\n        eCamAxisState_ReadSlaveParameters,\n        eCamAxisState_AxisInitDone,\n        eCamAxisState_WaitForCommand,\n        eCamAxisState_DecoupleBeforeStart,\n        eCamAxisState_CheckTableSelect,\n        eCamAxisState_LoadCamTable,\n        eCamAxisState_CheckAxisStatus,\n        eCamAxisState_ReadSlaveDynamics,\n        eCamAxisState_DetermineSyncMove,\n        eCamAxisState_SlaveSyncMove,\n        eCamAxisState_CoupleSlave,\n        eCamAxisState_SetChangeMode,\n        eCamAxisState_WaitForChangeCommand,\n        eCamAxisState_WriteNewTable,\n        eCamAxisState_WaitForActive,\n        //eCamAxisState_DecoupleSlave,\n\n        //eCamAxisState_HaltSlave,\n        eCamAxisState_Error\n    ) UDINT;\nEND_TYPE\n</code></pre>"},{"location":"SPT_MotionControl/duts.html#e_camsyncmode","title":"E_CamSyncMode","text":"<p>When <code>StartSync()</code> is called, a modulo move will be performed to position the slave according to the selected cam table.  <code>ST_CamParameters.SyncMode</code> specifies how this move should be executed. <pre><code>TYPE E_CamSyncMode : (\n        eCamSyncMode_ShortestWay    := 0, // Move the Shortest Distance\n        eCamSyncMode_Forward        := 1, // Move Only in the Forward Direction\n        eCamSyncMode_Reverse        := 2, // Move Only in the Reverse Direction\n        eCamSyncMode_Window_Forward := 3, // Move Shortest Distance If In Window Else Move Forward\n        eCamSyncMode_Window_Reverse := 4  // Move Shortest Distance If In Window Else Move Reverse\n    );\nEND_TYPE\n</code></pre></p>"},{"location":"SPT_MotionControl/duts.html#structs","title":"STRUCTs","text":""},{"location":"SPT_MotionControl/duts.html#st_abshomeparameters","title":"ST_AbsHomeParameters","text":"<pre><code>TYPE ST_AbsHomeParameters :\n    STRUCT\n        PositionBias           : LREAL;\n        PositionLimit_Positive : LREAL;\n        PositionLimit_Negative : LREAL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_MotionControl/duts.html#st_camparameters","title":"ST_CamParameters","text":"<pre><code>TYPE ST_CamParameters :\n    STRUCT\n        // Table Must Be Constructed of Motion Functions\n        MasterPos     : LREAL         := 0.1;                                    // Position of Master For Which Corresponding Slave Position Is Found For\n        SyncMode      : E_CamSyncMode := E_CamSyncMode.eCamSyncMode_ShortestWay; // Specifies Which Direction Slave Moves To Synchronize With the Master\n        SyncWindow    : LREAL         := 10.0;                                   // Used In Conjunction With Sync Mode\n        SyncVelocity  : LREAL         := 10.0;                                   // Used When Slave Moves To Synchronization Position\n        SyncAccel     : LREAL         := 100.0;                                  // Used When Slave Moves To Synchronization Position\n        SyncDecel     : LREAL         := 100.0;                                  // Used When Slave Moves To Synchronization Position\n        SyncJerk      : LREAL         := 1000.0;                                 // Used When Slave Moves To Synchronization Position\n        TableSelect   : UDINT         := 1;                                      // Selects Which of Five Cam Tables To Use\n        CamTableId    : MC_CAM_ID     := 1;                                      // Make Sure All Your Id's are Unique\n        CamTable      : ARRAY[1..Parameters_NCCamAxis.CAM_SLAVE_AXIS_TABLES] OF ST_CamPoints;\n        Periodic      : BOOL         := TRUE;\n        MasterOffset  : LREAL        := 0.0;\n        SlaveOffset   : LREAL        := 0.0;\n        MasterScaling : LREAL        := 1.0;\n        SlaveScaling  : LREAL        := 1.0;\n        StartMode     : MC_StartMode := MC_STARTMODE_ABSOLUTE;\n        BufferMode    : MC_BufferMode;\n        CamInOptions  : ST_CamInOptions;\n        ChangeOptions : ST_CamInOptions; // Used for MC_SetCamOnlineChangeMode; Change Mode is Set After Cam In\n    END_STRUCT\nEND_TYPE\nST_CamParameters\n</code></pre>"},{"location":"SPT_MotionControl/duts.html#st_campoints","title":"ST_CamPoints","text":"<pre><code>TYPE ST_CamPoints :\n    STRUCT\n        Points         : ARRAY[1..Parameters_NCCamAxis.CAM_SLAVE_AXIS_MAX_CAM_POINTS] OF MC_MotionFunctionPoint; // Array of Points \n        NumberOfPoints : DINT;                                                                                   // Quantity of Points \n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_MotionControl/duts.html#st_stepblocklagbasedparameters","title":"ST_StepBlockLagBasedParameters","text":"<pre><code>TYPE ST_StepBlockLagBasedParameters :\n    STRUCT\n        Direction               : MC_Home_Direction := mcNegativeDirection;\n        Velocity                : LREAL             := 10;\n        Acceleration            : LREAL             := 100;\n        Deceleration            : LREAL             := 100;\n        Jerk                    : LREAL             := 1000;\n        DetectionVelocityLimit  : LREAL             := 5;\n        DetectionVelocityTime   : TIME              := T#500MS;\n        TimeLimit               : TIME;\n        DistanceLimit           : LREAL;\n        TorqueLimit             : LREAL := 10;\n        LagLimit                : LREAL := 10;\n        ClearPositionLag        : BOOL;         // ST_Home_Options\n        DisableDriveAccess      : BOOL;         // ST_Home_Options2 // ST_Home_Options3\n        InstantLagReduction     : BOOL := TRUE; // ST_Home_Options3\n        TorquePolarityInverted  : BOOL;         // ST_Home_Options3\n        EnableLagErrorDetection : BOOL;         // ST_Home_Options4\n    END_STRUCT\nEND_TYPE\n</code></pre> Member Type Description Direction LREAL Enumeration that defines the initial direction of movement for the search procedure Velocity LREAL Maximum travel velocity (&gt;0). Acceleration LREAL Acceleration (\u22650). If the value is 0, the standard acceleration from the axis configuration in the System Manager is used. Deceleration LREAL Deceleration (\u22650). If the value is 0, the standard deceleration from the axis configuration in the System Manager is used. Jerk LREAL Jerk (\u22650). If the value is 0, the standard jerk from the axis configuration in the System Manager is used. DetectionVelocityLimit LREAL Velocity that must be fallen below for the time DetectionVelocityTime in order to detect driving against the fixed stop DetectionVelocityTime LREAL Time for detecting the velocity undershoot when driving against the fixed stop. TimeLimit LREAL Exceeding this time leads to the search procedure being aborted. DistanceLimit LREAL Exceeding this distance in relation to the start position leads to the search procedure being aborted. TorqueLimit LREAL The motor torque is limited to this value, in relation to the weight counterbalance that is possibly parameterized in the drive, in order to avoid mechanical damage. LagLimit LREAL Position lag value which, if exceeded, leads to detection of driving against the fixed stop InstantLagReduction Bool InstantLagReduction: When referencing to a mechanical fixed stop, the sudden stop produces a position lag in the NC axis, which is dissipated with the parameterized dynamic values in the further course. This can lead to an assumed delay when observing the sequence, but it is purposeful in particular with \"soft\" fixed stops. The position lag is dissipated abruptly by setting this flag ClearPositionLag BOOL Clear Position lag after homing. DisableDriveAccess BOOL Set to FALSE for Beckhoff drives, usually to TRUE for third-party drives. TorquePolarityInverted BOOL EnableLagErrorDetection BOOL In the step functions, the lag error detection is switched off in order to ensure a smooth referencing process. If it would be useful to keep the lag error detection active in an application, this can be achieved by setting this flag."},{"location":"SPT_MotionControl/functionblocks.html","title":"Function Blocks","text":""},{"location":"SPT_MotionControl/functionblocks.html#axis-types","title":"Axis Types","text":""},{"location":"SPT_MotionControl/functionblocks.html#fb_basicaxis","title":"FB_BasicAxis","text":"<p>(extends <code>FB_CyclicFB</code>, implements <code>I_BasicAxis</code>)</p> <p>Complete implementation of I_BasicAxis.  For use as a PackML component, use <code>FB_Component_BasicAxis</code>.</p> <p>READ ALL OF ME</p> <ul> <li>The <code>Initialize()</code> method checks to see if the underlying AXIS_REF has been linked to an NC axis.  If not, <code>Initialize()</code> will not return <code>TRUE</code>.</li> <li>This behavior can be inhibited by setting the library parameter <code>ALLOW_UNLINKED_NC_AXES</code> to <code>TRUE</code>.</li> <li>The <code>Initialize()</code> method automatically reads all of the axis' NC parameters, which can be accessed via the <code>NCParameters</code> property.</li> <li><code>CyclicLogic()</code> should be called so that underlying function block calls are made</li> <li><code>BOOL</code> return values from command methods should be interpreted as \"COMMAND ACCEPTED\".  This is not \"COMMAND COMPLETED\".  Monitor the <code>Busy</code> property to detect when a command has finished (see example below).</li> <li>Most commands are internally interlocked with <code>_Busy</code> such that a command will not be accepted (return <code>TRUE</code>) if a command is already in process.  This can be bypassed (move interrupted) by passing <code>TRUE</code> to the <code>AbortPrevious</code> argument of the move method call.  If the <code>AbortPrevious</code> argument is not included in the method signature, this should be interpreted to mean the command will take place immediately. </li> </ul>"},{"location":"SPT_MotionControl/functionblocks.html#properties","title":"Properties","text":""},{"location":"SPT_MotionControl/functionblocks.html#axis","title":"Axis","text":"<p><code>PROPERTY Axis : REFERENCE TO AXIS_REF</code></p> <p>Returns a reference to the underlying NC axis for use in other axes or otherwise external motion functions.</p> <p>Example <pre><code>PROGRAM MAIN\nVAR\n    MyBasicAxis : FB_BasicAxis;\n    MyBasicSlaveAxis : FB_BasicSlaveAxis;\n    MySlaveAxis : AXIS_REF;\n    MC_GearIn : MC_GearIn;\nEND_VAR\n\n//Mixing basic MC2 and FB_BasicAxis\nMC_GearIn(\n    Master:= MyBasicAxis.Axis, \n    Slave:= MySlaveAxis, \n    Execute:= TRUE, \n    RatioNumerator:= 1, \n    RatioDenominator:= 1);\n\n//Assigning a FB_BasicAxis to an FB_BasicSlaveAxis\nMyBasicSlaveAxis.Master1 REF= MyBasicAxis.Axis;\n</code></pre></p>"},{"location":"SPT_MotionControl/functionblocks.html#externalsequence","title":"ExternalSequence","text":"<p><code>PROPERTY ExternalSequence : I_MotionSequence</code></p> <p>The standard motion methods all execute function blocks with the <code>BufferMode</code> input set to <code>MC_Aborting</code>.  In the case that your motion sequence requires some sort of buffering or blending, you can create a function block that implements <code>I_MotionSequence</code> and contains any sequence of motion commands you desire.  <code>RunExternalSequence()</code> will call <code>Execute()</code> on your custom sequence function block.</p>"},{"location":"SPT_MotionControl/functionblocks.html#homemethod","title":"HomeMethod","text":"<p><code>PROPERTY HomeMethod : I_MotionSequence</code></p> <p>You can optionally assign an external sequence of events to occur when the <code>Home()</code> method is called.  Assigning a function block which implements <code>I_MotionSequence</code> will automatically assign the axis' <code>AXIS_REF</code> for use in whatever function blocks you choose.  The instantiation of custom home routine function block should take place in the parent of the <code>FB_BasicAxis</code> instance.  </p> <p>Default Home() Behavior</p> <p>The default behavior is to set the current position as zero when this property is not set and <code>Home()</code> is called.  There is an internal instance of FB_HomeRoutine_SetZeroHere which, if not overridden, is call by <code>Home()</code>.</p>"},{"location":"SPT_MotionControl/functionblocks.html#resetmethod","title":"ResetMethod","text":"<p><code>PROPERTY ResetMethod : I_MotionSequence</code></p> <p>You can optionally assign an external sequence of events to occur when the <code>Reset()</code> method is called.  This can be useful, for instance, when using an AX5000 or some drive that needs a separate reset routine to be called in addition to MC_Reset.  Assigning a function block which implements <code>I_MotionSequence</code> will automatically assign the axis' <code>AXIS_REF</code> for use in whatever function blocks you choose.  The instantiation of custom reset routine function block should take place in the parent of the <code>FB_BasicAxis</code> instance.  </p> <p>Default Reset() Behavior</p> <p>The default behavior is to call MC_Reset when this property is not set and the Reset() method is called.</p>"},{"location":"SPT_MotionControl/functionblocks.html#methods","title":"Methods","text":""},{"location":"SPT_MotionControl/functionblocks.html#movevelocity","title":"MoveVelocity()","text":"<pre><code>METHOD MoveVelocity : BOOL\nVAR_INPUT\n    Velocity      : LREAL;\n    AbortPrevious : BOOL;\nEND_VAR\n</code></pre> <p>Important</p> <p>The <code>Velocity</code> argument is allowed to be &lt;= 0 (axis will stop--does not call MC_Halt).  The <code>Velocity</code> argument will also be automatically transferred to the <code>Velocity</code> property of the function block!</p>"},{"location":"SPT_MotionControl/functionblocks.html#stop","title":"Stop()","text":"<p><code>METHOD Stop : BOOL</code></p> <p>Important</p> <p><code>Stop()</code> makes a call <code>MC_Halt</code> internally.  <code>MC_Halt</code> can be interruped by a further motion command, whereas <code>MC_Stop</code> cannot.</p>"},{"location":"SPT_MotionControl/functionblocks.html#examples","title":"Examples","text":"Enabling Axis <pre><code>MyAxis.CyclicLogic();\n\nCASE State OF\n  0:\n    IF MyAxis.Enable() THEN\n      State := State + 10;\n    END_IF\n  10:\n    IF MyAxis.Enabled THEN\n      State := State + 10;\n    END_IF\n  20:\n    // Continue\n    ... \nEND_CASE\n</code></pre> Command a discrete move <pre><code>CASE State OF\n  0:\n    MyAxis.Velocity := 10;\n    IF MyAxis.MoveAbsolute(100, FALSE) THEN\n      State := State + 10;\n    END_IF\n\n  10:\n    IF NOT MyAxis.Busy THEN\n      State := State + 10;\n    END_IF\n\n  20:\n    //Continue\n    ...\nEND_CASE\n</code></pre> Command a velocity move and then change velocity <pre><code>CASE State OF\n  0:\n    IF MyAxis.MoveVelocity(100, FALSE) THEN\n      State := State + 10;\n    END_IF\n\n  10:\n    IF ChangeVelocity THEN\n      MyAxis.MoveVelocity(10, TRUE);\n      State := State + 10;\n    END_IF\n\n  20:\n    //Continue\n    ...\nEND_CASE\n</code></pre> <p>Proper sequencing of multiple axes</p> <p>Resist the temptation to combine commands to multiple axes in the same state/line.  Depending on the command, you can find yourself in a race condition.</p> <p>Less typing, more headaches: <pre><code>CASE State OF\n  0:\n    //Move is issued to both axes--okay\n    IF MyAxis.MoveRelative(10, FALSE) AND MyOtherAxis.MoveRelative(5, FALSE) THEN\n      State := State + 10;\n    END_IF\n  10:\n    //MyOtherAxis finishes its move first and second command is issued\n    //MyAxis is still busy at this point, so command is ignored until first move is complete\n    //Commands end up flip-flopping and axes goes nowhere near where you intended\n    IF MyAxis.MoveRelative(1, FALSE) AND MyOtherAxis.MoveRelative(5, FALSE) THEN\n      State := State + 10;\n    END_IF\n\n  20:\n    //You may or may not ever get here...\n    IF NOT MyAxis.Busy AND NOT MyOtherAxis.Busy THEN\n      State := State + 10;\n    END_IF\n  30:\n    //Continue\n    ...\nEND_CASE\n</code></pre> Result</p> <p></p> <p>More states, but axes go where you want them to: <pre><code>CASE State OF\n  0:\n    IF MyAxis.MoveRelative(10, FALSE) THEN\n      State := State + 10;\n    END_IF\n  10:\n    IF MyOtherAxis.MoveRelative(5, FALSE) THEN\n      State := State + 10;\n    END_IF\n  20:\n    //Wait for both axes to be done\n    IF NOT MyAxis.Busy AND NOT MyOtherAxis.Busy THEN\n      State := State + 10;\n    END_IF\n  30:\n    IF MyAxis.MoveRelative(1, FALSE) THEN\n      State := State + 10;\n    END_IF\n  40:\n    IF MyOtherAxis.MoveRelative(5, FALSE) THEN\n      State := State + 10;\n    END_IF\n  50:\n    IF NOT MyAxis.Busy AND NOT MyOtherAxis.Busy THEN\n      State := State + 10;\n    END_IF\n  60:\n    //Continue\n    ...\nEND_CASE\n</code></pre> Result</p> <p></p>"},{"location":"SPT_MotionControl/functionblocks.html#fb_basicslaveaxis","title":"FB_BasicSlaveAxis","text":"<p>(extends <code>FB_BasicAxis</code>, implements <code>I_BasicSlaveAxis</code>)</p> <p>Complete implementation of I_BasicSlaveAxis.  For use as a PackML component, use FB_Component_BasicSlaveAxis.</p> <p>Note</p> <p>See FB_BasicAxis for documentation of base motion functions</p>"},{"location":"SPT_MotionControl/functionblocks.html#examples_1","title":"Examples","text":"Couple two axes at 1:1 ratio <pre><code>CASE State OF\n  0:\n    MySlaveAxis.Master1 REF= MyMasterAxis.Axis;\n    MySlaveAxis.RatioMaster1 := 1.0;\n    IF MySlaveAxis.GearIn() THEN\n      State := State + 10;\n    END_IF\n\n  10:\n    IF MySlaveAxis.InGear THEN\n      State := State + 10;\n    END_IF\n  20:\n    //Continue\n    ...\nEND_CASE\n</code></pre> Adjusting ratio on the fly <pre><code>CASE State OF\n  0:\n    MySlaveAxis.Master1 REF= MyMasterAxis.Axis;\n    MySlaveAxis.RatioMaster1 := 1.0;\n    IF MySlaveAxis.GearIn() THEN\n      State := State + 10;\n    END_IF\n\n  10:\n    IF MySlaveAxis.InGear THEN\n      State := State + 10;\n    END_IF\n\n  20:\n    IF MyMasterAxis.MoveVelocity(100, FALSE) THEN\n      State := State + 10;\n    END_IF\n\n  30:\n    IF AdjustRatio THEN\n      MySlaveAxis.RatioMaster1 := 5.0;\n      State := State + 10;\n    END_IF  \n  40:\n    //Continue\n    ...\nEND_CASE\n</code></pre> <p>Result</p> <p></p> Phase adjustments using multimaster gearing <p>You can gear a second (and third/fourth) master to the same slave axis.  This can be useful when you need to make phase adjustments to a master/slave coupling (conveyor gapping, etc.)  Moves made to the additional masters are superimposed against the other masters according to the dynamics of the phase adjustment moves. <pre><code>CASE State OF\n  0:\n    MySlaveAxis.Master1 REF= MyMasterAxis.Axis;\n    MySlaveAxis.Master2 REF= MyPhaseAdjustAxis.Axis;\n    MySlaveAxis.RatioMaster1 := 1.0;\n    MySlaveAxis.RatioMaster2 := 1.0;\n\n    IF MySlaveAxis.GearIn() THEN\n      State := State + 10;\n    END_IF\n\n  10:\n    IF MySlaveAxis.InGear THEN\n      State := State + 10;\n    END_IF\n\n  20:\n    //Start master axis\n    IF MyMasterAxis.MoveVelocity(100, FALSE) THEN\n      State := State + 10;\n    END_IF\n  30:\n    IF AdjustPhase THEN\n      //Advance phase of slave by +100 units\n      IF MyPhaseAdjustAxis.MoveRelative(100, FALSE) THEN\n        State := State + 10;\n      END_IF\n    END_IF\n  40:\n    IF NOT MyPhaseAdjustAxis.Busy THEN\n      //Advance phase of slave by -200 units\n      IF MyPhaseAdjustAxis.MoveRelative(-200, FALSE) THEN\n        State := State + 10;\n      END_IF            \n    END_IF\n  50:\n    //Continue\n    ... \nEND_CASE\n</code></pre></p> <p>Result </p>"},{"location":"SPT_MotionControl/functionblocks.html#fb_camslaveaxis","title":"FB_CamSlaveAxis","text":"<p>(extends <code>FB_BasicAxis</code>, implements <code>I_CamSlaveAxis</code>)</p> <p>Complete implementation of I_CamSlaveAxis.  For use as a PackML component, use <code>FB_Component_CamSlaveAxis</code>.</p> <p>Important</p> <ul> <li>See <code>FB_BasicAxis</code> for documentation of base motion functions</li> <li><code>CamParameters.CamTable[]</code> holds cam definition data for 1 to <code>Parameters_NCCamAxis.CAM_SLAVE_AXIS_TABLES</code> cam tables</li> <li>Each instance of <code>ST_CamPoints</code> holds 1 to <code>1..Parameters_NCCamAxis.CAM_SLAVE_AXIS_MAX_CAM_POINTS</code> of <code>MC_MotionFunctionPoints</code> (see Infosys)</li> <li>Once a slave is coupled to its master, <code>CamParameters.TableSelect</code> specifies which <code>CamParameters.CamTable[]</code> is to be run.  The switch-out happens automatically and according to <code>CamParameters.ChangeOptions</code>.  The default behavior is an instantaneous switch</li> <li>Update <code>CamParameters.ChangeOptions</code> and use <code>ChangeMode()</code> to modify this behavior</li> <li>Table data of the currently running cam can be updated on the fly using <code>UpdateTable()</code> after updating <code>CamParameters.CamTable[]</code>.  Same online change behavior mentioned above applies.</li> </ul>"},{"location":"SPT_MotionControl/functionblocks.html#examples_2","title":"Examples","text":"Hello, Camming! <p><pre><code>CamParameters.CamTableId                              := Slave.Axis.NcToPlc.AxisId;\n\n//Table 1\nCamParameters.CamTable[1].NumberOfPoints              := 3;\nCamParameters.CamTable[1].Points[1].PointIndex        := 1;\nCamParameters.CamTable[1].Points[1].FunctionType      := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5;\nCamParameters.CamTable[1].Points[1].PointType         := MC_MotionPointType.MOTIONPOINTTYPE_REST;\nCamParameters.CamTable[1].Points[1].RelIndexNextPoint := 1;\nCamParameters.CamTable[1].Points[1].MasterPos         := 0.0;\nCamParameters.CamTable[1].Points[1].SlavePos          := 0.0;\nCamParameters.CamTable[1].Points[2].PointIndex        := 2;\nCamParameters.CamTable[1].Points[2].FunctionType      := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5;\nCamParameters.CamTable[1].Points[2].PointType         := MC_MotionPointType.MOTIONPOINTTYPE_TURN;\nCamParameters.CamTable[1].Points[2].RelIndexNextPoint := 1;\nCamParameters.CamTable[1].Points[2].MasterPos         := 180.0;\nCamParameters.CamTable[1].Points[2].SlavePos          := 100.0;\nCamParameters.CamTable[1].Points[3].PointIndex        := 3;\nCamParameters.CamTable[1].Points[3].FunctionType      := MC_MotionFunctionType.MOTIONFUNCTYPE_POLYNOM5;\nCamParameters.CamTable[1].Points[3].PointType         := MC_MotionPointType.MOTIONPOINTTYPE_REST;\nCamParameters.CamTable[1].Points[3].RelIndexNextPoint := 0;\nCamParameters.CamTable[1].Points[3].MasterPos         := 360.0;\nCamParameters.CamTable[1].Points[3].SlavePos          := 0.0;\nCamParameters.CamTable[1].NumberOfPoints              := 3;\n</code></pre> Result </p> Coupling above table <p><pre><code>CASE SequenceState OF\n    10:\n        IF Master.Enable() THEN\n            SequenceState := 11;\n        END_IF\n    11:\n        IF Slave.Enable() THEN\n            SequenceState := 12;\n        END_IF\n    12:\n        IF Master.Enabled AND Slave.Enabled THEN\n            SequenceState := 20;\n        END_IF\n    20:\n        IF Slave.StartSync() THEN\n            SequenceState := 21;\n        END_IF\n    21:\n        IF Slave.InSync THEN\n            SequenceState := 22;\n        END_IF\n\n    22:\n        IF Master.MoveVelocity(100, FALSE) THEN\n            SequenceState := 23;\n        END_IF\n    23:\n      //Continue\n      ...\nEND_CASE\n</code></pre> Result </p> Update Online Change Mode <pre><code>CamParameters.ChangeOptions.ActivationMode := MC_CAMACTIVATION_NEXTCYCLE;\n\nIF Slave.ChangeMode() THEN\n  SequenceState := 0;\nEND_IF\n</code></pre> Change Current Table Point Data <p><pre><code>CamParameters.CamTable[1].Points[2].SlavePos          := 250.0;\n\nIF Slave.UpdateTable() THEN\n  SequenceState := 51;\nEND_IF\n</code></pre> Result </p> Change To Different Table Switching Tables vs Modifying Points <p>The behavior of the internal code is to modify the running table's points if the axis is already cammed in. Once the tables have been defined in the array ST_CamParameters.CamTable[1..10], setting the property ST_CamParameters.TableSelect will cause the internal table with ID = 1 to be modified to match the selected table. This means that the two tables must contain the same number of points. If not, an error will occur. (0x4A13 - 18963 - Line Index Not Allowed). For this reason the sample code provided includes a FOR loop to fill the table with 'Ignore' points.  </p> <p>If the axes are not coupled when changing tables, then the new table can be of a different size.</p> <pre><code>CamParameters.TableSelect := 2;\nIF Slave.RunningTable = 2 THEN\n  SequenceState := 0;\nEND_IF\n</code></pre> <p>Result </p> <p>Pre-Couple Sync Behavior</p> <ul> <li><code>StartSync()</code> is called</li> <li>Correct slave position according to current master position is looked up using <code>MC_ReadCamTableSlaveDynamics</code></li> <li><code>MC_MoveModulo</code> is performed on Slave to bring into sync with master according to cam</li> <li><code>MC_CamIn</code> is executed--slave is now coupled</li> </ul> <p></p> <p>Manually Positioning Slave Prior to Coupling</p> <p>It is possible that you might want to control the pre-couple synchronization move of the slave on your own.  Use <code>FindSyncPos()</code> or <code>FindSlavePos()</code> to do this.  After looking up the sync position and manually moving slave axis, use <code>StartCouple()</code> instead of <code>StartSync()</code>.</p> <p>FindSyncPos() Result </p> <p>FindSlavePos() Use </p>"},{"location":"SPT_MotionControl/functionblocks.html#home-routines","title":"Home Routines","text":""},{"location":"SPT_MotionControl/functionblocks.html#fb_homeroutine_abshoming","title":"FB_HomeRoutine_AbsHoming","text":"<p><pre><code>FUNCTION_BLOCK FINAL FB_HomeRoutine_AbsHoming EXTENDS FB_CyclicFB IMPLEMENTS I_MotionSequence\n</code></pre> Use with multi-turn absolute encoder to make current position read as 0.0 using position bias parameter of the NC encoder object.  A persistent variable of the type ST_AbsHomeParameters must be created along with the FB declaration.  The persistent variable will store the desired value through power cycles. <pre><code>VAR PERSISTENT\n    AbsHomingParms  : ST_AbsHomeParameters;\nEND_VAR\nVAR\n    AbsHoming       : FB_HomeRoutine_AbsHoming;\nEND_VAR\n</code></pre> The initialization code of the application should set the home method and the reference to the parameters variable. <pre><code>Axis.HomeMethod:=AbsHoming;\nAbsHoming.Parameters REF= AbsHomingParms;\n</code></pre> In the Maintenence mode, Execute State, the axis should be manually placed in the desired zero position.  An HMI command can trigger the AbsHoming.Execute method a single time to update the position bias parameter. <pre><code>IF AbsHomeCmd THEN\n    AbsHoming.Execute();\n    AbsHomeCmd:=FALSE;\nEND_IF\n</code></pre></p>"},{"location":"SPT_MotionControl/functionblocks.html#properties_1","title":"Properties","text":"Property Type Access Description Parameters ST_AbsHomeParameters RW Get/Set parameter structure"},{"location":"SPT_MotionControl/functionblocks.html#fb_homeroutine_hardstop","title":"FB_HomeRoutine_HardStop","text":"<pre><code>FUNCTION_BLOCK FINAL FB_HomeRoutine_HardStop EXTENDS FB_CyclicFB IMPLEMENTS I_MotionSequence\n</code></pre> <p>Sets torque limit and moves axis at a set velocity toward specified end of travel.  When a mechanical interference is detected via increasing position lag, sets home to interference position.</p>"},{"location":"SPT_MotionControl/functionblocks.html#properties_2","title":"Properties","text":"Property Type Access Description HomePosition LREAL RW Get/Set position that should be set once hard stop is detected Parameters ST_StepBlockLagBasedParameters RW Get/Set parameter structure"},{"location":"SPT_MotionControl/functionblocks.html#fb_homeroutine_setposition","title":"FB_HomeRoutine_SetPosition","text":"<pre><code>FUNCTION_BLOCK FINAL FB_HomeRoutine_SetPosition EXTENDS FB_CyclicFB IMPLEMENTS I_MotionSequence\n</code></pre> <p>Sets current axis position equal to <code>HomePosition</code> property.</p>"},{"location":"SPT_MotionControl/functionblocks.html#properties_3","title":"Properties","text":"Property Type Access Description HomePosition LREAL RW Get/Set position that should be set"},{"location":"SPT_MotionControl/functionblocks.html#fb_homeroutine_setzerohere","title":"FB_HomeRoutine_SetZeroHere","text":"<pre><code>FUNCTION_BLOCK FINAL FB_HomeRoutine_SetZeroHere EXTENDS FB_CyclicFB IMPLEMENTS I_MotionSequence\n</code></pre> <p>Sets current axis position to 0.0</p>"},{"location":"SPT_MotionControl/functionblocks.html#hardware-utility-function","title":"Hardware Utility Function","text":""},{"location":"SPT_MotionControl/functionblocks.html#fb_resetroutine_coedrive","title":"FB_ResetRoutine_CoEDrive","text":"<pre><code>FUNCTION_BLOCK FINAL FB_ResetRoutine_CoEDrive EXTENDS FB_BaseFB IMPLEMENTS I_MotionSequence\n</code></pre> <p>Issues a basic <code>MC_Reset</code> command against the assigned axis.  Default behavior for <code>FB_BasicAxis</code>, <code>FB_BasicSlaveAxis</code>.</p>"},{"location":"SPT_MotionControl/functionblocks.html#fb_resetroutine_soedrive","title":"FB_ResetRoutine_SoEDrive","text":"<pre><code>FB_ResetRoutine_SoEDrive EXTENDS FB_BaseFB IMPLEMENTS I_MotionSequence\n</code></pre> <p>Issues a SoE reset command, followed by <code>MC_Reset</code>.  For use with AX5000 drives.</p>"},{"location":"SPT_MotionControl/globals.html","title":"Globals/Parameters","text":""},{"location":"SPT_MotionControl/globals.html#parameters","title":"Parameters","text":""},{"location":"SPT_MotionControl/globals.html#parameters_motioncontrol","title":"Parameters_MotionControl","text":"Parameter Type Default Description ALLOW_UNLINKED_NC_AXES BOOL FALSE Allows NC axes to skip checking for linked NC axes during initialization CAM_SLAVE_AXIS_TABLES UDINT 10 Maximum number of cam tables allocated per FB_CamSlaveAxis CAM_SLAVE_AXIS_MAX_CAM_POINTS UDINT 30 Maximum number of cam point allocated per cam table ALWAYS_CALL_IPRESETMETHOD_ON_RESET BOOL FALSE If <code>TRUE</code>, Reset() will always call FB assigned to <code>ResetMethod</code> regardless of the nature of the error"},{"location":"SPT_MotionControl/interfaces.html","title":"Interfaces","text":""},{"location":"SPT_MotionControl/interfaces.html#i_basicaxis","title":"I_BasicAxis","text":"<p>(extends <code>I_CyclicFB</code>)</p> <p>Defines basic required functionality for a basic NC axis.</p> <p>Tip</p> <p><code>I_BasicAxis</code> does not include any sort of coupling function.  See FB_BasicSlaveAxis and FB_CamSlaveAxis for more information.</p>"},{"location":"SPT_MotionControl/interfaces.html#properties","title":"Properties","text":"Property Type Access Description Axis REFERENCE TO AXIS_REF R Returns an AXIS_REF for use in external motion functions, etc. AxisParameters REFERENCE TO ST_AxisParameterSet R Returns a reference to the axis' NC parameters ExternalSequence I_MotionSequence RW Assign a custom sequence for axis to perform HomeMethod I_MotionSequence RW Assign a custom homing method ResetMethod I_MotionSequence RW Assign a custom reset method InhibitFeedPositive BOOL RW When TRUE, motion in the positive direction is not allowed InhibitFeedNegative BOOL RW When TRUE, motion in the negative direction is not allowed Override LREAL RW Get/Set axis override (100.0 = 100%)"},{"location":"SPT_MotionControl/interfaces.html#dynamics","title":"Dynamics","text":"Property Type Access Description Acceleration LREAL RW Get/Set acceleration input to motion functions Deceleration LREAL RW Get/Set deceleration input to motion functions Jerk LREAL RW Get/Set jerk input to motion functions Velocity LREAL RW Get/Set velocity input to motion functions (exception: <code>MoveVelocity()</code>)"},{"location":"SPT_MotionControl/interfaces.html#feedback","title":"Feedback","text":"Property Type Access Description ActualAcceleration LREAL R Get actual acceleration of axis ActualPosition LREAL R Get actual position of axis ActualPositionModulo LREAL R Get actual modulo position of axis ActualTorque LREAL R Get actual torque of axis ActualVelocity LREAL R Get actual velocity of axis PositionLag LREAL R Get position lag of axis SetAcceleration LREAL R Get setpoint acceleration of axis SetPosition LREAL R Get setpoint position of axis SetPositionModulo LREAL R Get setpoint modulo position of axis SetVelocity LREAL R Get setpoint velocity of axis"},{"location":"SPT_MotionControl/interfaces.html#status","title":"Status","text":"Property Type Access Description Enabled BOOL R Axis is enabled InPosition BOOL R Axis is within target position window Stopped BOOL R Axis is not moving"},{"location":"SPT_MotionControl/interfaces.html#methods","title":"Methods","text":"Method Return Type Description Disable BOOL Disable axis Enable BOOL Enable axis Home BOOL Home axis Jog BOOL Jog axis MoveAbsolute BOOL Initiate an absolute move MoveModulo BOOL Initiate a modulo move MoveRelative BOOL Initiate a relative move MoveVelocity BOOL Initiate a continuous velocity move ReadParameterSet Bool Reads parameter set for Axis, Parameter Set available in <code>AxisParameters</code> Reset BOOL Reset axis RunExternalSequence BOOL Executes function block assigned to  <code>ExternalSequence</code> WriteBoolParameter BOOL Write a parameter of type BOOL WriteParameter BOOL Write a parameter of type LREAL"},{"location":"SPT_MotionControl/interfaces.html#i_basicslaveaxis","title":"I_BasicSlaveAxis","text":"<p>(extends <code>I_BasicAxis</code>)</p> <p>Defines basic required functionality for a basic NC axis plus gearing functions.</p>"},{"location":"SPT_MotionControl/interfaces.html#properties_1","title":"Properties","text":"Property Type Access Description Master1 REFERENCE TO AXIS_REF RW Get/Set the first master axis to couple with Master2 REFERENCE TO AXIS_REF RW Get/Set the second master axis to couple with Master3 REFERENCE TO AXIS_REF RW Get/Set the third master axis to couple with Master4 REFERENCE TO AXIS_REF RW Get/Set the fourth master axis to couple with RatioMaster1 LREAL RW Get/Set the coupling ratio of the first master axis RatioMaster2 LREAL RW Get/Set the coupling ratio of the second master axis RatioMaster3 LREAL RW Get/Set the coupling ratio of the third master axis RatioMaster4 LREAL RW Get/Set the coupling ratio of the fourth master axis InGear LREAL R Get coupling status of this axis"},{"location":"SPT_MotionControl/interfaces.html#methods_1","title":"Methods","text":"Method Return Type Description GearIn BOOL Establish coupling with master axes GearOut BOOL Release the coupling with master axes"},{"location":"SPT_MotionControl/interfaces.html#i_camslaveaxis","title":"I_CamSlaveAxis","text":"<p>(extends <code>I_BasicAxis</code>)</p> <p>Defines basic required functionality for a basic NC axis plus camming functions.</p>"},{"location":"SPT_MotionControl/interfaces.html#properties_2","title":"Properties","text":"Property Type Access Description Master REFERENCE TO AXIS_REF RW Get/Set the master axis CamParameters REFERENCE TO ST_CamParameters RW Get/Set the parameter structure for cam definition, options, etc.  MUST BE SET USING REF= RunningTable UDINT RO Returns the index within <code>CamParameters.CamTable</code> is currently running SyncPos LREAL RO Returns the slave position that corresponds to either the current master position (<code>FindSyncPos()</code>) or a specified master position (<code>FindSlavePosition()</code>), depending on which method was called InSync BOOL RO Get synchronization status of this axis"},{"location":"SPT_MotionControl/interfaces.html#methods_2","title":"Methods","text":"Method Return Type Description ChangeMode BOOL Establish coupling with master axes FindSlavePos BOOL Loads a cam table and reports the corresponding slave position (via <code>SyncPos</code>) when the master is at <code>CamParameters.MasterPos</code> FindSyncPos BOOL Loads a cam table and reports the corresponding slave position (via <code>SyncPos</code>) according to the master's current position StartCouple BOOL Couple the slave to the master without performing any sync move StartSync BOOL Couple the slave to the master after performing an initial synchronization move to align the slave with the current master position UpdateTable BOOL Online update of the current cam's point definitions"},{"location":"SPT_MotionControl/interfaces.html#i_motionsequence","title":"I_MotionSequence","text":"<p>(extends <code>I_BaseFB</code>)</p> <p>Defines basic required functionality for external sequence of any sort.</p>"},{"location":"SPT_MotionControl/interfaces.html#properties_3","title":"Properties","text":"Property Type Access Description Axis I_BasicAxis RW Get/Set axis to be controlled by the sequence"},{"location":"SPT_MotionControl/interfaces.html#methods_3","title":"Methods","text":"Method Return Type Description Execute BOOL Start the sequence"},{"location":"SPT_NCI/index.html","title":"Overview","text":"<p>Component to use functionalities of Beckhoff NCI TF5100 within the SPT Framework.</p> <p>SPT_NCI is built on <code>Tc2_Nci</code> all functions within this library can be used via the property <code>Channel</code> provided by the Base <code>FB_Component_NciBase</code>. <code>FB_Component_NciBase</code> provides the basic functions to enable the execution of G-Code within the TC NCI.</p>"},{"location":"SPT_NCI/index.html#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\n    FB_Component_NciBase &lt;|-- FB_ComponentBase\n    FB_Component_NciBase &lt;|-- I_NciBase\n    I_NciBase &lt;|-- I_BaseFB\n    I_NciBase &lt;|-- I_NciChannel \n\n    class I_NciBase{\n        BlockSearchStartPosition\n        Deceleration\n        GetHskMFunction\n        GroupIsBuilt\n        IsHandshake\n        ItpIsRunning\n        Jerk\n        ProgramPath\n        Override\n\n        BlockSearch()\n        BuildNciGroup()\n        DissolveNciGroup()\n        EnableRetrace()\n        InterpreterStart()\n        InterpreterStop()\n        InterpreterStopOnPath()\n        IsFastMFunction()\n        LoadNciProgram()\n        ResumeAfterEstop()\n        RetraceBackward()\n        RetraceForward()\n        SetSearchOptionFlags()\n        StepOnAfterBlocksearch()\n        ConfirmHsk()\n    }\n\n    class I_NciChannel{\n        Channel\n    }\n\n    class FB_Component_NciBase{\n        Q1AxisId\n        Q2AxisId\n        Q3AxisId\n        Q4AxisId\n        Q5AxisId\n        XAxisId\n        YAxisId\n        ZAxisId\n    }\n</code></pre>"},{"location":"SPT_NCI/changelog.html","title":"Changelog","text":""},{"location":"SPT_NCI/changelog.html#40-2025-05-20","title":"[4.0] - 2025-05-20","text":""},{"location":"SPT_NCI/changelog.html#compiled","title":"Compiled","text":"<ul> <li>Using TwinCAT 3.1.4026</li> </ul>"},{"location":"SPT_NCI/changelog.html#39-2025-04-14","title":"[3.9] - 2025-04-14","text":""},{"location":"SPT_NCI/changelog.html#finalizing","title":"Finalizing","text":"<ul> <li>Internal updates and cleanup</li> </ul>"},{"location":"SPT_NCI/changelog.html#33-2025-04-11","title":"[3.3] - 2025-04-11","text":""},{"location":"SPT_NCI/changelog.html#sync","title":"Sync","text":"<ul> <li>Implement same version number across all SPT libraries</li> </ul>"},{"location":"SPT_NCI/changelog.html#added","title":"Added","text":"<ul> <li>Code formatting and comments</li> </ul>"},{"location":"SPT_NCI/changelog.html#323-2024-05-09","title":"[3.2.3] - 2024-05-09","text":""},{"location":"SPT_NCI/changelog.html#changed","title":"Changed","text":"<ul> <li>Allow to Dissolve Nci group while in error state</li> </ul>"},{"location":"SPT_NCI/changelog.html#322-2024-01-04","title":"[3.2.2] - 2024-01-04","text":""},{"location":"SPT_NCI/changelog.html#added_1","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_NCI/duts.html","title":"DUTs","text":""},{"location":"SPT_NCI/duts.html#st_ncichannel","title":"ST_NciChannel","text":"<pre><code>TYPE ST_NciChannel :\n    STRUCT\n        NcToPLC AT %I* : NCTOPLC_NCICHANNEL_REF;\n        PlcToNc AT %Q* : PLCTONC_NCICHANNEL_REF;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_NCI/duts.html#st_ncibase_hmi","title":"ST_NciBase_HMI","text":"<pre><code>TYPE ST_NciBase_HMI :\n    STRUCT\n        Config  : ST_NciBase_Config;\n        Command : ST_NciBase_Command;\n        Status  : ST_NciBase_Status;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_NCI/duts.html#st_ncibase_config","title":"ST_NciBase_Config","text":"<pre><code>TYPE ST_NciBase_Config :\n    STRUCT\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_NCI/duts.html#st_ncibase_command","title":"ST_NciBase_Command","text":"<pre><code>TYPE ST_NciBase_Command :\n    STRUCT\n        BuildGroup         : BOOL;\n        DissolveGroup      : BOOL;\n        LoadNciProgram     : BOOL;\n        ItpStart           : BOOL;\n        ItpStop            : BOOL;\n        ItpEstopStopOnPath : BOOL;\n        Resume             : BOOL;\n        SetOverride        : BOOL;\n        Override           : UDINT; //Override in 0..1000000 (0..100%)\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_NCI/duts.html#st_ncibase_status","title":"ST_NciBase_Status","text":"<pre><code>TYPE ST_NciBase_Status :\n    STRUCT\n        NcToPlc : NCTOPLC_NCICHANNEL_REF;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_NCI/functionblocks.html","title":"Function Blocks","text":""},{"location":"SPT_NCI/functionblocks.html#fb_component_ncibase","title":"FB_Component_NciBase","text":"<p>(extends <code>FB_ComponentBase</code>, implements <code>I_NciChannel</code> and <code>I_NciBase</code>)</p> <p>Serves as manager for NCI basic functions as Load/Start and Stop the NCI channel.</p> <p>Requires to be linked to desired NCI Channel object via <code>NcToPlc</code> and <code>PlcToNc</code>.</p> Quickstart <ol> <li> <p>Create instance of FB.     <pre><code>Nci : FB_Component_NciBase := (Name := 'Nci', Override := 1_000_000);\n</code></pre></p> </li> <li> <p>Link FB to Interpreter <code>NcToPlc</code> and <code>PlcToNc</code>.</p> <p> </p> </li> <li> <p>Assign the Axis Ids and build the Nci Group.</p> <p></p> <pre><code>10: // Startup\n    Nci.XAxisId  := X.Axis.NcToPlc.AxisId;\n    Nci.YAxisId  := Y.Axis.NcToPlc.AxisId;\n    Nci.ZAxisId  := Z.Axis.NcToPlc.AxisId;\n    Nci.Q1AxisId := Q1.Axis.NcToPlc.AxisId;\n    IF Nci.BuildNCIGroup() THEN\n        Seq := Seq + 10;\n    END_IF\n\n20: // Done\n    IF NOT Nci.Busy AND NOT Nci.Error THEN\n        Seq := Seq + 10;\n    END_IF\n</code></pre> </li> <li> <p>Load the .nc file into the interpreter     <pre><code>30: // Load Nc Program\n    Nci.ProgramPath := 'C:\\TwinCAT\\Mc\\Nci\\9999.nc';\n    IF Nci.LoadNciProgram() Then\n        Seq := Seq + 10;\n    END_IF\n\n40: // Done\n    IF NOT Nci.Busy AND NOT Nci.Error THEN\n        Seq := Seq + 10;\n    END_IF\n</code></pre></p> </li> <li> <p>Start Interpreter     <pre><code>50:\n    IF Nci.InterpreterStart() THEN\n        CIRSeq := CIRSeq + 10;\n    END_IF\n\n60:\n    IF Nci.InterpreterState &gt;= NCI_INTERPRETER_RUNNING AND NOT Nci.Busy AND NOT Nci.Error THEN\n        CIRSeq := CIRSeq + 10;\n    END_IF\n70:\n    //Continue\n    ...\n</code></pre></p> </li> </ol> Example .nc file <p>Create file with .nc ending that contains the following code. <pre><code>G00 X100 Y100 Z100\nG00 X0 Y0 Z0\n</code></pre></p>"},{"location":"SPT_NCI/functionblocks.html#properties","title":"Properties","text":"Property Type Access Description Classification ProgramPath String GET/SET Program Path for .nc file to load Config Override UDINT SET Override in 0..1000000 (0..100%) Start-Stop Jerk LREAL SET Jerk for E-Stop deceleration Start-Stop Deceleration LREAL SET Deceleration for E-Stop Start-Stop InterpreterState UINT GET Feedback interpreter state IsHandshake BOOL GET Feedback if handshake M-Code is active M Functions GetHskMFunction INT GET Get number of handshake M-Code M Functions GroupIsBuilt BOOL GET NCI Group is built Config BlockSearchStartPosition ST_ItpBlockSearchStartPosition GET Startposition when blocksearch was executed Retracing XAxisId BOOL GET/SET Axis Id Config YAxisId BOOL GET/SET Axis Id Config ZAxisId BOOL GET/SET Axis Id Config Q1AxisId BOOL GET/SET Axis Id Aux Axis Config Q2AxisId BOOL GET/SET Axis Id Aux Axis Config Q3AxisId BOOL GET/SET Axis Id Aux Axis Config Q4AxisId BOOL GET/SET Axis Id Aux Axis Config Q5AxisId BOOL GET/SET Axis Id Aux Axis Config <p>Note</p> <p>Axis Ids are to find in the corresponding axis object <code>NCTOPLC_AXIS_REF.AxisId</code>.</p>"},{"location":"SPT_NCI/functionblocks.html#methods","title":"Methods","text":"Method Return Type Description Classification BuildNciGroup BOOL Build Nci group with assigned AxisIds. Uses CfgBuildExt3DGroup Config LoadNciProgram BOOL Loads .nc file from <code>ProgramPath</code> into interpreter. Uses ItpLoadProgEx Config DissolveNciGroup BOOL Dissolve built Nci group. Uses CfgReconfigGroup Config InterpreterStart BOOL Start interpreter execution. Uses ItpStartStopEx Start-Stop InterpreterStop BOOL Stop interpreter execution. Uses ItpStartStopEx Start-Stop InterpreterStopOnPath BOOL Stop movement on path, enables the possibility of resume. Uses ItpEstopEx Start-Stop ResumeAfterEstop BOOL Resumes movement after Stop on Path. Uses ItpStepOnAfterEStopEx Start-Stop EnableRetrace BOOL Enable the possibility of retracing on path. Uses ItpEnableFeederBackup Retracing RetraceBackward BOOL Retrace on path. Uses ItpRetraceMoveBackward Retracing RetraceForward BOOL Retrace on path. Uses ItpRetraceMoveForward Retracing BlockSearch BOOL Executes block search in .nc file. Uses ItpBlocksearch Retracing SetSearchOptionFlags BOOL Configuration for Blocksearch. St_ItpBlockSearchOptions Retracing StepOnAfterBlocksearch BOOL Activates the block of the .nc file which was searched and found, starts the interpreter. Uses ItpStepOnAfterBlocksearch Retracing IsFastMFunction BOOL Query for active fast M-Code. If AutoReset is set to <code>TRUE</code> the function is reset in next cycle. Uses ItpIsFastMFunc M Functions ConfirmHsk BOOL Confirms Handshake M-Code. Uses ItpConfirmHsk M Functions <p>Warning</p> <p>Retracing only functional with classic dialect!</p>"},{"location":"SPT_NCI/functionblocks.html#fb_component_ncireadwriterparameter","title":"FB_Component_NciReadWriteRParameter","text":"<p>(extends <code>FB_Component_NciParameterBase</code>, implements <code>I_NciChannel</code>)</p>"},{"location":"SPT_NCI/functionblocks.html#properties_1","title":"Properties","text":"Property Type Access Description Channel I_NciChannel SET Assign NCI Channel to be used for read/write operations. Assign <code>FB_Component_NciBase</code>"},{"location":"SPT_NCI/functionblocks.html#methods_1","title":"Methods","text":"Method Return Type Description Read BOOL Input <code>RParameter</code> assigned to custom defined LREAL or Array of LREAL. Will read the length of the assigned <code>RParameter</code> Datatype length from Nci Channels R-Parameter. <code>StartRParameter</code> defines the first R-Parameter to be read. Write BOOL Input <code>RParameter</code> assigned to custom defined LREAL or Array of LREAL. Will write the length of the assigned <code>RParameter</code> Datatype length to the Nci Channels R-Parameter. <code>StartRParameter</code> defines the first R-Parameter to be written. <p>Example</p> <pre><code>VAR\n    Nci                 : FB_Component_NciBase                      := (Name := 'Nci Channel');\n    NciReadWriteR       : FB_Component_NciReadWriteRParameter       := (Name := 'Read Write R', Channel := Nci);\n\n    RParameterToBeRead  : ARRAY[20..24] OF LREAL; // Read R-Parameter 20-24, a total of 5 R-Parameter from NCI channel.\n    Read                : BOOL;\nEND_VAR\n\nIF Read THEN\n    Read := FALSE; \n    NciReadWriteR.Read(RParameter := RParameterToBeRead, StartRParameter := 20 ); // After successful read the values will be stored in `NciReadWriteR`\nEND_IF\n</code></pre>"},{"location":"SPT_NCI/interfaces.html","title":"Interfaces","text":""},{"location":"SPT_NCI/interfaces.html#i_ncichannel","title":"I_NciChannel","text":"<p>Connection to Nci Channel, access to Channel IO via this interface. </p> <p>Function and further components which need the Channel IO shall be accessing it via this interface.</p>"},{"location":"SPT_NCI/interfaces.html#properties","title":"Properties","text":"Property Type Access Description Channel ST_NciChannel GET Get reference of Channel IO"},{"location":"SPT_NCI/interfaces.html#i_ncibase","title":"I_NciBase","text":"<p>Interface for basic NCI functions as Load/Start and Stop Interpreter.</p> <p>All commands return <code>TRUE</code> if command was accepted.</p>"},{"location":"SPT_NCI/interfaces.html#properties_1","title":"Properties","text":"Property Type Access Description ProgramPath String GET/SET Program Path for .nc file to load Override UDINT SET Override in 0..1000000 (0..100%) Jerk LREAL SET Jerk for E-Stop deceleration Deceleration LREAL SET Deceleration for E-Stop InterpreterState UINT GET Feedback interpreter state IsHandshake BOOL GET Feedback if handshake M-Code is active GetHskMFunction INT GET Get number of handshake M-Code GroupIsBuilt BOOL GET NCI Group is built BlockSearchStartPosition ST_ItpBlockSearchStartPosition GET Startposition when blocksearch was executed"},{"location":"SPT_NCI/interfaces.html#methods","title":"Methods","text":"Method Return Type Description BuildNciGroup BOOL Build Nci group with assigned AxisIds. Uses CfgBuildExt3DGroup LoadNciProgram BOOL Loads .nc file from <code>ProgramPath</code> into interpreter. Uses ItpLoadProgEx DissolveNciGroup BOOL Dissolve built Nci group. Uses CfgReconfigGroup InterpreterStart BOOL Start interpreter execution. Uses ItpStartStopEx InterpreterStop BOOL Stop interpreter execution. Uses ItpStartStopEx InterpreterStopOnPath BOOL Stop movement on path, enables the possibility of resume. Uses ItpEstopEx ResumeAfterEstop BOOL Resumes movement after Stop on Path. Uses ItpStepOnAfterEStopEx EnableRetrace BOOL Enable the possibility of retracing on path. Uses ItpEnableFeederBackup RetraceBackward BOOL Retrace on path. Uses ItpRetraceMoveBackward RetraceForward BOOL Retrace on path. Uses ItpRetraceMoveForward IsFastMFunction BOOL Query for active fast M-Code. If AutoReset is set to <code>TRUE</code> the function is reset in next cycle. Uses ItpIsFastMFunc ConfirmHsk BOOL Confirms Handshake M-Code. Uses ItpConfirmHsk BlockSearch BOOL Executes block search in .nc file. Uses ItpBlocksearch SetSearchOptionFlags BOOL Configuration for Blocksearch. St_ItpBlockSearchOptions StepOnAfterBlocksearch BOOL Activates the block of the .nc file which was searched and found, starts the interpreter. Uses ItpStepOnAfterBlocksearch"},{"location":"SPT_Utilities/index.html","title":"Overview","text":"<p>Miscellaneous functions and function blocks for a variety of common tasks.</p>"},{"location":"SPT_Utilities/changelog.html","title":"Changelog","text":""},{"location":"SPT_Utilities/changelog.html#40-2025-05-20","title":"[4.0] - 2025-05-20","text":""},{"location":"SPT_Utilities/changelog.html#compiled","title":"Compiled","text":"<ul> <li>Using TwinCAT 3.1.4026</li> </ul>"},{"location":"SPT_Utilities/changelog.html#39-2025-04-14","title":"[3.9] - 2025-04-14","text":""},{"location":"SPT_Utilities/changelog.html#finalizing","title":"Finalizing","text":"<ul> <li>Internal updates and cleanup</li> </ul>"},{"location":"SPT_Utilities/changelog.html#33-2025-04-11","title":"[3.3] - 2025-04-11","text":""},{"location":"SPT_Utilities/changelog.html#sync","title":"Sync","text":"<ul> <li>Implement same version number across all SPT libraries</li> </ul>"},{"location":"SPT_Utilities/changelog.html#added","title":"Added","text":"<ul> <li>Code formatting and comments</li> </ul>"},{"location":"SPT_Utilities/changelog.html#324-2025-02-25","title":"[3.2.4] - 2025-02-25","text":""},{"location":"SPT_Utilities/changelog.html#update","title":"Update","text":"<ul> <li>New calculations for managing rollover in FIFO and Ring buffers</li> <li>New error checking for valid references in all buffers</li> </ul>"},{"location":"SPT_Utilities/changelog.html#323-2024-01-04","title":"[3.2.3] - 2024-01-04","text":""},{"location":"SPT_Utilities/changelog.html#added_1","title":"Added","text":"<ul> <li>Features to Json File Handler, create path, create file, resolve to any type.</li> </ul>"},{"location":"SPT_Utilities/changelog.html#fixed","title":"Fixed","text":"<ul> <li>Dependency on INC1 in Buffer FBs</li> </ul>"},{"location":"SPT_Utilities/changelog.html#322-2024-01-04","title":"[3.2.2] - 2024-01-04","text":""},{"location":"SPT_Utilities/changelog.html#added_2","title":"Added","text":"<ul> <li>Added FB_Component_JsonFileHandler</li> </ul>"},{"location":"SPT_Utilities/changelog.html#321-2023-11-13","title":"[3.2.1] - 2023-11-13","text":""},{"location":"SPT_Utilities/changelog.html#added_3","title":"Added","text":"<ul> <li>Added FBs for handling arrays of type ANY</li> </ul>"},{"location":"SPT_Utilities/changelog.html#320-2023-06-02","title":"[3.2.0] - 2023-06-02","text":""},{"location":"SPT_Utilities/changelog.html#added_4","title":"Added","text":"<ul> <li>Added license file to project (MIT License)</li> </ul>"},{"location":"SPT_Utilities/changelog.html#303-2023-05-12","title":"[3.0.3] - 2023-05-12","text":""},{"location":"SPT_Utilities/changelog.html#changed","title":"Changed","text":"<ul> <li>Corrected library references</li> </ul>"},{"location":"SPT_Utilities/changelog.html#302-2023-04-06","title":"[3.0.2] - 2023-04-06","text":""},{"location":"SPT_Utilities/changelog.html#added_5","title":"Added","text":"<ul> <li>Moved Tracing listener interfaces and function blocks from SPT_Tracing library (now deprecated)</li> <li>Added FB_SimpleRateLimiter</li> </ul>"},{"location":"SPT_Utilities/changelog.html#301-2022-10-18","title":"[3.0.1] - 2022-10-18","text":""},{"location":"SPT_Utilities/changelog.html#added_6","title":"Added","text":"<ul> <li>Added analog scaling function F_ApplyScaling</li> </ul>"},{"location":"SPT_Utilities/changelog.html#300-2022-10-05","title":"[3.0.0] - 2022-10-05","text":""},{"location":"SPT_Utilities/changelog.html#added_7","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_Utilities/duts.html","title":"DUTs","text":""},{"location":"SPT_Utilities/duts.html#st_scalingparameters","title":"ST_ScalingParameters","text":"<pre><code>TYPE ST_ScalingParameters :\n    STRUCT\n        Input_Minimum  : LREAL := 0;\n        Input_Maximum  : LREAL := 100;\n        Output_Minimum : LREAL := 0;\n        Output_Maximum : LREAL := 4096;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Utilities/duts.html#st_tracemessage","title":"ST_TraceMessage","text":"<pre><code>TYPE ST_TraceMessage :\n    STRUCT\n        Timestamp : T_MaxString;\n        Source    : T_MaxString;\n        Context   : T_MaxString;\n        ScanCount : UDINT;\n        Flags     : UDINT;\n        Message   : T_MaxString;\n        Json      : T_MaxString;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Utilities/duts.html#st_tree_indexbased_node","title":"ST_Tree_IndexBased_Node","text":"<pre><code>TYPE ST_Tree_IndexBased_Node :\n    STRUCT\n        Name       : STRING;\n        ChildCount : DINT;\n        Parent     : DINT;\n        Children   : ARRAY[0..15] OF DINT;\n        Depth      : DINT;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Utilities/functionblocks.html","title":"Function Blocks","text":""},{"location":"SPT_Utilities/functionblocks.html#fb_fifo_ulint_array","title":"FB_FIFO_ULINT_Array","text":""},{"location":"SPT_Utilities/functionblocks.html#properties","title":"Properties","text":"Property Type Access Description EntryCount DINT RO Number of entries currently in buffer LastInValue ULINT RO Newest value in buffer NextOutValue ULINT RO Oldest value in buffer"},{"location":"SPT_Utilities/functionblocks.html#methods","title":"Methods","text":"Method Return Type Access Description AddEntry BOOL PUBLIC Adds a value to the buffer RemoveEntry BOOL PUBLIC Removes the oldest value from the buffer"},{"location":"SPT_Utilities/functionblocks.html#addentry","title":"AddEntry()","text":"<pre><code>METHOD AddEntry : BOOL\n\nVAR_INPUT\n    Entry : ULINT;\nEND_VAR\n</code></pre> <p>Adds <code>Entry</code> to the buffer.  Returns <code>TRUE</code> on success, <code>FALSE</code> if buffer is full.</p>"},{"location":"SPT_Utilities/functionblocks.html#removeentry","title":"RemoveEntry()","text":"<p><code>METHOD RemoveEntry : BOOL</code></p> <p>Removes the oldest value from the buffer.  Returns <code>TRUE</code> on success, <code>FALSE</code> if buffer was already empty.</p>"},{"location":"SPT_Utilities/functionblocks.html#fb_messagelistener","title":"FB_MessageListener","text":"<p>(<code>FINAL</code>, extends <code>Tc3_EventLogger.FB_ListenerBase2</code>)</p> <p>Internal function block whose purpose is to listen to the event logger, filtering only trace messages.  Parses events into <code>ST_TraceMessage</code> which is then passed up to the parent function block via callback (<code>FB_TraceListenerBase</code>).</p>"},{"location":"SPT_Utilities/functionblocks.html#properties_1","title":"Properties","text":"Property Type Access Description Listener I_TraceListener RW Function block who should receive callback when event is raised"},{"location":"SPT_Utilities/functionblocks.html#fb_simpleratelimiter","title":"FB_SimpleRateLimiter","text":"<p>Limits the rate of change of <code>Y</code> toward <code>TargetValue</code> in both the positive and negative direction.</p> <pre><code>FUNCTION_BLOCK FB_SimpleRateLimiter\nVAR_INPUT\n    Enable        : BOOL;\n    TargetValue   : LREAL;\n    Minimum       : LREAL;\n    Maximum       : LREAL;\n    Rate_Increase : LREAL; //Units per second\n    Rate_Decrease : LREAL; //Units per second\nEND_VAR\n\nVAR_OUTPUT\n    Y : LREAL;\nEND_VAR\n</code></pre>"},{"location":"SPT_Utilities/functionblocks.html#fb_tracelistenerbase","title":"FB_TraceListenerBase","text":"<p>(Abstract, extends <code>FB_CyclicFB</code>, implements <code>I_TraceListener</code>)</p> <p>Base trace log listener block which can be inherited to provide alternate means of relaying trace messages.  Contains local instance of <code>FB_MessageListener</code> which will automatically handle event filtering.</p> <p>Note</p> <p>See I_TraceListener and ST_TraceMessage for more information.</p> <p>Why would I want this?</p> <p>Trace messages are always logged by the TC3 Event Logger system.  In some cases, you might want to forward or persist them by some other means. This function block provides an easy mechanism to do this. Create a new function block which extends <code>FB_TraceListenerBase</code> and override the <code>OnTraceReceived()</code> method.  From there you can, for instance, write the messages to a CSV file or send them via REST API to another system.</p>"},{"location":"SPT_Utilities/functionblocks.html#methods_1","title":"Methods","text":"Method Return Type Access Description OnTraceReceived null PUBLIC Abstract callback method to be overridden to implement alternate event handling"},{"location":"SPT_Utilities/functionblocks.html#fb_tree_indexbased","title":"FB_Tree_IndexBased","text":"<p>(Implements <code>I_Tree_IndexBased</code>)</p> <p>Stores parent-child relationships of a 'tree' of nodes by name.</p> <p>Note</p> <p>See I_Tree_IndexBased for more information.</p>"},{"location":"SPT_Utilities/functionblocks.html#methods_2","title":"Methods","text":"Method Return Type Access Description GetIndexByName DINT PUBLIC Returns the node ID of the node with the name specified"},{"location":"SPT_Utilities/functionblocks.html#any-buffers","title":"ANY Buffers","text":""},{"location":"SPT_Utilities/functionblocks.html#base","title":"Base","text":"<p>This is a set of utilities that are used with an array of any datatype.  </p> Type Description BUFFER Elements can be added until full, simpel buffer with FULL detection and reset functionality FIFO (aka RING without overwrite) Elements can be added until full, oldest added element can be fetched, the buffer is constantly looped like a ring buffer for best efficiency LIFO (aka STACK) Elements can be added until full, newest added element can be fetched RING Elements can be added, oldest element can be fetched, when full when written, the oldest element is OVERWRITTEN ARRAY Elements can be added, removed, exchanged at a certain location in the array"},{"location":"SPT_Utilities/functionblocks.html#class-diagram","title":"Class Diagram","text":"<p>The buffer style functions all extend from FB_AnyBase.  This holds the common use of each buffer type.  The ARRAY type stands on its own.</p> <pre><code>classDiagram\n\nclass FB_AnyBase{\n    _LowerBoundary : DINT\n    _UpperBoundary : DINT\n    _Enable        : BOOL\n    _Empty         : BOOL\n    _Full          : BOOL\n\n    CheckBoundary()\n}\n\nFB_BaseFB&lt;|--FB_AnyBase</code></pre>"},{"location":"SPT_Utilities/functionblocks.html#properties_2","title":"Properties","text":"Name Type Description LowerBoundary DINT This is the lower boundary of the array being used UpperBoundary DINT This is the upper boundary of the array being used Enable BOOL This will enable the methods Empty BOOL Is the buffer type empty Full BOOL Is the buffer type full"},{"location":"SPT_Utilities/functionblocks.html#methods_3","title":"Methods","text":"Name Return Type Description CheckBoundary BOOL This will check the boundaries entered to make sure they are good"},{"location":"SPT_Utilities/functionblocks.html#trace","title":"Trace","text":"<p>Anytime the properties that are used are not good, a message is sent to the event system using the FB_BaseFB Trace method and the _Error bit is set.  Depending on the type of function, traces are sent if object is _FULL when trying to add data.</p>"},{"location":"SPT_Utilities/functionblocks.html#buffer-any","title":"Buffer ANY","text":"<p>Elements can be added until full, simple buffer with FULL detection and reset functionality </p> <p>This object does not give the user the ability to read the array.  This would be done outside this functionality.</p>"},{"location":"SPT_Utilities/functionblocks.html#class-diagram_1","title":"Class Diagram","text":"<pre><code>classDiagram\n\nFB_BaseFB&lt;|--FB_AnyBase\n\nclass FB_BufferAny{\n    Push()\n    Reset()   \n}\n\nFB_AnyBase&lt;|--FB_BufferAny</code></pre>"},{"location":"SPT_Utilities/functionblocks.html#methods_4","title":"Methods","text":"Name Return Type Description Push BOOL This will add data into the array at the next index.  It will cause an _ERROR when it is already _FULL Reset BOOL This will empty the array and put the index to the beginning"},{"location":"SPT_Utilities/functionblocks.html#fifo-any","title":"FIFO ANY","text":"<p>(aka RING without overwrite) Elements can be added until full, oldest added element can be fetched, the buffer is constantly looped like a ring buffer for best efficiency</p>"},{"location":"SPT_Utilities/functionblocks.html#class-diagram_2","title":"Class Diagram","text":"<pre><code>classDiagram\n\n\nFB_BaseFB&lt;|--FB_AnyBase\n\nclass FB_FIFOAny{\n    Push()\n    Pop()\n    Reset()   \n}\n\nFB_AnyBase&lt;|--FB_FIFOAny</code></pre>"},{"location":"SPT_Utilities/functionblocks.html#methods_5","title":"Methods","text":"Name Return Type Description Push BOOL This will add data into the array at the next index.  It will cause an _ERROR when it is already _FULL Pop BOOL This will extract the oldest data in the array.  It will cause an _ERROR if called when _EMPTY Reset BOOL This will empty the array and put the index to the beginning"},{"location":"SPT_Utilities/functionblocks.html#lifo-any","title":"LIFO ANY","text":"<p>(aka STACK) Elements can be added until full, newest added element can be fetched</p>"},{"location":"SPT_Utilities/functionblocks.html#class-diagrm","title":"Class Diagrm","text":"<pre><code>classDiagram\n\n\nFB_BaseFB&lt;|--FB_AnyBase\n\nclass FB_LIFOAny{\n    Push()\n    Pop()\n    Reset()   \n}\n\nFB_AnyBase&lt;|--FB_LIFOAny</code></pre>"},{"location":"SPT_Utilities/functionblocks.html#methods_6","title":"Methods","text":"Name Return Type Description Push BOOL This will add data into the array at the next index.  It will cause an _ERROR when it is already _FULL Pop BOOL This will extract the newest data in the array.  It will cause an _ERROR if called when _EMPTY Reset BOOL This will empty the array and put the index to the beginning"},{"location":"SPT_Utilities/functionblocks.html#ring-any","title":"Ring ANY","text":"<p>Elements can be added, oldest element can be fetched, when full when written, the oldest element is OVERWRITTEN</p>"},{"location":"SPT_Utilities/functionblocks.html#class-diagram_3","title":"Class Diagram","text":"<pre><code>classDiagram\n\n\nFB_BaseFB&lt;|--FB_AnyBase\n\nclass FB_RingAny{\n    Push()\n    Pop()\n    Reset()   \n}\n\nFB_AnyBase&lt;|--FB_RingAny</code></pre>"},{"location":"SPT_Utilities/functionblocks.html#methods_7","title":"Methods","text":"Name Return Type Description Push BOOL This will add data into the array at the next index.  If _FULL, then oldest element is OVERWRITTEN Pop BOOL This will extract the oldest data in the array.  It will cause an _ERROR if called when _EMPTY Reset BOOL This will empty the array and put the index to the beginning"},{"location":"SPT_Utilities/functionblocks.html#any-array","title":"ANY Array","text":"<p>Elements can be added, removed, exchanged at a certain location in the array</p>"},{"location":"SPT_Utilities/functionblocks.html#class-diagram_4","title":"Class Diagram","text":"<pre><code>classDiagram\n\n\nFB_BaseFB&lt;|--FB_ArrayAny\n\nclass FB_ArrayAny{\n    Enable : BOOL\n    LowerBoundary : DINT\n    UpperBoundary : DINT\n\n    Delete()\n    Insert()\n    Exchange()\n    Reset()   \n}\n</code></pre>"},{"location":"SPT_Utilities/functionblocks.html#properties_3","title":"Properties","text":"Name Type Description LowerBoundary DINT This is the lower boundary of the array being used UpperBoundary DINT This is the upper boundary of the array being used Enable BOOL This will enable the methods"},{"location":"SPT_Utilities/functionblocks.html#methods_8","title":"Methods","text":"Name Return Type Passed Params Description Delete BOOL ArrayIn:ANY,DataIn:ANY,Location:DINT This will delete the data at the location in the array and shift up the rest below and make the UpperBound value 0 Insert BOOL ArrayIn:ANY,DataIn:ANY,Location:DINT This will insert the DataIn at the location in the array and shift down the rest of the array.  This will lose the data on the end of the array Exchange BOOL ArrayIn:ANY,DataIn:ANY,Location:DINT This will insert the DataIn at the location in the array losing what was at the location.  No shifting of the other data Reset ArrayIn : ANY This will empty the array and put the index to the beginning"},{"location":"SPT_Utilities/functionblocks.html#fb_component_jsonfilehandler","title":"FB_Component_JsonFileHandler","text":"<p>Basic handler for Json files. LoadFile() will load document or create file in <code>Path</code> if not existent. </p> <p>Same patter is followed in all <code>UpdateXYZ()</code> and <code>ReadXYZ()</code> methods, if member does not exist member will be created in file.</p>"},{"location":"SPT_Utilities/functionblocks.html#properties_4","title":"Properties","text":"Name Type Description Path String Path to Json document e.g. <code>C:\\MyJsonFile.json</code>"},{"location":"SPT_Utilities/functionblocks.html#methods_9","title":"Methods","text":"<p>All methods return <code>TRUE</code> if command has been accepted.</p> Name Return Type Description LoadFile BOOL Loads Json document from <code>Path</code>, creates json file it not present in <code>Path</code>. ReadBool BOOL Read member from json file and display in <code>Value</code> output, creates member if not found in file. ReadDInt BOOL Read member from json file and display in <code>Value</code> output, creates member if not found in file. ReadLREAL BOOL Read member from json file and display in <code>Value</code> output, creates member if not found in file. ReadString BOOL Read member from json file and display in <code>Value</code> output, creates member if not found in file. UpdateBool BOOL Update member in json file, creates member if not found in file. UpdateDInt BOOL Update member in json file, creates member if not found in file. UpdateLreal BOOL Update member in json file, creates member if not found in file. UpdateString BOOL Update member in json file, creates member if not found in file."},{"location":"SPT_Utilities/functions.html","title":"Functions","text":""},{"location":"SPT_Utilities/functions.html#f_applyscaling","title":"F_ApplyScaling","text":"<p>Generic analog scaling function</p> <p>Note</p> <p>See ST_ScalingParameters for more information.</p> <pre><code>FUNCTION F_ApplyScaling : LREAL\nVAR_INPUT\n    X : LREAL;\n    Parameters : ST_ScalingParameters;\nEND_VAR\n</code></pre>"},{"location":"SPT_Utilities/functions.html#f_comparelreal","title":"F_CompareLREAL","text":"<p>Returns true if <code>Val1</code> and <code>Val2</code> are within +/- <code>Tolerance</code> of each other.</p> <p>Why would I want this?</p> <p>Floating-point values should not be compared directly for equality.  See here for more information.</p> <pre><code>FUNCTION F_CompareLREAL : BOOL\nVAR_INPUT\n    Val1      : LREAL;\n    Val2      : LREAL;\n    Tolerance : LREAL;\nEND_VAR\n</code></pre>"},{"location":"SPT_Utilities/functions.html#f_comparereal","title":"F_CompareREAL","text":"<p>Returns true if <code>Val1</code> and <code>Val2</code> are within +/- <code>Tolerance</code> of each other.</p> <p>Why would I want this?</p> <p>Floating-point values should not be compared directly for equality.  See here for more information.</p> <pre><code>FUNCTION F_CompareREAL : BOOL\nVAR_INPUT\n    Val1      : REAL;\n    Val2      : REAL;\n    Tolerance : REAL;\nEND_VAR\n</code></pre>"},{"location":"SPT_Utilities/functions.html#f_lreal_roundtoplace","title":"F_LREAL_RoundToPlace","text":"<p>Returns <code>In</code> rounded to <code>DecimalPlaces</code>.</p> <pre><code>FUNCTION F_LREAL_RoundToPlace : LREAL //! Rounded number\nVAR_INPUT\n    In            : LREAL; //! Number to be rounded\n    DecimalPlaces : DINT;  //! Number of decimal places\nEND_VAR\n</code></pre>"},{"location":"SPT_Utilities/interfaces.html","title":"Interfaces","text":""},{"location":"SPT_Utilities/interfaces.html#i_tracelistener","title":"I_TraceListener","text":"<p>Defines basic required functionality trace listener function blocks</p> <p>Note</p> <p>See FB_TraceListenerBase for more information.</p>"},{"location":"SPT_Utilities/interfaces.html#methods","title":"Methods","text":"Method Return Type Description OnTraceReceived null Callback which is fired when a trace message has been sent to the event log"},{"location":"SPT_Utilities/interfaces.html#i_tree_indexbased","title":"I_Tree_IndexBased","text":"<p>Defines basic required functionality index-based trees</p> <p>Note</p> <p>See FB_Tree_IndexBased for more information.</p>"},{"location":"SPT_Utilities/interfaces.html#methods_1","title":"Methods","text":"Method Return Type Description AddNodeAsChildByName null Adds a new node to the tree underneath the node specified as by <code>ParentName</code>"},{"location":"SPT_Utilities/interfaces.html#i_jsonfilehandler","title":"I_JsonFileHandler","text":"<p>Defines basic methods for json file handling.</p> <p>Note</p> <p>See FB_Component_JsonFileHandler for more information.</p>"},{"location":"SPT_Utilities/interfaces.html#methods_2","title":"Methods","text":"<p>All methods return <code>TRUE</code> if command has been accepted.</p> Name Return Type Description LoadFile BOOL Loads Json document from <code>Path</code>, creates json file it not present in <code>Path</code>. ReadBool BOOL Read member from json file and display in <code>Value</code> output, creates member if not found in file. ReadDInt BOOL Read member from json file and display in <code>Value</code> output, creates member if not found in file. ReadLREAL BOOL Read member from json file and display in <code>Value</code> output, creates member if not found in file. ReadString BOOL Read member from json file and display in <code>Value</code> output, creates member if not found in file. UpdateBool BOOL Update member in json file, creates member if not found in file. UpdateDInt BOOL Update member in json file, creates member if not found in file. UpdateLreal BOOL Update member in json file, creates member if not found in file. UpdateString BOOL Update member in json file, creates member if not found in file."},{"location":"SPT_Vision/VisionBlob.html","title":"Vison Processing Blob","text":""},{"location":"SPT_Vision/VisionBlob.html#code","title":"Code","text":"<pre><code>// Convert Images into the necessary color space\nhr := F_VN_GetPixelFormat(ipImageIn, PixelFormat, hr);\nIF PixelFormat.nChannels = 3 THEN\n    hr := F_VN_CopyImage(ipImageIn, ipImageRes, hr);\n    hr := F_VN_ConvertColorSpace(ipImageRes,\n                                 ipImageIn,\n                                 TCVN_CST_RGB_TO_GRAY,\n                                 hr);\nELSE\n    hr := F_VN_ConvertColorSpace(ipImageIn,\n                                 ipImageRes,\n                                 TCVN_CST_Gray_TO_RGB,\n                                 hr);\nEND_IF\n\n// Image Segementation\nhr := F_VN_Threshold(ipImageIn,\n                     ipImageWork,\n                     _BlobParams.fMinThreshold,\n                     255,\n                     TCVN_TT_Binary,\n                     hr);\n// Start Watchdog - DetectBlobs - Stop Watchdog\nhrWD   := F_VN_StartRelWatchdog(tStop, S_OK);\nhrFunc := F_VN_DetectBlobs(ipSrcImage     := ipImageWork,\n                           ipBlobContours := ipContourList,\n                           stParams       := _BlobParams,\n                           hrPrev         := hr);\n\nhrWD := F_VN_StopWatchdog(hrWD, tRest =&gt; tRest, nFractionProcessed =&gt; nFraction);\n\n\n//Clear Results and set new results-Number of Blobs\nMEMSET(ADR(Results), 0, SIZEOF(Results));\nulint_ref REF= (NumberOfBlobs);\nhr        := F_VN_GetNumberOfElements(ipContainer := ipContourList, nNumberOfElements := ulint_ref, hrPrev := hr);\nIF NumberOfBlobs &gt; 0 THEN\n    FOR i := 0 TO (NumberOfBlobs - 1) BY 1 DO\n        hr := F_VN_GetAt_ITcVnContainer(ipSrcContainer  := ipContourList,\n                                        ipDestContainer := ipResultContainer,\n                                        nIndex          := i,\n                                        hrPrev          := hr);\n\n        hr := F_VN_ContourArea(ipContour := ipResultContainer, fArea := Results[i + 1].Area, hrPrev := hr);\n        hr := F_VN_ContourCenterOfMass(ipContour := ipResultContainer, aCenterOfMass := Results[i+1].CenterOfMass, hrPrev := hr);\n\n        //More items\n        hr := F_VN_ContourCircularity(ipContour := ipResultContainer, fCircularity := Results[i + 1].Circularity, hrPrev := hr);\n        hr := F_VN_ContourConvexity(ipContour := ipResultContainer, fConvexity := Results[i + 1].Convexity, hrPrev := hr);\n        hr := F_VN_ContourEccentricity(ipContour := ipResultContainer, fEccentricity := Results[i + 1].Eccentricity, hrPrev := hr);\n        hr := F_VN_ContourInertiaRatio(ipContour := ipResultContainer, fInertiaRatio := Results[i + 1].InertiaRatio, hrPrev := hr);\n        hr := F_VN_ContourOrientation(ipContour := ipResultContainer, stOrientation := Results[i+1].Orientation, hrPrev := hr);\n        hr := F_VN_ContourPerimeter(ipContour  := ipResultContainer,\n                                    fPerimeter := Results[i + 1].Perimeter,\n                                    bClosed    := TRUE,\n                                    hrPrev     := hr);\n\n        hr := F_VN_ContourRoundness(ipContour := ipResultContainer, fRoundness := Results[i + 1].Roundness, hrPrev := hr);\n\n    END_FOR\nEND_IF\n\n(* Draw Result Image\n// --------------------------------------------------------------*)\nhr := F_VN_DrawContours(ipContourList,\n                        -1,\n                        ipImageRes,\n                        GVL_VisionColor.ColorGreen,\n                        3,\n                        hr);\n\nIF NumberOfBlobs &gt; 0 THEN\n    FOR i := 0 TO (NumberOfBlobs - 1) DO\n        hr := F_VN_GetAt_ITcVnContainer(ipSrcContainer  := ipContourList,\n                                        ipDestContainer := ipResultContainer,\n                                        nIndex          := i,\n                                        hrPrev          := hr);\n\n        //hr     := F_VN_UprightBoundingRectangle(ipResultContainer, Rect, hr);\n        Text := TO_STRING(i + 1);\n        hr   := F_VN_PutText(Text,\n                             ipImageRes,\n                             TO_UDINT(Results[i + 1].CenterOfMass[0]) - 20,\n                             TO_UDINT(Results[i + 1].CenterOfMass[1]) + 20,\n                             TCVN_FT_HERSHEY_DUPLEX,\n                             2,\n                             GVL_VisionColor.ColorMagenta,\n                             hr);\n    END_FOR\nEND_IF\n\n// Display Input Image\nhr := F_VN_TransformIntoDisplayableImage(ipImageIn, ipImageInDisp, hr);\n\n// Display Result Image\nhr := F_VN_TransformIntoDisplayableImage(ipImageRes, ipImageResDisp, hr);\n\n// Display Threshold Image\nhr := F_VN_TransformIntoDisplayableImage(ipImageWork, ipImageThresholdDisp, hr);\n</code></pre>"},{"location":"SPT_Vision/VisionBlob.html#blob-parameters","title":"Blob Parameters","text":"Name Type Default Description FilterByArea BOOL TRUE Enable filtering by area (fMinArea &lt;= area &lt;= fMaxArea); strongly recommended to activate for filtering noise with fMinArea. FilterByCircularity BOOL FALSE Enable filtering by circularity (fMinCircularity &lt;= circularity(4pi * area / perimeter^2) &lt;= fMaxCircularity). FilterByConvexity BOOL FALSE Enable filtering by convexity (fMinConvexity &lt;= convexity(area / hullArea) &lt;= fMaxConvexity). FilterByEccentricity BOOL FALSE Enable filtering by eccentricity (fMinEccentricity &lt;= eccentricity &lt;= fMaxEccentricity). FilterByInertiaRatio BOOL FALSE Enable filtering by inertia ratio (fMinInertiaRatio &lt;= inertia ratio &lt;= fMaxInertiaRatio). MinArea REAL 10 Min estimated blob area in pixel MaxArea REAL 100000000 Max estimated blob area in pixel MinCircularity REAL 0 Min circularity (1.0: ideal circle, &lt; 1: less circular, 0: not circular at all) MaxCircularity REAL 1 Max circularity (1.0: ideal circle, &lt; 1: less circular, 0: not circular at all) MinConvexity REAL 0 Min convexity (1.0: blob fully convex, &lt; 1: less convex) MaxConvexity REAL 1 Max convexity (1.0: blob fully convex, &lt; 1: less convex) MinEccentricity REAL 0 Min eccentricity (0.0: circular, 1.0: linear) MaxEccentricity REAL 1 Max eccentricity (0.0: circular, 1.0: linear) MinInertiaRatio REAL 0 Min inertia ratio (1.0: equal width and height, 0.0: linear) MinInertiaRatio REAL 0 Max inertia ratio (1.0: equal width and height, 0.0: linear) ThresholdType ETcVnThresholdType TCVN_TT_BINARY Threshold type for internally applied threshold method (OTSU_XXX only supported for USINT images). MinThreshold REAL 30 Threshold to start with (if fThresholdStep &gt; 0, otherwise this is the only threshold used). MaxThreshold REAL 225 MinThreshold : REAL := 30 ThresholdStep REAL 0 Sets to 0 if only 1 threshold should be used (much faster than multiple thresholds and combining the results). MinBlobDistance REAL 5 Minimum distance between the center points of two different blobs (only used if fThresholdStep &gt; 0; if distance &lt; fMinBlobDistance, the blobs are treated as the same). MinRepeatability UDINT 2 Minimum number of threshold steps, for which the same contour has to be detected (only used if fThresholdStep &gt; 0; same means center point distance &lt; fMinBlobDistance). BlobCombination ETcVnBlobCombination TCVN_BC_MEDIAN_THRESHOLD Selects, which of the multi-threshold blob contours should be returned."},{"location":"SPT_Vision/VisionBlob.html#results","title":"Results","text":"<pre><code>TYPE ST_BlobResults :\n    STRUCT\n        Area           : LREAL;\n        CenterOfMass   : TcVnPoint2_LREAL;\n        Circularity    : LREAL;\n        Convexity      : LREAL;\n        Eccentricity   : LREAL;\n        ExtremePoint   : TcVnPoint2_LREAL;\n        InertiaRatio   : LREAL;\n        Moments        : TcVnMoments;\n        Orientation    : TcVnRotatedRectangle;\n        OrientationExp : TcVnRotatedRectangle;\n        Perimeter      : LREAL;\n        Roundness      : LREAL;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_Vision/VisionConcept.html","title":"Overview","text":"<p>This is the documentation on the SPT Vision Library objects.   </p> <p>The vision process takes some time, so there will be another Task seperate from the PLC Task.  A good name for this can be VisionMain.  In this task, there will be an instance of the vision process type you choose (see further documentation).  In the PLC task under the machine module or equipment module you will have an instance of the FB_PLCTask.  Together these components will communicate by using the TwinCAT Process data space and linking variables.</p>"},{"location":"SPT_Vision/VisionConcept.html#block-diagram","title":"Block Diagram","text":""},{"location":"SPT_Vision/VisionConcept.html#process-data","title":"Process Data","text":"Name Type Output From Description RunVision BOOL PLC Task This will run the vision to aquiring when high and stop the aquiring when low SoftwareTrigger BOOL PLC Task This will software trigger the camera to take an image Reset BOOL PLC Task This is used to reset vision system when under error CameraState ETcVnCameraState Vision Task This is a status of the camera's state ResultsAvailable BOOL Vision Task This will let the PLC task know that there are results NumberOfResults UDINT Vision Task This is the number of elements found in the results Results ARRAY[1..MAX_BUFFER_BYTES] of BYTE Vision Task The data type that is put into buffer will be decided at application time from the process of analysis.  Each side will have to define the structure of results needed for PLC task to function Error BOOL Vision Task This is set when there is an error ErrorID UDINT Vision Task This is the value of the Alarm when one is set"},{"location":"SPT_Vision/VisionConcept.html#global-parameter-list","title":"Global Parameter List","text":"<p>This list can be edited in the Library references for your project to be the size needed for your application.</p> <pre><code>{attribute 'qualified_only'}\nVAR_GLOBAL CONSTANT\n    MAX_BUFFER_BYTES : UDINT := 1000;\nEND_VAR\n</code></pre>"},{"location":"SPT_Vision/VisionConcept.html#typical-flow-diagram-software-trigger","title":"Typical Flow Diagram Software Trigger","text":"<pre><code>sequenceDiagram\n\nparticipant plc as PlcApp\nparticipant plctask as PlcTaskComponent\nparticipant visiontask as VisionTaskComponent\nparticipant c as Camera\nplc-&gt;&gt;plctask: Run Vision\nplctask-&gt;&gt;visiontask: RunVision\nloop Get to acquire\nvisiontask-&gt;&gt;c: Initialize,open,acquire\nc-&gt;&gt;visiontask: Camera States\nend\nvisiontask-&gt;&gt;plctask: Camera State(acquire)\nplctask-&gt;&gt;plc: Camera State(acquire)\nloop vision cylce\nplc-&gt;&gt;plctask: Software Trigger\nplctask-&gt;&gt;visiontask: SoftwareTrigger\nvisiontask-&gt;&gt;c: Trigger\nc-&gt;&gt;c: Capture Image\nc-&gt;&gt;visiontask: Image\nvisiontask-&gt;&gt;visiontask: Process the Image\nvisiontask-&gt;&gt;plctask:Results\nplctask-&gt;&gt;plc:Results\nNote over plc: Copy Results \nend</code></pre>"},{"location":"SPT_Vision/VisionDetection.html","title":"Overview","text":"<p>The concept is that this FB and its methods will use the base class to take a picture and the process it and return elements that fit the processing with the following Results as a minimum:</p> <ol> <li>Center of Mass (x,y)</li> <li>Orientation (a)</li> </ol>"},{"location":"SPT_Vision/VisionDetection.html#fb_visiondetection","title":"FB_VisionDetection","text":""},{"location":"SPT_Vision/VisionDetection.html#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\nclass FB_VisionBase{\n    &lt;&lt;ABSTRACT&gt;&gt;\n    eState : ETcVnCameraState;\n    VisionBaseAlarms : ARRAY[1..x] of FB_TcAlarm\n    ProcessImage()\n    CyclicLogic()\n    Reset()\n    CreateEvents()\n    GetResults()\n}   \n\nclass FB_VisionDetection{\n    ProcessImage()\n    ProcessImage_Blob()\n    ProcessImage_Color()\n    ProcessImage_Contour()\n}\n\n\nFB_VisionBase&lt;|--FB_VisionDetection</code></pre>"},{"location":"SPT_Vision/VisionDetection.html#process-image","title":"Process Image","text":"<pre><code>CASE VisionTool OF\n    E_VisionTools.Blob:\n        ProcessImage_Blob();\n    E_VisionTools.Contour:\n        ProcessImage_Contour();\n    E_VisionTools.Color:\n        ProcessImage_Color();\nEND_CASE\n</code></pre>"},{"location":"SPT_Vision/VisionDetection.html#e_visiontools","title":"E_VisionTools","text":"<pre><code>classDiagram\nclass E_VisionTools{\n    &lt;&lt;Enumeration&gt;&gt;\n    Blob\n    Contour\n    Color\n}</code></pre>"},{"location":"SPT_Vision/VisionDetection.html#alarms","title":"Alarms","text":"<p> These still need to be defined from what can happen with this process image</p>"},{"location":"SPT_Vision/VisionDetection.html#to-do","title":"To Do","text":"<ol> <li>Decide on all of the analysis tools we want to use</li> <li>HMI user object to setup these things</li> </ol>"},{"location":"SPT_Vision/VisionPLC.html","title":"PLC Task","text":""},{"location":"SPT_Vision/VisionPLC.html#plc-task","title":"PLC Task","text":"<p>The PLC Camera Base handles the PLC to Camera interaction. By separating the PLC task and Vision task, the PLC task is allowed to run at a faster clock cycle than the Vision task so that other PLC functions are not affected by the slower processing of images. The PLC task is used to run the vision jobs that are setup in the vision task. It also has access to vision results so that it may be used in a PLC process. </p>"},{"location":"SPT_Vision/VisionPLC.html#fb_plccamerabase","title":"FB_PlcCameraBase","text":"<pre><code>FUNCTION_BLOCK FB_PlcCameraBase EXTENDS FB_ComponentBase\n</code></pre>"},{"location":"SPT_Vision/VisionPLC.html#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\n\n\nclass FB_PlcCameraBase{\n    CreateEventsI()\n    CyclicLogic()\n    GetResults()\n    Reset()\n\n    RunVision\n    TriggerImage\n    VisionAlarms\n}\n\nFB_PlcCameraBase--|&gt;FB_ComponentBase</code></pre>"},{"location":"SPT_Vision/VisionPLC.html#outputs","title":"Outputs","text":"Name Type Description RunVision BOOL This will run the vision to aquiring when high and stop the aquiring when low SoftwareTrigger BOOL This will software trigger the camera to take an image Reset BOOL This is used to reset vision system when under error"},{"location":"SPT_Vision/VisionPLC.html#inputs","title":"Inputs","text":"Name Type Description CameraState ETcVnCameraState This is a status of the camera's state ResultsAvailable BOOL This will let the PLC task know that there are results NumberOfResults UDINT This is the number of elements found in the results Results ARRAY[1..MAX_RESULTS_BUFFER_BYTES] of BYTE The data type that is put into buffer will be decided at application time from the process of analysis.  Each side will have to define the structure of results needed for PLC task to function VisionError BOOL This is set when there is an error VisionErrorID UDINT This is the value of the Alarm when one is set VisionAlarms ARRAY[1..5] of FB_TcAlarm Alarm object used with Event Logger"},{"location":"SPT_Vision/VisionPlayback.html","title":"Overview","text":""},{"location":"SPT_Vision/VisionPlayback.html#fb_videoplaybackcontrol","title":"FB_VideoPlaybackControl","text":"<p>This is a function block to add the feature of buffering the images from a vision system and then stitch them together to create a video.  In order to do this, the PLC will communicate with a C# application.  The C# application will connect as a client to the ADS of the PLC on Local and at port 851. The C# App has the ability to work on multiple cameras from one PLC.</p>"},{"location":"SPT_Vision/VisionPlayback.html#parameters","title":"Parameters","text":"<p>The Parameters_Vision are adjustable per application and have the following defaults</p> <pre><code>{attribute 'qualified_only'}\nVAR_GLOBAL CONSTANT\n    MAX_RESULTS_BUFFER_BYTES   : UDINT := 1000;\n    MAX_NUMBER_CAMERAS : USINT := 1;\n    MAX_NUMBER_IMAGES_2_VIDEO : UINT := 200;\nEND_VAR\n</code></pre>"},{"location":"SPT_Vision/VisionPlayback.html#gvl_images2video","title":"GVL_Images2Video","text":"<p>In order to make a C# application with as little configuration as possible, the following GVL data was created so the program can run easily.  The first thing the C# app does is ask how many cameras and then it creates the ability to connect to the data of each camera.</p> <pre><code>{attribute 'qualified_only'}\nVAR_GLOBAL\n    NumberOfCameras    : UINT := Parameters_Vision.MAX_NUMBER_CAMERAS;\n    CameraData         : ARRAY[1..Parameters_Vision.MAX_NUMBER_CAMERAS] OF ST_Image2Video;\nEND_VAR\n</code></pre>"},{"location":"SPT_Vision/VisionPlayback.html#definition","title":"Definition","text":"<p><code>FUNCTION_BLOCK FB_VideoPlaybackControl EXTENDS FB_ListenerBase2 IMPLEMENTS I_CyclicFB</code></p>"},{"location":"SPT_Vision/VisionPlayback.html#fb_listenerbase2","title":"FB_ListenerBase2","text":"Name Return Type Input Description Execute HRESULT none This is called to run the listening code OnAlarmRaised HRESULT fbEvent : REFERENCE TO FB_TcEvent This gets called when an alarm with this filtering happens <p>This is the subscription to the Events and the JSONString is:</p> <p><code>JSONString       : T_MaxString := '{\"CreateVideo\": 1}';</code> <pre><code>IF _Subscribe THEN\n    _Subscribe := FALSE;\n    JSONFilter.Clear().JsonAttribute.Value.EqualTo(JSONString); //define all events (messages and alarms) from this eventclass   \n    hr := Subscribe2(JSONFilter);                               //subscribe to retrieve defined events\n    IF SUCCEEDED(hr) THEN\n        _Subscribed := TRUE;\n    END_IF\nEND_IF\n</code></pre></p>"},{"location":"SPT_Vision/VisionPlayback.html#i_cyclicfb-i_basefb","title":"I_CyclicFB &amp; I_BaseFB","text":"<pre><code>    //Base FB\n    _Busy    : BOOL := TRUE;\n    _Error   : BOOL;\n    _ErrorID : UDINT;\n\n    //Cyclic FB\n    _InitComplete : BOOL;\n</code></pre>"},{"location":"SPT_Vision/VisionPlayback.html#methods","title":"Methods","text":"Name Return Type Input Description AddImage BOOL ipImageIn : ITcVnImage This method will add images the ring buffer.  If it is processing the images to files then it does not add them WriteImage BOOL BufferImageSaveNameIndex : INTIndex : INT This method will write a single file to the name 'ImageXXX.png'  Where XXX is the Index and the image comes from BufferImageSaveNameIndex loacation in the buffer. It is called in the CyclicLogic up to Parameters_Vision.MAX_NUMBER_IMAGES_2_VIDEO times. CyclicLogic None None This method calls the Execute for the FB_ListenerBase2, Subscribes/Unsubscribes and runs logic for Image to Video"},{"location":"SPT_Vision/VisionPlayback.html#flowchart","title":"Flowchart","text":"<p>This is the flow of the Camera state engine and what happens once an image has been received (VisionTask VisionCamera.CyclicLogic ) <pre><code>flowchart\nb{AcquiringImage State&lt;br&gt;If Image Received}\nc[ProcessImage Method]\nc1{Buffer Enabled}\nb--\"Yes\"--&gt;c\nc--&gt;d[Make Displayable]\nd--&gt;c1--\"Yes\"--&gt;d1\nd1[Add Image to VideoPlayback Buffer]\nc1--\"No\"--&gt;b\nd1--&gt;b</code></pre></p> <p>This is the VideoPlayBack.CyclicLogic (Vision Task VisionCamera.CyclicLogic-&gt;VideoPlayback.CyclicLogic)</p> <pre><code>flowchart\ne{If an alarm}\ne1{If delay Passed}\nf[Trigger Video&lt;br&gt;Disable Image buffer]\ng[Write buffer Images to files]\nh[set bit for C# to make Video]\ni{Video Made}\nj[Enable Image Buffer]\n\ne--\"Yes\"--&gt;e1--\"Yes\"--&gt;f--&gt;g--&gt;h--&gt;i--\"Yes\"--&gt;j--&gt;e</code></pre>"},{"location":"SPT_Vision/VisionPlayback.html#data-tofrom-c-app-st_image2video","title":"Data To/From C# App (ST_Image2Video)","text":"Name Type Description VideoPathSource STRING Location on PLC for the Video to be written ImagePathSource STRING Location on PLC for the images to be found VideoFilename STRING File name for the video source VideoCreate BOOL Create the Video from images in the ImagePathSource VideoCreated BOOL Video is created VideoFPS UINT Video Frames Per Second Heartbeat BOOL Heartbeat between PLC and C# app"},{"location":"SPT_Vision/VisionTask.html","title":"Vision Task","text":"<p>The design is to have a Vision Base object that can have all things needed to setup and run a camera and take a picture.  Then the extended classes would be implement the ProcessImage in order to handle the processing as needed.   From the base class, three types of vision handling are given to use:</p> <ol> <li>Object Detection - Results at a minimum are x,y,a relative to origin of image</li> <li> Measurement - Results are Pass fail or Offset or distance value</li> <li> Inspection - Results are Pass fail</li> <li>  Combo of Tools - Array of method pointers to choose the tools you want to use</li> <li>Video Playback - Images are put together to create a AVI file when a fault occurs</li> </ol> <p>NOTE: You can create an extended FB and handle vision as you need if our 3 components do not fit your solution.</p>"},{"location":"SPT_Vision/VisionTask.html#fb_visionbase","title":"FB_VisionBase","text":"<pre><code>FUNCTION_BLOCK ABSTRACT FB_VisionBase EXTENDS FB_ComponentBase IMPLEMENTS I_VisionBase\n</code></pre>"},{"location":"SPT_Vision/VisionTask.html#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\nclass FB_ComponentBase\nclass FB_VisionBase{\n    &lt;&lt;ABSTRACT&gt;&gt;\n    Camera : FB_VN_SimpleCameraControl\n    ABSRACT ProcessImage()\n    CyclicLogic()\n    Reset()\n    CreateEvents()\n    GetResults()\n    ReadParamDINT()\n    SetParamDINT()\n}   \nFB_ComponentBase&lt;|--FB_VisionBase</code></pre>"},{"location":"SPT_Vision/VisionTask.html#hmi","title":"HMI","text":"<p>The HMI tag will be connected to the Vision Task component since this is where all the status and commands will go directly.  The PLC task will not have HMI tags.</p> Name Type HMI Type Description Trigger BOOL Command If the vision is in Aquisition with mode trigger on and source software, it will trigger camera to take picture StartAquisition BOOL Command This will start the camera state engine for taking pictures and processing StopAquistion BOOL Command This will stop the camera from taking pictures and processing Running BOOL Status Is the Camera state engin running CameraState ETcVnCmaeraState Status This will show the actual state of the camera ElementsFound ULINT Status This is the number of elements found in last image/processing"},{"location":"SPT_Vision/VisionTask.html#processimage-function","title":"ProcessImage Function","text":"<p><pre><code>METHOD PUBLIC ABSTRACT ProcessImage\n</code></pre> This method needs to be overriden in the Extended function block.  </p>"},{"location":"SPT_Vision/VisionTask.html#readparamdint","title":"ReadParamDINT","text":""},{"location":"SPT_Vision/VisionTask.html#setparamdint","title":"SetParamDINT","text":""},{"location":"SPT_Vision/VisionTask.html#alarms","title":"Alarms","text":"<p>The alarms array will be in the PLC Task so that the framework can handle them correclty for the machine.  The Vision Task will have to send Error and ErrorID over the TwinCAT Process Image.</p>"},{"location":"SPT_Vision/VisionTask.html#to-do","title":"To Do","text":"<ol> <li>Switch between real camera and simulation</li> <li>Define a results Structure that fits the given solutions<ol> <li>Position (x,y,a)</li> <li>Pass/fail</li> <li>Measurement<ol> <li>Offset</li> <li>distance</li> <li>roundness</li> </ol> </li> <li>Other result types</li> </ol> </li> <li>HMI user object for this component.  Still use the TcVision HMI items, but a quick user control for layout in SPT HMI</li> </ol>"},{"location":"SPT_Vision/VisionTask.html#overall-diagram","title":"Overall Diagram","text":"<pre><code>classDiagram\n\nclass FB_ComponentBase\n\nclass FB_VisionBase{\n    &lt;&lt;ABSTRACT&gt;&gt;\n    eState : ETcVnCameraState;\n    VisionBaseAlarms : ARRAY[1..x] of FB_TcAlarm\n    ProcessImage()\n    CyclicLogic()\n    Reset()\n    CreateEvents()\n    GetResults()\n}   \n\nclass FB_VisionDetection{\n    ProcessImage()\n    ProcessImage_Blob()\n    ProcessImage_Color()\n    ProcessImage_Contour()\n}\n\nclass FB_VisionMeasurement{\n    ProcessImage()\n}\n\nclass FB_VisionInspection{\n    ProcessImage()\n}\n\nFB_ComponentBase&lt;|--FB_VisionBase\nFB_VisionBase&lt;|--FB_VisionDetection\nFB_VisionBase&lt;|--FB_VisionMeasurement\nFB_VisionBase&lt;|--FB_VisionInspection\n\nclass E_VisionTools{\n    &lt;&lt;Enumeration&gt;&gt;\n    Blob\n    Contour\n    Color\n}\n\nclass I_VisionBase{\n    &lt;&lt;Interface&gt;&gt;\n\n\n\n    ProcessImage()\n    GetResults()\n}</code></pre>"},{"location":"SPT_Vision/changelog.html","title":"Changelog","text":""},{"location":"SPT_Vision/changelog.html#40-2025-05-20","title":"[4.0] - 2025-05-20","text":""},{"location":"SPT_Vision/changelog.html#compiled","title":"Compiled","text":"<ul> <li>Using TwinCAT 3.1.4026</li> </ul>"},{"location":"SPT_Vision/changelog.html#39-2025-04-14","title":"[3.9] - 2025-04-14","text":""},{"location":"SPT_Vision/changelog.html#finalizing","title":"Finalizing","text":"<ul> <li>Internal updates and cleanup</li> </ul>"},{"location":"SPT_Vision/changelog.html#33-2025-04-11","title":"[3.3] - 2025-04-11","text":""},{"location":"SPT_Vision/changelog.html#sync","title":"Sync","text":"<ul> <li>Implement same version number across all SPT libraries</li> </ul>"},{"location":"SPT_Vision/changelog.html#added","title":"Added","text":"<ul> <li>Code formatting and comments</li> </ul>"},{"location":"SPT_Vision/changelog.html#305-2024-09-30","title":"[3.0.5] - 2024-09-30","text":""},{"location":"SPT_Vision/changelog.html#update","title":"Update","text":"<ul> <li>Fixed bug with startup.  Changed Reconnect to 5s from 60s.  Auto Reset Video state engine.</li> </ul>"},{"location":"SPT_Vision/changelog.html#303-2024-05-02","title":"[3.0.3] - 2024-05-02","text":""},{"location":"SPT_Vision/changelog.html#update_1","title":"Update","text":"<ul> <li>Added support for Video Playback.  Codec was added as JSON parameter.</li> </ul>"},{"location":"SPT_Vision/changelog.html#302-2024-04-03","title":"[3.0.2] - 2024-04-03","text":""},{"location":"SPT_Vision/changelog.html#update_2","title":"Update","text":"<ul> <li>Changed video output file to .mp4 format from .avi format</li> </ul>"},{"location":"SPT_Vision/changelog.html#300-2023-12-5","title":"[3.0.0] - 2023-12-5","text":""},{"location":"SPT_Vision/changelog.html#added_1","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_XPlanar/index.html","title":"Overview","text":"<p>A modular XPlanar control component function block with minimal overhead built on the XPlanar Standard and XPlanar Utility libraries that can easily scale to custom and/or larger projects.  This function block can be used within the SPT PackML framework or any other architecture.</p> <p>For screenshots and notes on getting started please refer to the following document. SPT_XPlanar Startup Notes.pdf</p> <p>For and example project refer to the following repository https://github.com/Beckhoff-USA-Community/SPT_XPlanar_Demo</p>"},{"location":"SPT_XPlanar/index.html#class-diagram","title":"Class Diagram","text":"<pre><code>classDiagram\n\n\n\n    FB_Component_XPlanar o--|&gt; FB_XPlanarMover\n    ip --&gt; I_XPlanarMover\n    FB_XPlanarMover ..|&gt; I_XPlanarMover\n    FB_Component_XPlanar o--&gt; FB_XPlanarTrackSegment\n    FB_XPlanarTrackSegment ..|&gt; I_XPlanarTrack\n    ip --&gt; I_XPlanarTrack\n    FB_XPlanarStation ..|&gt; I_XPlanarStation\n    ip --&gt; I_XPlanarStation\n    I_XPlanarMover o--|&gt; I_XPlanarStation\n\n    class FB_Component_XPlanar{\n      BOOL BuildTracks()\n      BOOL CheckMovers()\n      BOOL CheckTilePower()\n      BOOL DisableMovers()\n      BOOL EnableGroup()\n      BOOL EnableMovers(AddToGroup)\n      BOOL EnableTracks(AddToGroup)\n      BOOL MoverRedetect()\n      BOOL Recover()\n      BOOL Reset()\n      CreateEvents()\n      HMICommunication()\n      Monitoring()\n      CyclicLogic()\n    }\n    class I_XPlanarMover{\n      UDINT DestinationID\n      REFERENCE_TO ST_MoveDynamics MoveDynamics\n      STRING MoverID\n      UDINT MoverIndex\n      I_XPlanarMoverStandard std\n      UDINT TrackID\n\n      BOOL Index(LREAL:Distance)\n      BOOL JoinTrack(UDINT:TrackID)\n      BOOL LeaveTrack(LREAL:DestinationX, LREAL:DestinationY)\n      BOOL SendToStation(UDINT:StationID)\n      BOOL Spin(UDINT:NumOfTurns)\n      BOOL SquareUp()\n      BOOL Tilt(LREAL:APosition, LREAL:BPosition)\n      BOOL VerticalMove(LREAL:Position)\n      BOOL Reset()\n      BOOL ClearCmd()\n\n    }\n    class FB_XPlanarMover{\n      CyclicLogic()\n      HMICommunication()\n    }\n    class I_XPlanarStation{\n      BOOL AllowQueing\n      BOOL CanReleaseMover\n      BOOL HasMover\n      BOOL MoverReady\n      BOOL StationComplete\n      UDINT NextStationID\n      UDINT StationID\n      UDINT TrackID\n      UDINT Size\n      REFERENCE_TO ARRAY[1..MOVER_COUNT] OF I_Mover\n      REFERENCE_TO PositionXYC Position\n\n      I_Process ProcessInterface\n      I_Mover CurrentMover\n\n      BOOL Execute()\n    }\n    class FB_XPlanarStation{\n      BOOL Prepare()\n      CyclicLogic()\n      Execute()\n    }\n    class I_XPlanarTrack{\n      BOOL Error\n      STRING ErrorInfo\n      UDINT ID\n      UDINT MoverCount\n      LREAL TrackLength\n      I_TrackStandard ref\n      REFERENCE_TO FB_TrackTable TrackTable\n      MC_PLANAR_TRACK_OPERATION_MODE OpMode\n\n    BOOL Clear()\n    }\n    class FB_XPlanarTrackSegment{\n        BOOL Build()\n        BOOL Clear()\n        CyclicLogic()\n    }\n\n    class ip{\n      Tracks : ARRAY[1..Tc3_XPlanarComponent.Params_XPlanar.maxTrackCount] of I_Track\n      Movers : ARRAY[1..Tc3_XPlanarComponent.Params_XPlanar.moverCount] of I_Mover\n      Stations : ARRAY[1..Tc3_XPlanarComponent.Params_XPlanar.maxNumStations] of I_Station\n    }\n\n</code></pre>"},{"location":"SPT_XPlanar/changelog.html","title":"Changelog","text":""},{"location":"SPT_XPlanar/changelog.html#unreleased","title":"[Unreleased]","text":""},{"location":"SPT_XPlanar/changelog.html#361-2023-12-07","title":"[3.6.1] - 2023-12-07","text":""},{"location":"SPT_XPlanar/changelog.html#optimizations","title":"Optimizations","text":"<ul> <li>Movers queuing in stations</li> <li>Mover Command Tracing</li> </ul>"},{"location":"SPT_XPlanar/changelog.html#360-2023-09-28","title":"[3.6.0] - 2023-09-28","text":""},{"location":"SPT_XPlanar/changelog.html#added","title":"Added","text":"<ul> <li>Method added for Mover Redetection</li> <li>Method added for Mover Identification</li> <li>I_XPlanarMover and I_XPlanarStation interfaces now directly extend System.QueryInterface</li> <li>XPlanarMover now includes access to TcIoXPlanarMover interface for ScopeAddr and Driver functions</li> <li>Movers are now declared at the application level for ease of extending functionality</li> <li>Track segments are now declared at the applcation level for ease of extending functionality</li> </ul>"},{"location":"SPT_XPlanar/changelog.html#applications-using-32-and-earlier-will-require-the-following-minor-modifications-to-be-compatable","title":"**Applications using 3.2 and earlier will require the following minor modifications to be compatable!","text":"<p>-Variable Declaration <pre><code>Movers  : ARRAY[1..Tc3_XPlanarStandard.Params_XPlanar.moverCount] OF FB_XPlanarMover;\nTracks  : ARRAY[1..Tc3_XPlanarStandard.Params_XPlanar.maxTrackCount] OF FB_XPlanarTrackSegment;\n</code></pre></p> <p>-Interfaces must be set on Initialization of the system for library to function. <pre><code>FOR i := 1 TO Tc3_XPlanarStandard.Params_XPlanar.moverCount DO\n    Movers[i].MoverIndex := i;\n    ip.Movers[i]          := Movers[i];\nEND_FOR\n\nFOR i := 1 TO Tc3_XPlanarStandard.Params_XPlanar.maxTrackCount DO\n    ip.Tracks[i] := Tracks[i];\nEND_FOR\n</code></pre></p>"},{"location":"SPT_XPlanar/changelog.html#320-2023-06-02","title":"[3.2.0] - 2023-06-02","text":""},{"location":"SPT_XPlanar/changelog.html#added_1","title":"Added","text":"<ul> <li>Each Mover Queue for Stations</li> <li>Station Base now includes multi-mover capability</li> <li>Control direction of rotation for Index and Spin methods by changing sign of input argument</li> </ul>"},{"location":"SPT_XPlanar/changelog.html#310-2023-04-14","title":"[3.1.0] - 2023-04-14","text":""},{"location":"SPT_XPlanar/changelog.html#added_2","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_XPlanar/functionblocks.html","title":"Function Blocks","text":""},{"location":"SPT_XPlanar/functionblocks.html#fb_component_xplanar","title":"FB_Component_XPlanar","text":"<p>(extends <code>FB_ComponentBase</code>) Function block that allows for an implementation of and XPlanar system as a component of a Machine.</p> <p>Note</p> <p>See also:     - I_ComponentBase</p>"},{"location":"SPT_XPlanar/functionblocks.html#notes","title":"Notes","text":"<ul> <li>The <code>CyclicLogic()</code> method should be called every PLC cycle to ensure the XPlanarEnvironment and XPlanarGroup NC objects along with each Movers/Stations/Tracks are cycled properly and statuses updated.  Called inherently if using SPT Framework</li> <li>The <code>Initialize()</code> method sets mover default halt dynamics and sets up all required interfaces pointers and references. Called inherently if using SPT Framework</li> <li>The <code>Reset()</code> method contains and sequence to reset and re-enable faulted movers</li> <li>The <code>CreateEvents()</code> method should be called before operation to initialize configured Event Logger events Called inherently if using SPT Framework</li> <li>The <code>HMICommunication()</code>method should be called to update statuses to the HMI Called inherently if using SPT Framework</li> </ul>"},{"location":"SPT_XPlanar/functionblocks.html#properties","title":"Properties","text":"Property Type Access Description MoverDetectionInfo ST_TcIoMoverDetectionInfos R Structure of configured and detected count of each mover type TracksInitialized BOOL R Signal reflecting that track segments have been build and do not need to be re-initialized TileCount UDINT R Actual tile count of the XPlanar system Xpu I_TcIoXPlanarProcessingUnit R Access to XPlanar environment and driver functions"},{"location":"SPT_XPlanar/functionblocks.html#methods","title":"Methods","text":"Method Return Type Access Description Abort BOOL PUBLIC Aborting sequence for immediate halting system and disabling movers BuildTracks BOOL PUBLIC Sequence for initializing all configured track segments CheckMovers BOOL PUBLIC Method that can be called to check all valid movers and raise an alarm if a lost mover is detected CheckTilePower BOOL PUBLIC Method that can be called to check DC Link voltage for all tiles and will raise an alarm if not ok EnableGroup BOOL PUBLIC Method used to Enable the XPlanar Group EnableMovers BOOL PUBLIC Method used to Enable all movers with the option of adding them to the XPlanar Group EnableTracks BOOL PUBLIC Method used to Enable all track segments with the option of adding them to the XPlanar Group IdentifyMovers BOOL PUBLIC Method used to identify and sort movers based on assigned ID Bumper MoverRedetect BOOL PUBLIC Method used to perform a mover redetect RecoverStations BOOL PUBLIC Method to cylce through the prepare sequence of each station Reset -- -- --"},{"location":"SPT_XPlanar/functionblocks.html#fb_xplanarmover","title":"FB_XPlanarMover","text":"<p>Complete implementation of I_XPlanarMover for control of an XPlanar mover.</p> <p>Note</p> <p>See also:     - I_XPlanarMover</p>"},{"location":"SPT_XPlanar/functionblocks.html#notes_1","title":"Notes","text":"<ul> <li> <p>The <code>CyclicLogic()</code> method is inherently called by the FB_Component_XPlanar parent object and ensures the NC object is cycled properly and updates the component Busy flag</p> </li> <li> <p>The <code>Reset()</code> method should be called to clear any mover faults</p> </li> </ul>"},{"location":"SPT_XPlanar/functionblocks.html#hmicommunication-method","title":"HMICommunication method","text":"<p>The <code>HMICommunication()</code> method should be called to update status of the mover to the HMI. Called inherently if using SPT Framework</p>"},{"location":"SPT_XPlanar/functionblocks.html#fb_moverqueue","title":"FB_MoverQueue","text":"<p>Function Block to handle a queueing of movers in a station.</p>"},{"location":"SPT_XPlanar/functionblocks.html#properties_1","title":"Properties","text":"Property Type Access Description Count UDINT R Actual count of movers in the queue FirstMover I_XPlanarMover R Interface to the lead mover in the queue LastMover I_XPlanarMover R Interface to the last mover in the queue MoverIDs ARRAY[1..StationParameters.MaxMoversPerStation] R Index values of movers currently in the queue Queue Reference To ARRAY[1..StationParameters.MaxMoversPerStation] R Reference to the entire queue of mover interfaces"},{"location":"SPT_XPlanar/functionblocks.html#methods_1","title":"Methods","text":"Method Return Type Access Description Clear BOOL PUBLIC Full clear and reset of the queue buffer Dequeue BOOL PUBLIC Unload the leading mover from the queue Enqueue BOOL PUBLIC Load mover into the queue"},{"location":"SPT_XPlanar/functionblocks.html#fb_xplanarstationbase","title":"FB_XPlanarStationBase","text":"<p>Complete implementation of <code>I_XPlanarStation</code> for configuring and controlling a processing point on the XPlanar table.</p> <p>Note</p> <p>See also:     - I_XPlanarStation</p>"},{"location":"SPT_XPlanar/functionblocks.html#notes_2","title":"Notes","text":"<ul> <li> <p>The <code>Recover()</code> method is called by the recovery sequence of the FB_XPlanar parent object and if a mover is in the 'bubble' of the station it will be brought center and joined to the defined track segment of the station (if applicable).</p> </li> <li> <p>The <code>CyclicLogic()</code> method is inherently called by the FB_XPlanar sum up component and continually monitors for a mover to arrive.  </p> </li> <li>As movers pass through the <code>HasMover</code> flag will set, if a mover enters the station and stops the <code>MoverReady</code> flag will be set.</li> </ul>"},{"location":"SPT_XPlanar/functionblocks.html#fb_xplanartracksegment","title":"FB_XPlanarTrackSegment","text":"<p>Complete implementation of <code>I_XPlanarTrack</code> for configuring and building planar track segments in NC</p> <p>Note</p> <p>See also:     - I_XPlanarTrack</p>"},{"location":"SPT_XPlanar/functionblocks.html#notes_3","title":"Notes","text":"<ul> <li> <p>The <code>CyclicLogic()</code> method is inherently called by the FB_XPlanar parent object and ensures the NC object is cycled properly.</p> </li> <li> <p>The <code>Build()</code> method is called by the Build Tracks sequence of the FB_XPlanar parent object and checks the point configuration and initializes the segment with its linked NC group.</p> </li> </ul>"},{"location":"SPT_XPlanar/globals.html","title":"Interface Properties (ip)","text":"<p>Arrays of Mover, Track Segment, and Station interfaces for use within the application.</p> Property Type Access Description Movers ARRAY[1..Tc3_XPlanarStandard.Params_XPlanar.moverCount] of I_XPlanarMover R Access to mover interfaces for higher level objects Stations ARRAY[1..Tc3_XPlanarStandard.Params_XPlanar.maxNumStations] of I_XPlanarStation R Access to station interfaces for higher level objects Tracks ARRAY[1..Tc3_XPlanarStandard.Params_XPlanar.maxTrackCount] of I_XPlanarTrack R Access to track interfaces for higher level objects"},{"location":"SPT_XPlanar/interfaces.html","title":"Interfaces","text":""},{"location":"SPT_XPlanar/interfaces.html#i_xplanarmover","title":"I_XPlanarMover","text":"<p>Defines required functionality for an XPlanar mover.</p>"},{"location":"SPT_XPlanar/interfaces.html#properties","title":"Properties","text":"Property Type Access Description Destination I_XPlanarStation RW Interface pointer for the next station the mover is going to. Error BOOL RO Error signal from Move Commands ErrorID UDINT RO Error ID returned from Command Feedback ErrorInfo STRING RO Error description returned from Command Feedback IdentifiedBTN STRING RO Reported BTN from ID Bumper InStation BOOL RW Signal indicating mover is in a station queue MoverDynamics ST_MoveDynamics RW Sturcture for move dynamic vars. Velocity, Accel, Decel, Jerk, CA Gap, etc. MoverBTN STRING(13) R BTN that is assigned to the mover MoverIndex UDINT RW Index number of the mover MoverTcIo I_TcIoXPlanarMover RO Interface to Mover TcIo Driver functions MoverType MoverType RO Identified Mover Type from TcCOM Object TrackID UDINT RW Index number of the track segment the mover is currently on std I_XPlanarMoverStandard R Interface to the base library mover functions"},{"location":"SPT_XPlanar/interfaces.html#move-commands","title":"Move Commands","text":"<p>Built in Mover functions that can be easily called from the application.</p> Method Return Type Description ClearCmd BOOL Used to externally reset the internal command state machine Disable BOOL Disables the mover Enable BOOL Enables the mover FreeMove BOOL Command the mover to an XY position on the table Index BOOL Command the mover to rotate a fraction of a turn (Use negative number to change rotation direction) JoinTrack BOOL Join the mover to a specified Track Segment LeaveTrack BOOL Command mover to un-join its current track segment and move to a specified xy position SendToStation BOOL Send the mover to a desired Station Spin BOOL Rotate the mover a specified number of turns (Use negative number to change rotation direction SquareUp BOOL Rotate the mover to its nearest quarter angle Tilt BOOL Tilt the mover on the A and B Axis VerticalMove BOOL Raise or lower the mover on the Z Axis"},{"location":"SPT_XPlanar/interfaces.html#i_xplanarstation","title":"I_XPlanarStation","text":"<p>Defines a specified area of a track where a mover is going to be processed.</p>"},{"location":"SPT_XPlanar/interfaces.html#properties_1","title":"Properties","text":"Property Type Access Description CanReleaseMover BOOL W Immediate area around the station is blocked, do not release mover CurrentMover I_XPlanarMover R Interface pointer to the lead mover in the stations mover queue HasMover BOOL BOOL A Mover is currently in the defined station area ID UDINT RW Index number of the station MoverQueue Reference To FB_MoverQueue_ R Reference to the movers currently queued up in the station NextStation I_XPlanarStation RW Interface pointer to the next station to send the mover to NumMoversRequired UDINT RW Number of movers required by the station before station is ready to process.  Only required with Multi-Mover station type Positon REFERENCE TO PositionXYC R Reference to the postition of the station on the XPlanar table StationComplete BOOL W Bit for an external process to tell the station that processing is complete and send the mover to the next station StationReady BOOL R Mover(s) are registered in the station and ready to command StationType E_StationType(UDINT) RW Type of process the station is being setup to do (0 = Process, 1 = DecisionPoint, etc.) ProcessInterface I_Process W Interface pointer for a processing sequence that the mover will perform while in the station AllowQueing BOOL W Bit to tell the station to bypass checking if the next station is blocked and send the mover anyway (basically allow queuing or not) Size UDINT RW Configured station size in mm (default = 240) TrackID I_Track RW Interface pointer to the track segment the station resides on. (do not set if not using tracks)"},{"location":"SPT_XPlanar/interfaces.html#methods","title":"Methods","text":"Method Return Type Description Execute null 'Automatic' function of the station.  Watch for a mover to arrive, execute a process if assigned, and send the mover away Reset BOOL Reset the internal state machine of the station"},{"location":"SPT_XPlanar/interfaces.html#i_xplanartrack","title":"I_XPlanarTrack","text":"<p>Defines functionality of a specified track segment</p>"},{"location":"SPT_XPlanar/interfaces.html#properties_2","title":"Properties","text":"Property Type Access Description Error BOOL R Bit indicating an error occurred during the build process ErrorInfo STRING R Description of error that occurred during build process ID UDINT RW Index number of the segment MoverCount UDINT R Number of movers currently on segment OpMode MC_PLANAR_TRACK_OPERATION_MODE R Current operating mode of the track segment std I_TrackStandard R Interface to the base library track functions TrackLength UDINT R Linear length of track segment in mm TrackTable REFERENCE_TO FB_TrackTable R Reference to the track table for point configuration"},{"location":"SPT_XTS/index.html","title":"Overview","text":"<p>The XPU component serves as a wrapper to functions and classes provided by the Tc3_XTS_Utility library.</p> <p>The intention for the component is to insulate the application programmer from the 'messy middle' of buffering movers, handling relationships between stations, group motion setup and maintenance, etc.</p> <p>Consider an assembly machine utilizing XTS as a product transport mechanism.  An assembly machine typically consists of multiple stations each performing a discrete operation on a part which is moved serially though the machine.  Ideally a team of developers should be able to work on such a machine simultaneously, concerning themselves only with the logic and operations specific to a particular station.  The passing of an XTS mover to and from a station should be secondary to the developer's efforts.  Additionally, the locations of the stations on the machine base should be flexible and otherwise transparent to the developer.</p> <p>The existing XTS configuration tools continue to be utilized.  Station position(s) and number of movers required are parameterized in the XTS Configuration Tool via the Stations section.  The XPU component will collect all of the configured parameters via the Tc3_XTS_Utility library.</p> <p>At the application layer, a station need only implement a relatively lightweight interface <code>I_XTS_ApplicationStation</code> and make itself known to the XPU component.  During initialization, the XPU component will establish the necessary links and assign an instance of <code>I_XTS_InfoStation</code> to the station.  <code>I_XTS_InfoStation</code> is the interface through which a station can request mover(s) from the XPU component.</p>"},{"location":"SPT_XTS/index.html#mover-exchange","title":"Mover Exchange","text":"<p>The function blocks linked to the NC axes corresponding to XTS movers are contained within <code>FB_Component_XPU</code>.  They are each associated via interface pointer with only one <code>InfoStation</code> at a time.  The XPU component maintains a list of stations and their associated \"neighbors\"--one upstream and another downstream.  <code>ApplicationStations</code> and their specific logic dictates when they are done with/need another mover.  They request a mover from their associated <code>InfoStation</code>, which passes this request to the XPU for processing.</p> <p>The movement of a mover's interface pointer from one InfoStation's buffer to another takes place in a single PLC scan.</p> <p>An illustration of this exchange: <pre><code>sequenceDiagram\n    participant DS as Downstream ApplicationStation\n    participant DI as Downstream InfoStation\n    participant X as XPU\n    participant UI as Upstream InfoStation\n    participant US as Upstream ApplicationStation\n\n    Note over DS,DI: Downstream Application Station and &lt;br&gt;Downstream InfoStation know about each other\n\n    DS -&gt;&gt; DI: Get a new mover\n\n    DI-&gt;&gt;X: Give me a mover\n    Note over DI,X: InfoStation passes an interface to itself &lt;br&gt; as an argument to XPU\n    Note over X: XPU matches the interface to &lt;br&gt; its neighbor\n    X-&gt;&gt;UI: Give Downstream InfoStation a mover\n    Note over X,UI: XPU passes interface to Downstream InfoStation\n    Note over US,UI: Upstream Station and Upstream &lt;br&gt;InfoStation know about each other\n    UI-&gt;US: Are you done with this thing?\n    US--&gt;UI: Yeah go ahead and give it away\n    UI--&gt;&gt;DI: I heard you wanted a mover?\n    Note over UI, DI: Upstream InfoStation passes interface to its first mover in queue\n    DI -&gt; DS: Are you sure you want this thing?\n\n    DS --&gt; DI: Yep!\n    Note over DI: Enqueues the mover\n    DI --&gt;&gt; UI: Thanks I'll take it\n    Note over UI: Dequeues the mover\n    UI --&gt;&gt; X: It is done.\n    X --&gt;&gt; DI: Upstream gave you a mover\n    DI --&gt;&gt; DS: OK check your queue\n    Note over DS: Sends new mover to open station position</code></pre></p>"},{"location":"SPT_XTS/index.html#class-diagram","title":"Class Diagram","text":"<p>For illustration only</p> <pre><code>classDiagram\n\n\n    NC --* CAGroup\n    NC --* Axis\n\n    Axis --* SoftDrive\n\n    XtsProcessingUnit -- Mover    \n    XtsProcessingUnit -- Part\n    XtsProcessingUnit -- Track\n\n\n\n\n\n   FB_Component_XPU -- ApplicationStation\n\n\n\n    Part --  FB_Component_XPU\n    Track --  FB_Component_XPU\n    Mover --  FB_Component_XPU\n    CAGroup --  FB_Component_XPU\n    InfoStation --  FB_Component_XPU\n    XtsInfoServer -- InfoStation\n    InfoStation .. ApplicationStation\n\n    Axis -- Mover\n    SoftDrive -- Mover\n\n\n    Mover .. Part\n    Mover .. Track\n    Mover .. CAGroup\n\n\n\n    class FB_Component_XPU{\n        Parts[]\n        Tracks[]\n        Movers[]\n        InfoStations[]\n    }\n\n\n    class ApplicationStation{\n        InfoStation\n        MoverQueue\n    }\n\n    class InfoStation{\n        ApplicationStation\n        MoverQueue\n        StopPositions[]\n        GetMover()\n        GiveMover()\n        TakeMover()\n    }\n\n    class XtsProcessingUnit{\n        &lt;&lt;TcCom&gt;&gt;\n        Parts[]\n        Tracks[]\n        Movers[]\n    }\n\n    class XtsInfoServer {\n        &lt;&lt;TcCom&gt;&gt;\n        InfoStations[]\n    }\n\n    class NC{\n        &lt;&lt;System Manager&gt;&gt;\n    }</code></pre>"},{"location":"SPT_XTS/changelog.html","title":"Changelog","text":""},{"location":"SPT_XTS/changelog.html#unreleased","title":"[Unreleased]","text":"<ul> <li>Track management functionality</li> </ul>"},{"location":"SPT_XTS/changelog.html#40-2025-05-20","title":"[4.0] - 2025-05-20","text":""},{"location":"SPT_XTS/changelog.html#replaced-dependencies","title":"Replaced Dependencies","text":"<ul> <li>Tc3_PackML_V2 with Tc3_PackML_V3</li> </ul>"},{"location":"SPT_XTS/changelog.html#updated","title":"Updated","text":"<ul> <li>All references to Tc3_PackML_V2 have been updated to Tc3_PackML_V3</li> </ul>"},{"location":"SPT_XTS/changelog.html#compiled","title":"Compiled","text":"<ul> <li>Using TwinCAT 3.1.4026</li> </ul>"},{"location":"SPT_XTS/changelog.html#39-2025-04-14","title":"[3.9] - 2025-04-14","text":""},{"location":"SPT_XTS/changelog.html#finalizing","title":"Finalizing","text":"<ul> <li>Internal updates and cleanup</li> </ul>"},{"location":"SPT_XTS/changelog.html#33-2025-04-11","title":"[3.3] - 2025-04-11","text":""},{"location":"SPT_XTS/changelog.html#sync","title":"Sync","text":"<ul> <li>Implement same version number across all SPT libraries</li> </ul>"},{"location":"SPT_XTS/changelog.html#added","title":"Added","text":"<ul> <li>Code formatting and comments</li> </ul>"},{"location":"SPT_XTS/changelog.html#320-2023-06-02","title":"[3.2.0] - 2023-06-02","text":""},{"location":"SPT_XTS/changelog.html#added_1","title":"Added","text":"<ul> <li>Added license file to project (MIT License)</li> <li>MC_GearInPosCA functionality</li> </ul>"},{"location":"SPT_XTS/changelog.html#fixed","title":"Fixed","text":"<ul> <li>Added check to FB_XTS_StationBase.CanReleaseMover in order to verify that there is actually a mover available to release</li> </ul>"},{"location":"SPT_XTS/changelog.html#310-2022-04-14","title":"[3.1.0] - 2022-04-14","text":""},{"location":"SPT_XTS/changelog.html#added_2","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"SPT_XTS/duts.html","title":"DUTs","text":""},{"location":"SPT_XTS/duts.html#enums","title":"ENUMs","text":""},{"location":"SPT_XTS/duts.html#e_applicationstationstate","title":"E_ApplicationStationState","text":"<pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_ApplicationStationState : (\n        eApplicationStationState_Init          := 0,\n        eApplicationStationState_GetMovers     := 1,\n        eApplicationStationState_InProcess     := 2,\n        eApplicationStationState_ReleaseMovers := 4\n    ) DWORD;\nEND_TYPE\n</code></pre>"},{"location":"SPT_XTS/duts.html#e_colors_argb","title":"E_Colors_ARGB","text":"<pre><code>{attribute 'qualified_only'}\nTYPE E_Colors_ARGB : (\n        Darkred              := 16#FF8B0000, // rgb(139,0,0)\n        Brown                := 16#FFA52A2A, // rgb(165,42,42)\n        Firebrick            := 16#FFB22222, // rgb(178,34,34)\n        Crimson              := 16#FFDC143C, // rgb(220,20,60)\n        Red                  := 16#FFFF0000, // rgb(255,0,0)\n        Tomato               := 16#FFFF6347, // rgb(255,99,71)\n        Coral                := 16#FFFF7F50, // rgb(255,127,80)\n        Indianred            := 16#FFCD5C5C, // rgb(205,92,92)\n        Lightcoral           := 16#FFF08080, // rgb(240,128,128)\n        Darksalmon           := 16#FFE9967A, // rgb(233,150,122)\n        Salmon               := 16#FFFA8072, // rgb(250,128,114)\n        Lightsalmon          := 16#FFFFA07A, // rgb(255,160,122)\n        Orangered            := 16#FFFF4500, // rgb(255,69,0)\n        Darkorange           := 16#FFFF8C00, // rgb(255,140,0)\n        Orange               := 16#FFFFA500, // rgb(255,165,0)\n        Gold                 := 16#FFFFD700, // rgb(255,215,0)\n        Darkgoldenrod        := 16#FFB8860B, // rgb(184,134,11)\n        Goldenrod            := 16#FFDAA520, // rgb(218,165,32)\n        Palegoldenrod        := 16#FFEEE8AA, // rgb(238,232,170)\n        Darkkhaki            := 16#FFBDB76B, // rgb(189,183,107)\n        Khaki                := 16#FFF0E68C, // rgb(240,230,140)\n        Olive                := 16#FF808000, // rgb(128,128,0)\n        Yellow               := 16#FFFFFF00, // rgb(255,255,0)\n        Yellowgreen          := 16#FF9ACD32, // rgb(154,205,50)\n        Darkolivegreen       := 16#FF556B2F, // rgb(85,107,47)\n        Olivedrab            := 16#FF6B8E23, // rgb(107,142,35)\n        Lawngreen            := 16#FF7CFC00, // rgb(124,252,0)\n        Chartreuse           := 16#FF7FFF00, // rgb(127,255,0)\n        Greenyellow          := 16#FFADFF2F, // rgb(173,255,47)\n        Darkgreen            := 16#FF006400, // rgb(0,100,0)\n        Green                := 16#FF008000, // rgb(0,128,0)\n        Forestgreen          := 16#FF228B22, // rgb(34,139,34)\n        Lime                 := 16#FF00FF00, // rgb(0,255,0)\n        Limegreen            := 16#FF32CD32, // rgb(50,205,50)\n        Lightgreen           := 16#FF90EE90, // rgb(144,238,144)\n        Palegreen            := 16#FF98FB98, // rgb(152,251,152)\n        Darkseagreen         := 16#FF8FBC8F, // rgb(143,188,143)\n        Mediumspringgreen    := 16#FF00FA9A, // rgb(0,250,154)\n        Springgreen          := 16#FF00FF7F, // rgb(0,255,127)\n        Seagreen             := 16#FF2E8B57, // rgb(46,139,87)\n        Mediumaquamarine     := 16#FF66CDAA, // rgb(102,205,170)\n        Mediumseagreen       := 16#FF3CB371, // rgb(60,179,113)\n        Lightseagreen        := 16#FF20B2AA, // rgb(32,178,170)\n        Darkslategray        := 16#FF2F4F4F, // rgb(47,79,79)\n        Teal                 := 16#FF008080, // rgb(0,128,128)\n        Darkcyan             := 16#FF008B8B, // rgb(0,139,139)\n        Aqua                 := 16#FF00FFFF, // rgb(0,255,255)\n        Lightcyan            := 16#FFE0FFFF, // rgb(224,255,255)\n        Darkturquoise        := 16#FF00CED1, // rgb(0,206,209)\n        Turquoise            := 16#FF40E0D0, // rgb(64,224,208)\n        Mediumturquoise      := 16#FF48D1CC, // rgb(72,209,204)\n        Paleturquoise        := 16#FFAFEEEE, // rgb(175,238,238)\n        Aquamarine           := 16#FF7FFFD4, // rgb(127,255,212)\n        Powderblue           := 16#FFB0E0E6, // rgb(176,224,230)\n        Cadetblue            := 16#FF5F9EA0, // rgb(95,158,160)\n        Steelblue            := 16#FF4682B4, // rgb(70,130,180)\n        Cornflowerblue       := 16#FF6495ED, // rgb(100,149,237)\n        Deepskyblue          := 16#FF00BFFF, // rgb(0,191,255)\n        Dodgerblue           := 16#FF1E90FF, // rgb(30,144,255)\n        Lightblue            := 16#FFADD8E6, // rgb(173,216,230)\n        Skyblue              := 16#FF87CEEB, // rgb(135,206,235)\n        Lightskyblue         := 16#FF87CEFA, // rgb(135,206,250)\n        Midnightblue         := 16#FF191970, // rgb(25,25,112)\n        Navy                 := 16#FF000080, // rgb(0,0,128)\n        Darkblue             := 16#FF00008B, // rgb(0,0,139)\n        Mediumblue           := 16#FF0000CD, // rgb(0,0,205)\n        Blue                 := 16#FF0000FF, // rgb(0,0,255)\n        Royalblue            := 16#FF4169E1, // rgb(65,105,225)\n        Blueviolet           := 16#FF8A2BE2, // rgb(138,43,226)\n        Indigo               := 16#FF4B0082, // rgb(75,0,130)\n        Darkslateblue        := 16#FF483D8B, // rgb(72,61,139)\n        Slateblue            := 16#FF6A5ACD, // rgb(106,90,205)\n        Mediumslateblue      := 16#FF7B68EE, // rgb(123,104,238)\n        Mediumpurple         := 16#FF9370DB, // rgb(147,112,219)\n        Darkmagenta          := 16#FF8B008B, // rgb(139,0,139)\n        Darkviolet           := 16#FF9400D3, // rgb(148,0,211)\n        Darkorchid           := 16#FF9932CC, // rgb(153,50,204)\n        Mediumorchid         := 16#FFBA55D3, // rgb(186,85,211)\n        Purple               := 16#FF800080, // rgb(128,0,128)\n        Thistle              := 16#FFD8BFD8, // rgb(216,191,216)\n        Plum                 := 16#FFDDA0DD, // rgb(221,160,221)\n        Violet               := 16#FFEE82EE, // rgb(238,130,238)\n        Magenta              := 16#FFFF00FF, // rgb(255,0,255)\n        Orchid               := 16#FFDA70D6, // rgb(218,112,214)\n        Mediumvioletred      := 16#FFC71585, // rgb(199,21,133)\n        Palevioletred        := 16#FFDB7093, // rgb(219,112,147)\n        Deeppink             := 16#FFFF1493, // rgb(255,20,147)\n        Hotpink              := 16#FFFF69B4, // rgb(255,105,180)\n        Lightpink            := 16#FFFFB6C1, // rgb(255,182,193)\n        Pink                 := 16#FFFFC0CB, // rgb(255,192,203)\n        Antiquewhite         := 16#FFFAEBD7, // rgb(250,235,215)\n        Beige                := 16#FFF5F5DC, // rgb(245,245,220)\n        Bisque               := 16#FFFFE4C4, // rgb(255,228,196)\n        Blanchedalmond       := 16#FFFFEBCD, // rgb(255,235,205)\n        Wheat                := 16#FFF5DEB3, // rgb(245,222,179)\n        Cornsilk             := 16#FFFFF8DC, // rgb(255,248,220)\n        Lemonchiffon         := 16#FFFFFACD, // rgb(255,250,205)\n        LightGoldenRodYellow := 16#FFFAFAD2, // rgb(250,250,210)\n        LightYellow          := 16#FFFFFFE0, // rgb(255,255,224)\n        SaddleBrown          := 16#FF8B4513, // rgb(139,69,19)\n        Sienna               := 16#FFA0522D, // rgb(160,82,45)\n        Chocolate            := 16#FFD2691E, // rgb(210,105,30)\n        Peru                 := 16#FFCD853F, // rgb(205,133,63)\n        SandyBrown           := 16#FFF4A460, // rgb(244,164,96)\n        BurlyWood            := 16#FFDEB887, // rgb(222,184,135)\n        RosyBrown            := 16#FFBC8F8F, // rgb(188,143,143)\n        Moccasin             := 16#FFFFE4B5, // rgb(255,228,181)\n        NavajoWhite          := 16#FFFFDEAD, // rgb(255,222,173)\n        PeachPuff            := 16#FFFFDAB9, // rgb(255,218,185)\n        MistyRose            := 16#FFFFE4E1, // rgb(255,228,225)\n        LavenderBlush        := 16#FFFFF0F5, // rgb(255,240,245)\n        Linen                := 16#FFFAF0E6, // rgb(250,240,230)\n        OldLace              := 16#FFFDF5E6, // rgb(253,245,230)\n        PapayaWhip           := 16#FFFFEFD5, // rgb(255,239,213)\n        Seashell             := 16#FFFFF5EE, // rgb(255,245,238)\n        MintCream            := 16#FFF5FFFA, // rgb(245,255,250)\n        SlateGray            := 16#FF708090, // rgb(112,128,144)\n        LightSlateGray       := 16#FF778899, // rgb(119,136,153)\n        LightSteelBlue       := 16#FFB0C4DE, // rgb(176,196,222)\n        Lavender             := 16#FFE6E6FA, // rgb(230,230,250)\n        FloralWhite          := 16#FFFFFAF0, // rgb(255,250,240)\n        AliceBlue            := 16#FFF0F8FF, // rgb(240,248,255)\n        GhostWhite           := 16#FFF8F8FF, // rgb(248,248,255)\n        HoneyDew             := 16#FFF0FFF0, // rgb(240,255,240)\n        Ivory                := 16#FFFFFFF0, // rgb(255,255,240)\n        Azure                := 16#FFF0FFFF, // rgb(240,255,255)\n        Snow                 := 16#FFFFFAFA, // rgb(255,250,250)\n        Black                := 16#FF000000, // rgb(0,0,0)\n        DimGray              := 16#FF696969, // rgb(105,105,105)\n        Gray                 := 16#FF808080, // rgb(128,128,128)\n        DarkGray             := 16#FFA9A9A9, // rgb(169,169,169)\n        Silver               := 16#FFC0C0C0, // rgb(192,192,192)\n        LightGray            := 16#FFD3D3D3, // rgb(211,211,211)\n        Gainsboro            := 16#FFDCDCDC, // rgb(220,220,220)\n        WhiteSmoke           := 16#FFF5F5F5, // rgb(245,245,245)\n        White                := 16#FFFFFFFF  // rgb(255,255,255)\n    ) UDINT;\nEND_TYPE\n</code></pre>"},{"location":"SPT_XTS/duts.html#e_moverassignmentrecoverysource","title":"E_MoverAssignmentRecoverySource","text":"<pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_MoverAssignmentRecoverySource : (\n        eMoverAssignmentRecoverySource_NoBackup   := 0,\n        eMoverAssignmentRecoverySource_NOVRAM     := 1,\n        eMoverAssignmentRecoverySource_Persistent := 2\n    );\nEND_TYPE\n</code></pre>"},{"location":"SPT_XTS/duts.html#e_xtsstate","title":"E_XTSState","text":"<pre><code>{attribute 'qualified_only'}\n{attribute 'strict'}\n{attribute 'to_string'}\nTYPE E_XTSState : (\n        eXTSState_Disabling := 0,\n        eXTSState_Disabled  := 1,\n        eXTSState_Enabling  := 2,\n        eXTSState_Enabled   := 4,\n        eXTSState_Error     := 8,\n        eXTSState_Reset     := 16\n    ) DWORD;\nEND_TYPE\n</code></pre>"},{"location":"SPT_XTS/duts.html#structs","title":"STRUCTs","text":""},{"location":"SPT_XTS/duts.html#st_gearinposcaparameters","title":"ST_GearInPosCAParameters","text":"<pre><code>TYPE ST_GearInPosCAParameters :\n    STRUCT\n        RatioNumerator      : MC_LREAL         := 1;\n        RatioDenumerator    : UINT             := 1;\n        MasterSyncPosition  : MC_LREAL         := MC_INVALID;\n        SlaveSyncPosition   : MC_LREAL         := MC_INVALID;\n        SyncStrategy        : MC_SYNC_STRATEGY := MC_SYNC_STRATEGY.mcSyncStrategyEarly;\n        SyncMode            : MC_SYNC_MODE     := MC_SYNC_MODE.mcSyncModePositive;\n        MasterStartDistance : MC_LREAL         := MC_IGNORE;\n        Velocity            : MC_LREAL         := MC_INVALID;\n        Acceleration        : MC_LREAL         := MC_DEFAULT;\n        Deceleration        : MC_LREAL         := MC_DEFAULT;\n        Jerk                : MC_LREAL         := MC_DEFAULT;\n        Gap                 : MC_LREAL         := MC_DEFAULT;\n        BufferMode          : MC_BUFFER_MODE   := mcAborting;\n        Options             : ST_GearInPosCAOptions;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_XTS/duts.html#st_movedynamics","title":"ST_MoveDynamics","text":"<pre><code>TYPE ST_MoveDynamics :\n    STRUCT\n        Velocity     : LREAL := 200;\n        Acceleration : LREAL := MC_DEFAULT;\n        Deceleration : LREAL := MC_DEFAULT;\n        Jerk         : LREAL := MC_DEFAULT;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_XTS/duts.html#st_xtsstationconfig","title":"ST_XTSStationConfig","text":"<pre><code>TYPE ST_XTSStationConfig :\n    STRUCT\n        IsAQueueStation : BOOL; //Can accept movers on cold start recovery (station limits will be ignored!!)\n        OverrideGap     : BOOL;\n        Gap             : LREAL;\n        Dynamics        : ST_MoveDynamics;\n    END_STRUCT\nEND_TYPE\n</code></pre>"},{"location":"SPT_XTS/examplestations.html","title":"Example Stations","text":"<p>While XTS is constantly being used in more complex and interesting ways, many applications are relatively basic: a closed loop with various \"stations\" along the track where movers need to stop and be worked on.  To compensate for differences in the cycle times of these various station processes, intermediate positions are typically specified between these stations where movers can line up and wait for the next station to be free.</p> <p>The <code>SPT_XTS</code> library contains some example implementations of station logic.  These function blocks can be \"plugged in\" directly to <code>FB_Component_XPU</code> and used as-is, or can be easily copied and modified to implement custom application-specific logic.</p>"},{"location":"SPT_XTS/examplestations.html#fb_xts_queuestation","title":"FB_XTS_QueueStation","text":"<p>(<code>FINAL</code>, extends <code>FB_XTS_StationBase</code>)</p> <p>A queue station will always accept movers from an upstream station, as long as the number of currently assigned movers doesn't exceed <code>MaxNumberOfMovers</code>.  Upon accepting a new mover, it is commanded to move to the first Stop Position (any other defined stop positions are ignored) using the dynamics specified in the station configuration.</p> <p>When the downstream station is ready for movers (<code>CanAcceptMovers</code> property = <code>TRUE</code>) the first mover in the buffer is immediately released from the QueueStation and passed to the downstream station.  It's possible that this condition is satisfied before the mover ever arrives at the QueueStation; it could even happen in the same PLC scan where the mover was accepted by the QueueStation.  In this case, the mover will not stop at the QueueStation's Stop Position.</p>"},{"location":"SPT_XTS/examplestations.html#properties","title":"Properties","text":"Property Type Access Description MaxNumberOfMovers UDINT RW Get/Set the maximum number of movers that can be in a queue at a time"},{"location":"SPT_XTS/examplestations.html#overriding-fb_xts_stationbase","title":"Overriding <code>FB_XTS_StationBase</code>","text":"<p>While much of the logic built in to <code>FB_XTS_StationBase</code> is reused, a few things were overridden and modified to create the queue.</p>"},{"location":"SPT_XTS/examplestations.html#canacceptmover","title":"CanAcceptMover","text":"<p>(from I_XTS_ApplicationStation)</p> <p>Queues need to accept incoming movers as long as there is room for them:</p> <p><code>CanAcceptMover := NumberOfAssignedMovers &lt; _MaxNumberOfMovers;</code></p>"},{"location":"SPT_XTS/examplestations.html#canreleasemover","title":"CanReleaseMover","text":"<p>(from I_XTS_ApplicationStation)</p> <p>Queues can always release movers as long as it has one to release:</p> <p><code>CanReleaseMover := NumberOfAssignedMovers &gt; 0;</code></p>"},{"location":"SPT_XTS/examplestations.html#resetting","title":"Resetting()","text":"<p>(from FB_PackML_BaseModule)</p> <p>The base <code>Resetting()</code> logic sends movers to discrete positions according to the Stop Positions configured.  Queues will only send movers to the first Stop Position, allowing collision avoidance to maintain a suitable gap between them:</p> <pre><code>METHOD PROTECTED Resetting\n\n// Need a copy of .Queue so we can index through array\nipMovers := MoverQueue.Queue;\nCASE SequenceState OF\n    0:\n        _Busy := TRUE;\n        MoverTracker.Clear();\n        SequenceState := SequenceState + 10;\n\n    10:\n        //Determine if any movers have been assigned to this station\n        IF NumberOfAssignedMovers &lt;&gt; 0 THEN\n            SequenceState := 100;\n        ELSE\n            SequenceState := 1000;\n        END_IF\n\n    100:\n        MoverTracker.Clear();\n        FOR i := 1 TO NumberOfAssignedMovers DO\n            IF ipMovers[i] &lt;&gt; 0 THEN\n                IF NOT ipMovers[i].Busy THEN\n                    //Queue stations always command movers to position 1\n                    StopPosition := StopPositions[1];\n                    StopPosition := GetStopPosition(StopPosition);\n                    IF ipMovers[i].MoveAbsoluteCA(StopPosition, TRUE, RecoveryMoveComplete) THEN\n                        MoverTracker.Set(i);\n                    END_IF\n                END_IF\n            END_IF\n        END_FOR\n\n        IF MoverTracker.NumberCompleted = NumberOfAssignedMovers THEN\n            RecoveryMoveComplete := TRUE;\n            SequenceState        := 1000;\n        END_IF\n\n    1000:\n        _Busy := FALSE;\n        SUPER^.Resetting();\nEND_CASE\n</code></pre>"},{"location":"SPT_XTS/examplestations.html#execute","title":"Execute()","text":"<p>(from FB_PackML_BaseModule)</p> <p>There is no <code>Execute()</code> logic defined in the base station; that is left up to the application developer.  In the case of a queue, the process in <code>Execute()</code> is to take ownership of a mover from the upstream station and command it to move to the first Stop Position.  There is no additional state machine required; as long as queues are in the Execute state, they are constantly pulling movers from the upstream station.</p> <pre><code>METHOD PROTECTED Execute\n\nGetMovers();\n</code></pre>"},{"location":"SPT_XTS/examplestations.html#getmovers","title":"GetMovers()","text":"<p>(from FB_XTS_StationBase)</p> <p><code>GetMovers()</code> is a helper method which asks the associated InfoStation for a mover and then commands the mover to the first Stop Position.  The actual logic for passing the mover's interface pointer from one station to the next is internal to the InfoStation.  The application need only call <code>GetMover()</code> on the InfoStation and wait for the return value <code>TRUE</code>, at which point the new mover will be available in <code>MoverQueue.LastMover</code>.</p> <pre><code>METHOD PROTECTED GetMovers : BOOL\n\nCASE SequenceState OF\n    0:\n        //Don't combine this with state 20 -- there is a dead scan for method cleanup/returns\n        IF CanAcceptMover THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    10:\n        IF ipInfoStation.GetMover() THEN\n            // Ask for a new mover      \n            SequenceState := SequenceState + 10;\n        END_IF\n\n    20:\n        //Make sure we don't page fault\n        IF MoverQueue.LastMover &lt;&gt; 0 THEN\n            // Call new mover to this station--use only stop position 1\n            StopPosition := StopPositions[1];\n            StopPosition := GetStopPosition(StopPosition);\n            IF MoverQueue.LastMover.MoveAbsoluteCA(StopPosition, TRUE, FALSE) THEN\n                SequenceState := 0;\n            END_IF\n        ELSE\n            SequenceState := 0;\n        END_IF\nEND_CASE\n</code></pre>"},{"location":"SPT_XTS/examplestations.html#fb_xts_simplestation","title":"FB_XTS_SimpleStation","text":"<p>(<code>FINAL</code>, extends <code>FB_XTS_StationBase</code>)</p> <p>SimpleStations have one or many Stop Positions defined by the XTS Configurator.  The number of Stop Positions dictates how many movers the station will accept at a time.  A simple state machine is implemented:</p> <ul> <li>GetMovers will ask the upstream station for movers until there is one mover for each Stop Position in the buffer and they have all arrived at their assigned Stop Position.</li> <li>InProcess starts a timer that simulates the cycle time of a station's intended process</li> <li>ReleaseMovers signals to the downstream station that movers are available and sends them along as requested</li> </ul> <p>Tip</p> <p>For many applications, the logic in <code>FB_XTS_SimpleStation</code> is adequate with the exception of the simulated process timer.  This was the design intent of <code>FB_XTS_StationBase</code>.  By simply extending <code>FB_XTS_StationBase</code> and overriding <code>Execute()</code>, many different application-specific station types can be developed without having to re-write code.</p>"},{"location":"SPT_XTS/examplestations.html#properties_1","title":"Properties","text":"Property Type Access Description SimulatedProcessTime TIME RW Get/Set the preset time for the process simulation timer"},{"location":"SPT_XTS/examplestations.html#overriding-fb_xts_stationbase_1","title":"Overriding <code>FB_XTS_StationBase</code>","text":""},{"location":"SPT_XTS/examplestations.html#execute_1","title":"Execute()","text":"<p>(from FB_PackML_BaseModule)</p> <p>There is no <code>Execute()</code> logic defined in the base station; that is left up to the application developer.  SimpleStations employ a basic state machine.  The <code>GetMovers()</code> method will return <code>TRUE</code> when all required movers have been acquired and are in position ready to be processed.  Note that <code>GetMovers()</code> is defined in <code>FB_XTS_StationBase</code> and is unchanged in SimpleStations.</p> <pre><code>METHOD PROTECTED Execute\n\nCASE StationState OF\n    E_ApplicationStationState.eApplicationStationState_GetMovers:\n        IF NOT _DisableStation THEN\n            IF GetMovers() THEN\n                StationState := E_ApplicationStationState.eApplicationStationState_InProcess;\n            END_IF\n        END_IF\n\n    E_ApplicationStationState.eApplicationStationState_InProcess:\n        ProcessSimulationTimer_TON(IN := NOT _Pause);\n        IF ProcessSimulationTimer_TON.Q THEN\n            ProcessSimulationTimer_TON(IN := FALSE);\n            StationState := E_ApplicationStationState.eApplicationStationState_ReleaseMovers;\n        END_IF\n\n    E_ApplicationStationState.eApplicationStationState_ReleaseMovers:\n        IF (NumberOfAssignedMovers = 0) THEN\n            // Downstream station has accepted all of our movers\n            StationState := E_ApplicationStationState.eApplicationStationState_GetMovers;\n        END_IF\nEND_CASE\n</code></pre>"},{"location":"SPT_XTS/functionblocks.html","title":"Function Blocks","text":""},{"location":"SPT_XTS/functionblocks.html#fb_component_xpu","title":"FB_Component_XPU","text":"<p>(<code>FINAL</code>, extends <code>FB_ComponentBase</code>, implements <code>I_XTS_Xpu</code>)</p> <p>Wrapper component for XPU TcCOM object and all of the children TcCOMs beneath.</p> <p>Serves as a central point of management for movers and their assignment to I_XTS_InfoStation and the corresponding I_XTS_ApplicationStation.</p> <p>Basic mover management functions are handled within and exposed via public methods.</p> <p>Hardware diagnostic data is automatically collected and made available by property.</p> <p>Retention of mover station assignments is optionally available via Persistent data or NOVRAM (if equipped).  Automatic restoration of retained assignments on cold start is provided.</p> <p>Example Reference Stations</p> <p>See example reference stations for example station types which extend this function block.</p> <p>Info</p> <p>See I_XTS_Xpu for more information.</p>"},{"location":"SPT_XTS/functionblocks.html#properties","title":"Properties","text":"Property Type Access Description MoverAssignmentStorageLocation E_MoverAssignmentRecoverySource RW Get/Set the location, if any, for retention of mover station assignments PartCoEData ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsPartsPerXpu] OF ARRAY[1..TcIoXtsEnvironmentParameterList.MaxModulesPerPart] OF ST_AT2xxxAllCoEData R Get diagnostic data from XPU/Hardware State E_XTSState R Get the current state of the XPU Stations ARRAY[0..TcIoXtsEnvironmentParameterList.MaxXtsInfoServer * TcIoXtsEnvironmentParameterList.MaxXtsInfoStation] OF I_XTS_ApplicationStation RW Get/Set interface pointers to assign application stations to InfoStations <p>Zero-based arrays</p> <p>For internal purposes, many arrays in this library are zero-based.  However, index 0 is never to be used.  Always start at index 1.</p>"},{"location":"SPT_XTS/functionblocks.html#methods","title":"Methods","text":"Method Return Type Access Description ClearMoverAssignments BOOL PUBLIC Returns <code>TRUE</code> if the <code>Set()</code> has been called on index <code>i</code> Disable BOOL PUBLIC Returns <code>TRUE</code> when the entire tracking register has been cleared Enable BOOL PUBLIC Clears the tracking register on index <code>i</code> and returns <code>TRUE</code> Reset BOOL PUBLIC Sets the tracking register on index <code>i</code> and returns <code>TRUE</code>"},{"location":"SPT_XTS/functionblocks.html#clearmoverassignments","title":"ClearMoverAssignments","text":"<p><code>METHOD PUBLIC ClearMoverAssignments : BOOL</code></p> <p>If enabled, mover station assignments are constantly being collected and persisted internally within the XPU component.  This method allows you to clear these assignments.</p> <p>Upon the next execution of <code>Reset()</code> the XPU component will automatically assign all movers to the next station in the positive direction whose configuration has the <code>IsAQueueStation</code> flag set.</p>"},{"location":"SPT_XTS/functionblocks.html#disable","title":"Disable","text":"<p><code>METHOD PUBLIC Disable : BOOL</code></p> <p>Disables all mover axes and dissolved the collision avoidance group.</p>"},{"location":"SPT_XTS/functionblocks.html#enable","title":"Enable","text":"<p><code>METHOD PUBLIC Enable : BOOL</code></p> <p>Enables all mover axes and adds them to the collision avoidance group.  Enables the collision avoidance group.</p>"},{"location":"SPT_XTS/functionblocks.html#reset","title":"Reset","text":"<p><code>METHOD PUBLIC Reset : BOOL</code></p> <p>Disables all movers, clears any group/mover faults.  If the mover station assignment recovery process has not yet been performed, or <code>ClearMoverAssignments()</code> was previously called, the XPU component will automatically assign all movers to the next station in the positive direction whose configuration has the <code>IsAQueueStation</code> flag set.</p>"},{"location":"SPT_XTS/functionblocks.html#fb_moverqueue","title":"FB_MoverQueue","text":"<p>Helper function block that holds a buffer of I_XTS_Mover for use by applications stations.  Assignment of movers from one station to the next happens internal to the XPU.  Application stations should use the properties listed below to gain access to specific movers for motion commands.</p>"},{"location":"SPT_XTS/functionblocks.html#properties_1","title":"Properties","text":"Property Type Access Description Count UDINT R Returns the number of I_XTS_Mover currently in the buffer FirstMover I_XTS_Mover R Returns an interface pointer to the first mover in the buffer LastMover I_XTS_Mover R Returns an interface pointer to the last mover in the buffer MoverIDs ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsMoversPerXpu] OF UDINT R Returns the mover IDs of all mover currently in the buffer Queue ARRAY[0..TcIoXtsEnvironmentParameterList.MaxXtsMoversPerXpu] OF I_XTS_Mover R Returns an array of interface pointers representing all movers in the buffer"},{"location":"SPT_XTS/functionblocks.html#methods_1","title":"Methods","text":"Method Return Type Access Description Clear BOOL PUBLIC Clears all movers from the buffer Dequeue null PUBLIC Returns <code>TRUE</code> when the first mover in the buffer has been removed Enqueue BOOL PUBLIC Returns <code>TRUE</code> when a mover has been added to the buffer (FIFO) <p>These methods are used internally!</p> <p>The methods listed above are called internally by the XPU and should never need to be called by application stations!</p>"},{"location":"SPT_XTS/functionblocks.html#fb_trackingregister_movers","title":"FB_TrackingRegister_Movers","text":"<p>Helper function block used to track different operations performed on movers.</p> <p>Why would I want this?</p> <p>The calling pattern for motion methods on movers is \"returns <code>TRUE</code> when the command has been accepted\".  This is not the same as \"command complete\".</p> <p>Take for example a collection of movers you want to move to a position on the track.  Calling <code>MoveAbsoluteCA()</code> on all of them simultaneously will return <code>TRUE</code> right away (assuming they were all ready to move) but they won't finish at the same time.  So we need some mechanism to call the command on all of the movers until it is accepted by all and then wait for the movement to be complete in a separate state.  This function block serves that purpose.</p>"},{"location":"SPT_XTS/functionblocks.html#properties_2","title":"Properties","text":"Property Type Access Description NumberCompleted UDINT R Returns the number of movers that <code>Set()</code> has been called for"},{"location":"SPT_XTS/functionblocks.html#methods_2","title":"Methods","text":"Method Return Type Access Description Check BOOL PUBLIC Returns <code>TRUE</code> if the <code>Set()</code> has been called on index <code>i</code> Clear BOOL PUBLIC Returns <code>TRUE</code> when the entire tracking register has been cleared Reset BOOL PUBLIC Clears the tracking register on index <code>i</code> and returns <code>TRUE</code> Set BOOL PUBLIC Sets the tracking register on index <code>i</code> and returns <code>TRUE</code>"},{"location":"SPT_XTS/functionblocks.html#fb_xts_stationbase","title":"FB_XTS_StationBase","text":"<p>(abstract, extends <code>FB_PackML_BaseModule</code>, implements <code>I_XTS_ApplicationStation</code>)</p> <p>Provides a basic implementation of I_XTS_ApplicationStation.  Being <code>ABSTRACT</code>, this function block must be extended and cannot be instantiated directly.  The default behavior can be overridden by its descendants.</p> <p>Example Reference Stations</p> <p>See example reference stations for example station types which extend this function block.</p>"},{"location":"SPT_XTS/functionblocks.html#properties_3","title":"Properties","text":"Property Type Access Description NumberOfAssignedMovers UDINT R Returns the number of movers currently assigned to this station NumberOfStops UDINT R Returns the number stop positions for this station StopPositions REFERENCE TO ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsStopPositionsPerStation] OF LREAL R Returns all stop position locations <p>Stop Positions cannot be commanded as-is!</p> <p>Stop Positions as defined by the XTS Configurator are relative to the Start Position of the station.  This Start Position is relative to the datum of the assigned Part.  Move commands require positions that are relative to the Track that the mover is assigned to. </p> <p></p> <p>In order to tranform a station Stop Position into a usable Track position use <code>GetStopPosition()</code>.</p> <pre><code>//Get the track position of the first stop position\nStopPosition := GetStopPosition(StopPositions[1]);\n\n//Send the last mover in line there\nIF MoverQueue.LastMover.MoveAbsoluteCA(StopPosition, TRUE, FALSE) THEN\n    //Do stuff\nEND_IF\n</code></pre>"},{"location":"SPT_XTS/functionblocks.html#methods_3","title":"Methods","text":"Method Return Type Access Description GetMovers BOOL PROTECTED Requests movers from upstream neighbor and commands each to its respective Stop Position.  Returns <code>TRUE</code> when <code>NumberOfAssignedMovers</code> = <code>NumberOfStops</code> and all movers are in position GetStopPosition LREAL PROTECTED Returns the corresponding Track position for a given stop position"},{"location":"SPT_XTS/functionblocks.html#default-behavior","title":"Default Behavior","text":"<p>The descendants of this function block are meant to be registered as Equipment Modules with a Machine Module and thus implement the PackML state machine.  Not all PackML states are required for basic station operation.  The states where custom logic was implemented are described below.</p> <p>PackML</p> <p>See SPT_Base_Types for more information.</p>"},{"location":"SPT_XTS/functionblocks.html#resetting","title":"Resetting","text":"<p>Determines if any movers have already been assigned to this station and commands them to move to their respective stop position.  When all movers have arrived at their stop positions, the state is complete.</p>"},{"location":"SPT_XTS/functionblocks.html#stopping","title":"Stopping","text":"<p>Waits for all assigned movers to be stopped, after which the state is complete.  This state does not command a stop.  Rather, it allows any in-progress move commands to complete.</p>"},{"location":"SPT_XTS/functionblocks.html#execute","title":"Execute","text":"<p>Descendants of this base function block should implement their own logic in <code>Execute()</code>.  No logic is provided in this base function block.</p>"},{"location":"SPT_XTS/globals.html","title":"Globals/Parameters","text":""},{"location":"SPT_XTS/globals.html#parameters","title":"Parameters","text":""},{"location":"SPT_XTS/globals.html#parameters_xts","title":"Parameters_XTS","text":"Parameter Type Default Description ALLOW_UNLINKED_MOVER_NC_AXES BOOL FALSE Allows internal FB_XTS_Mover FBs to skip checking for linked NC axes during initialization ENABLE_DEBUG_TRACING BOOL FALSE Allow debug messages to be emitted to trace log STATIONCOLOR_DEFAULT_GETMOVERS E_Colors_ARGB E_Colors_ARGB.Yellow XTS Viewer station color during GetMovers state STATIONCOLOR_DEFAULT_INPROCESS E_Colors_ARGB E_Colors_ARGB.Red XTS Viewer station color during InProcess state STATIONCOLOR_DEFAULT_RELEASEMOVERS E_Colors_ARGB E_Colors_ARGB.Green XTS Viewer station color during ReleaseMovers state <p>XPU generates a lot of trace messages</p> <p><code>FB_Component_XPU</code> generates a great deal of trace messages when <code>ENABLE_DEBUG_TRACING</code> is <code>TRUE</code>.  Eventually (after many thousands of messages) this can cause instability in XAE/Visual Studio due in part to the Errors List window also receiving these messages.</p> <p>These trace messages are very helpful for debugging systems but should be disabled in production.</p>"},{"location":"SPT_XTS/globals.html#gvls","title":"GVLs","text":""},{"location":"SPT_XTS/globals.html#xts","title":"XTS","text":"<pre><code>{attribute 'qualified_only'}\nVAR_GLOBAL\n    Environment              : Tc3_XTS_Utility.FB_TcIoXtsEnvironment;\n    XTSEnvironmentConfig     : ST_XtsEnvironmentConfiguration := (bEnableInitXPU := TRUE, bEnableInitCaGroup := TRUE, bEnableInitInfoServer := TRUE);\n    InitializationInProgress : BOOL;\n    InitializationComplete   : BOOL;\n    XPUCount                 : UINT;\n    XPUOIDs                  : REFERENCE TO ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsProcessingUnits] OF OTCID;\n    InfoServerCount          : UINT;\n    InfoServerOIDs           : REFERENCE TO ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsInfoServer] OF OTCID;\n    InfoStationCounts        : ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsInfoServer] OF UDINT;\n    ipInfoServer             : ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsInfoServer] OF I_TcIoXtsInfoServer;\n    ipInfoStations           : ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsInfoServer, 1..TcIoXtsEnvironmentParameterList.MaxXtsInfoStation] OF I_TcIoXtsInfoServerInfoStation;\n    CAGroupCount             : UINT;\n    CAGroupOIDs              : REFERENCE TO ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsCaGroup] OF OTCID;\nEND_VAR\n</code></pre> <p>Note</p> <p>See also: FB_TcIoXtsEnvironment, ST_XtsEnvironmentConfiguration, I_TcIoXtsInfoServer, I_TcIoXtsInfoServerInfoStation.</p> <p>Do not modify these variables!</p> <p>The variables in the <code>XTS</code> GVL are used internally by <code>FB_Component_XPU</code>.  Changing the values of any of these variables will only end in disaster or at best instability.</p>"},{"location":"SPT_XTS/interfaces.html","title":"Interfaces","text":""},{"location":"SPT_XTS/interfaces.html#i_xts_applicationstation","title":"I_XTS_ApplicationStation","text":"<p>Application Stations are the function blocks that hold the actual logic of a machine station.  They are responsible for positioning movers and performing any other operations on the part(s) being conveyed.</p> <p>Application Stations are linked 1:1 via interface pointer to their respective InfoStations.  In other words, an Application Station can only have one linked InfoStation and vice-versa.  This link is bi-directional.</p> <p>InfoStations take care of the intricacies of buffer management, station relationships, etc. and actually contain the buffer of movers within them.  Application Stations work alongside InfoStations at the application layer to signal when their particular logic and sequence can either accommodate a new mover or is finished with a mover under its control.</p>"},{"location":"SPT_XTS/interfaces.html#properties","title":"Properties","text":"Property Type Access Description CanAcceptMover BOOL R Get whether or not this station can accept an additional mover into its buffer CanReleaseMover BOOL R Get whether or not this station can release a mover from its buffer Config ST_XTSStationConfig RW Get/Set configuration struction for this station InfoStation I_XTS_InfoStation W Set the InfoStation that is associated with this station Name STRING R Get the friendly name of this station TrackOID OTCID R Get the OID of the Track that this station is associated with"},{"location":"SPT_XTS/interfaces.html#i_xts_infostation","title":"I_XTS_InfoStation","text":"<p>An InfoStation is a zone which spans a part, as defined by a Start and End position along the part.  Additionally, stop positions can be defined relative to the Start position.</p> <p>Warning</p> <p>Note that the XTS configuration tool allows for the specification of multiple parts in an InfoStation definition.  This is not supported by this component/framework.  An InfoStation can only be defined across a single part.</p>"},{"location":"SPT_XTS/interfaces.html#properties_1","title":"Properties","text":"Property Type Access Description ApplicationStation I_XTS_ApplicationStation RW Get/Set interface pointer to the function block who is controlling the application logic for this InfoStation Color E_Colors_ARGB RW Get/Set the color of this InfoStation that will be displayed on the XTS Viewer MoverQueue REFERENCE TO FB_MoverQueue R Get a reference to the buffer of movers currently under this station's control NumberOfStops UDINT R Get the number of stop positions defined for this station StopPositions REFERENCE TO ARRAY[1..TcIoXtsEnvironmentParameterList.MaxXtsStopPositionsPerStation] OF LREAL R Get a reference to the stop positions defined for this station"},{"location":"SPT_XTS/interfaces.html#methods","title":"Methods","text":"Method Return Type Description GetMover BOOL Returns <code>TRUE</code> when a mover has been successfully passed from the upstream neighbor station and is ready to be commanded by this station GetPositionOnTrack LREAL Given a position on a relative to the start position of this station, along with the <code>OTCID</code> of the desired track, returns the corresponding track position"},{"location":"SPT_XTS/interfaces.html#i_xts_mover","title":"I_XTS_Mover","text":"<p>(extends <code>I_CyclicFB</code>)</p> <p>Defines basic required functionality for an XTS mover.</p>"},{"location":"SPT_XTS/interfaces.html#properties_2","title":"Properties","text":"Property Type Access Description Axis REFERENCE TO AXIS_REF R Returns an AXIS_REF for use in external motion functions, etc. LimitBipolarCurrent BOOL RW Enable/Disable the limiting of current to the mover MoverID UDINT R Returns the mover index on its associated XTS Override LREAL RW Get/Set axis override (100.0 = 100%) Station I_XTS_ApplicationStation RW Get/Set the station to which this mover has been assigned"},{"location":"SPT_XTS/interfaces.html#dynamics","title":"Dynamics","text":"Property Type Access Description Acceleration LREAL RW Get/Set acceleration input to motion functions Deceleration LREAL RW Get/Set deceleration input to motion functions Jerk LREAL RW Get/Set jerk input to motion functions Velocity LREAL RW Get/Set velocity input to motion functions (exception: <code>MoveVelocity()</code>)"},{"location":"SPT_XTS/interfaces.html#feedback","title":"Feedback","text":"Property Type Access Description ActualAcceleration LREAL R Get actual acceleration of axis ActualPosition LREAL R Get actual position of axis ActualPositionModulo LREAL R Get actual modulo position of axis ActualTorque LREAL R Get actual torque of axis ActualVelocity LREAL R Get actual velocity of axis PositionLag LREAL R Get position lag of axis SetAcceleration LREAL R Get setpoint acceleration of axis SetPosition LREAL R Get setpoint position of axis SetPositionModulo LREAL R Get setpoint modulo position of axis SetVelocity LREAL R Get setpoint velocity of axis"},{"location":"SPT_XTS/interfaces.html#status","title":"Status","text":"Property Type Access Description Enabled BOOL R Axis is enabled InPosition BOOL R Axis is within target position window InSync BOOL R Axis is synchronized with its master Stopped BOOL R Axis is not moving"},{"location":"SPT_XTS/interfaces.html#methods_1","title":"Methods","text":"Method Return Type Description Disable BOOL Disable axis Enable BOOL Enable axis GearInPosCA BOOL Initiate gearing synchronization\\ JoinGroup BOOL Join the associated collision avoidance group LeaveGroup BOOL Leave the associated collision avoidance group MoveAbsoluteCA BOOL Initiate an absolute move with collision avoidance MoveRelativeCA BOOL Initiate a relative move with collision avoidance Reset BOOL Reset axis Stop BOOL Commands a stop of the mover"},{"location":"SPT_XTS/interfaces.html#i_xts_part","title":"I_XTS_Part","text":"<p>A part is a collection of XTS motor modules, typically segmented by infeed modules.  An XTS system is comprised of one or many parts.</p>"},{"location":"SPT_XTS/interfaces.html#properties_3","title":"Properties","text":"Property Type Access Description Name STRING R Returns the object name of the associated XPU part ReadyToEnable BOOL R Returns <code>TRUE</code> if the <code>DriveState</code> of the part is satisfactory for enabling movers"},{"location":"SPT_XTS/interfaces.html#i_xts_stationneighbor","title":"I_XTS_StationNeighbor","text":"<p>Don't use this directly</p> <p>Internal type used to keep track of upstream/downstream relationships between InfoStations.  This should not be used at the application level and is only documented here for clarity.</p>"},{"location":"SPT_XTS/interfaces.html#properties_4","title":"Properties","text":"Property Type Access Description StationName STRING R Returns friendly name of the associated Application Station"},{"location":"SPT_XTS/interfaces.html#methods_2","title":"Methods","text":"Method Return Type Description GiveMover BOOL Returns <code>TRUE</code> when an InfoStation has successfully passed a mover to its downstream neighbor TakeMover BOOL Returns <code>TRUE</code> when an InfoStation accepts a mover into its buffer"},{"location":"SPT_XTS/interfaces.html#i_xts_track","title":"I_XTS_Track","text":"<p>A track is a logical path that XTS movers exist on.  Tracks are defined by including one or many parts.  The datum point of a track is typically the upstream side of the first part.  Multiple tracks can exist in the same XTS system, and can also overlap.  This means that a the same physical position on an XTS system can be a different track position, depending on how the track is defined.  A mover can only be assigned to one track at a time.  Collision avoidance is performed according to track.  This means that given a lineup of stationary movers, all avoiding collision, if a mover is assigned to a different track the movers upstream of that one will advance and collide.</p>"},{"location":"SPT_XTS/interfaces.html#properties_5","title":"Properties","text":"Property Type Access Description IsClosed BOOL R Returns <code>TRUE</code> if the track is a closed loop Length LREAL R Returns the length of the part in millimeters Name STRING R Returns the object name of the track"},{"location":"SPT_XTS/interfaces.html#methods_3","title":"Methods","text":"Method Return Type Description GetTrackPositionByPart LREAL Given a position on a particular part, along with the <code>OTCID</code> of the part, returns the corresponding track position"},{"location":"SPT_XTS/interfaces.html#i_xts_xpu","title":"I_XTS_Xpu","text":""},{"location":"SPT_XTS/interfaces.html#properties_6","title":"Properties","text":"Property Type Access Description InSimulationMode BOOL R Returns <code>TRUE</code> if the XPU driver is set to run in simulation mode"},{"location":"SPT_XTS/interfaces.html#methods_4","title":"Methods","text":"Method Return Type Description GetPositionOnTrack LREAL Given a position on a particular part, along with the <code>OTCID</code> of part &amp; track, returns the corresponding track position GiveMover BOOL Returns <code>TRUE</code> when a mover has been added to the <code>MoverQueue</code> of the requesting station"},{"location":"SPT_XTS/quickstart.html","title":"QuickStart","text":""},{"location":"SPT_XTS/quickstart.html#intial-setup","title":"Intial Setup","text":"<p>This process can take a few different paths, but the end goal is to have the XTS system laid out in your TwinCAT project.  This layout should include:</p> <ul> <li>Realtime Configuration</li> <li>PLC Task</li> <li>XTS Task(s) (250us cycle time)</li> <li>Proper core allocation</li> <li>TcCOM Objects</li> <li>XPU - Parts, Tracks, Movers</li> <li>InfoServer - Station definitions including stop positions</li> <li>NC Configuration</li> <li>Collision Avoidance TcCOM object<ul> <li>Track length matching XPU track length</li> </ul> </li> <li>Mover Axes with correct SoftDrive configuration/links</li> <li>EtherCAT configuration</li> <li>Motor modules as children of EtherCAT masters</li> <li>Masters may be disabled for execution in simulation mode</li> <li>Distributed clock timing checked and correct</li> </ul>"},{"location":"SPT_XTS/quickstart.html#simulation-mode","title":"Simulation Mode","text":"<p>Hardware configuration for simulation mode can be easily built using the XTS Simulation Builder:</p> <p></p>"},{"location":"SPT_XTS/quickstart.html#no-twincat-project-loaded","title":"No TwinCAT project loaded","text":"<p>The simulation builder includes template options for quickly building common track layouts:</p> <p></p>"},{"location":"SPT_XTS/quickstart.html#adding-xts-to-existing-twincat-project","title":"Adding XTS to existing TwinCAT project","text":"<p>Use Modify Projects to build a track layout by hand and add it to an existing TwinCAT project</p> <p></p>"},{"location":"SPT_XTS/quickstart.html#hardware-in-hand","title":"Hardware in hand","text":"<p>If running on real XTS hardware, refer to InfoSys for detailed configuration steps.</p>"},{"location":"SPT_XTS/quickstart.html#ca-group-configration","title":"CA Group Configration","text":"<p>A collision avoidance group object must be added to the NC configuration:</p> <p></p> <p></p> <p>CA group must be parameterized.  Rail length must match the actual XTS track length:</p> <p></p>"},{"location":"SPT_XTS/quickstart.html#application-programming","title":"Application Programming","text":"<p>This example will use the SPT PackML method of machine organization and programming but realize that there is no formal requirement for PackML to be involved to use the XTS component.</p> <p>The steps below assume the following configuration, but can be easily adapted to suit a variety of different setups:  - 3000 MM oval-shaped track using clothoid ends  - 1 Part  - 1 Track  - 10 Movers  - 4 Stations    - Station 1: Queue    - Station 2: SimpleStation, 1 stop position    - Station 3: Queue    - Station 4: SimpleStation, 1 stop position</p> <p></p> <p>Add a PLC project and reference the required libraries:   - SPT Base Types   - SPT XTS   - Tc3_XTS_Utility   - Tc3_PackML_V2</p>"},{"location":"SPT_XTS/quickstart.html#fb_machine","title":"FB_Machine","text":"<p>Create a function block <code>FB_Machine</code> which extends <code>FB_PackML_BaseModule</code>.  Instantiate <code>FB_Component_XPU</code> and station equipment modules.  Create configuration structures for each of the stations as well as an array for assigning the station instances to the XPU during initialization.  This function block will serve as our Machine Module, or the root of the control structure. <pre><code>FUNCTION_BLOCK FB_Machine EXTENDS FB_PackML_BaseModule\nVAR\n    XPU : FB_Component_XPU := (Name := 'XPU 1', Stations := ipStations, MoverAssignmentStorageLocation := E_MoverAssignmentRecoverySource.eMoverAssignmentRecoverySource_NoBackup);\n    Station1 : FB_XTS_QueueStation;\n    Station2 : FB_XTS_SimpleStation;\n    Station3 : FB_XTS_QueueStation;\n    Station4 : FB_XTS_SimpleStation;\n    StationConfig_Station1 : ST_XTSStationConfig;\n    StationConfig_Station2 : ST_XTSStationConfig;\n    StationConfig_Station3 : ST_XTSStationConfig;\n    StationConfig_Station4 : ST_XTSStationConfig;\n    ipStations : ARRAY[0..TcIoXtsEnvironmentParameterList.MaxXtsInfoServer * TcIoXtsEnvironmentParameterList.MaxXtsInfoStation] OF I_XTS_ApplicationStation;\nEND_VAR\n</code></pre></p>"},{"location":"SPT_XTS/quickstart.html#method-overrides","title":"Method Overrides","text":"<p>We must have an initialize routine to make some assignments and to perform some setup tasks.  <code>FB_PackML_BaseModule</code> already has an <code>Initialize()</code> method that we can override.  We must also override some of the acting state methods of <code>FB_PackML_BaseModule</code> in order to modify the default behavior.  <code>Aborting()</code>, <code>Clearing()</code>, <code>Resetting()</code>, and <code>Stopping()</code> should be overriden.</p>"},{"location":"SPT_XTS/quickstart.html#initialize","title":"Initialize()","text":"<p>Basic parameterization and assignment are done in the <code>Initialize()</code> method.  Note in particular the lines <code>StationConfig_Station1.IsAQueueStation := TRUE;</code> and <code>StationConfig_Station3.IsAQueueStation     := TRUE;</code>.  These bits indicate to the XPU component that during a cold start with no mover assignment backup data source, stations 1 and 3 are candidates for serving as a starting point where movers will be sorted and assigned to.</p> <pre><code>METHOD PROTECTED Initialize : BOOL;\n\nipComponents[1] := XPU;\nipSubModules[1] := Station1;\nipSubModules[2] := Station2;\nipSubModules[3] := Station3;\nipSubModules[4] := Station4;\nipStations[1] := Station1;\nipStations[2] := Station2;\nipStations[3] := Station3;\nipStations[4] := Station4;\nStation1.Config := StationConfig_Station1;\nStation2.Config := StationConfig_Station2;\nStation3.Config := StationConfig_Station3;\nStation4.Config := StationConfig_Station4;\nStationConfig_Station1.IsAQueueStation   := TRUE;\nStationConfig_Station1.Dynamics.Velocity := 500;\nStationConfig_Station2.Dynamics.Velocity := 500;\nStationConfig_Station3.IsAQueueStation   := TRUE;\nStationConfig_Station3.Dynamics.Velocity := 500;\nStationConfig_Station4.Dynamics.Velocity := 500;\nXPU.Stations := ipStations;\nInitialize := SUPER^.Initialize();\n</code></pre>"},{"location":"SPT_XTS/quickstart.html#aborting","title":"Aborting()","text":"<p>The default behavior of <code>Aborting()</code> does not know anything about the XPU's <code>Disable()</code> method.  Here we first disable the XPU component if required and then allow the base <code>Aborting()</code> method to continue with the rest of the equipment modules and components. <pre><code>METHOD PROTECTED Aborting\n\nCASE SequenceState OF\n    0:\n        IF XPU.State = E_XTSState.eXTSState_Enabled OR XPU.State = E_XTSState.eXTSState_Disabling THEN\n            IF XPU.Disable() THEN\n                SequenceState := SequenceState + 10;\n            END_IF\n        ELSIF XPU.State = E_XTSState.eXTSState_Disabled OR XPU.State = E_XTSState.eXTSState_Error THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    10:\n        SUPER^.Aborting();\nEND_CASE\n</code></pre></p>"},{"location":"SPT_XTS/quickstart.html#clearing","title":"Clearing()","text":"<p>The default behavior of <code>Clearing()</code> does not call <code>Reset()</code> on components that do not have errors.  Because mover assignment recovery is triggered by the <code>Reset()</code> method, we must make sure it is called regardless of error state.  Default behavior can resume afterward. <pre><code>METHOD PROTECTED Clearing\n\nCASE SequenceState OF \n    0:\n        IF XPU.Reset() THEN\n            SequenceState := SequenceState + 10;    \n        END_IF\n\n    10:\n        SUPER^.Clearing();\nEND_CASE\n</code></pre></p>"},{"location":"SPT_XTS/quickstart.html#resetting","title":"Resetting()","text":"<p>Similar to the case of <code>Aborting()</code> above, the XPU has an <code>Enable()</code> method which builds the CA group, enables mover axis, etc. which much be called.</p> <pre><code>METHOD PROTECTED Resetting\n\nCASE SequenceState OF\n    0:\n        IF XPU.Enable() THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    10:\n        SUPER^.Resetting();\nEND_CASE\n</code></pre>"},{"location":"SPT_XTS/quickstart.html#stopping","title":"Stopping()","text":"<p>The default behavior of <code>Stopping()</code> only handles issuing a stop command to equipment modules.  We also want to disable the XPU component after reaching this state.</p> <pre><code>METHOD PROTECTED Stopping\nVAR\n  i : UDINT;\n  SubModulesReady : BOOL := TRUE;\nEND_VAR\n</code></pre> <pre><code>CASE SequenceState OF\n    0:\n        // Send stop command to all sub modules\n        FOR i := 1 TO NumberOfSubModules DO\n            ipSubModules[i].StateCommand := ePMLCommand_Stop;\n        END_FOR\n\n        FOR i := 1 TO NumberOfSubModules DO\n            SubModulesReady := SubModulesReady AND (ipSubModules[i].CurrentState = ePMLState_Stopped OR ipSubModules[i].CurrentState = ePMLState_Aborted);\n        END_FOR\n\n        IF SubModulesReady THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    10:\n        IF XPU.Disable() THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    20:\n        IF XPU.State = E_XTSState.eXTSState_Disabled THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    30:\n        StateComplete();\nEND_CASE\n</code></pre>"},{"location":"SPT_XTS/quickstart.html#main-pou","title":"MAIN POU","text":"<p>Now that we have created our machine module and overridden the default behavior of <code>FB_PackML_BaseModule</code> as required, we can introduce it into the cyclic program logic.</p> <p>The default PLC project template in TwinCAT XAE will create a <code>MAIN</code> POU and attach it to the default PlcTask.  This will be the entry point for our program.</p> <p>Instantiate <code>FB_Machine</code> and <code>FB_ControlSource</code>.  <code>FB_ControlSource</code> simply provides a quick and easy means for commanding the machine module to different states and provides feedback on current machine module status.</p> <pre><code>PROGRAM MAIN\nVAR\n    Machine : FB_Machine;\n    ControlSource : FB_ControlSource;\nEND_VAR\n</code></pre> <p>We must attach <code>ControlSource</code> to the machine module so that it knows what it's controlling.  We must also make the calls to <code>CyclicLogic()</code> for both our machine module and <code>ControlSource</code>:</p> <pre><code>IF _TaskInfo[1].FirstCycle THEN\n    Machine.RegisterExternalController(ControlSource);\nEND_IF\n\nMachine.CyclicLogic();\nControlSource.CyclicLogic();\n</code></pre>"},{"location":"SPT_XTS/quickstart.html#linking-process-data-to-plc","title":"Linking process data to PLC","text":"<p>At this point you should be able to build the PLC project with no errors.  Doing this also will let XAE know of any allocated variables (<code>%I*</code>/<code>%Q*</code>) in our program and allow us to link them to other TwinCAT modules.</p>"},{"location":"SPT_XTS/quickstart.html#nc-axes","title":"NC Axes","text":"<p>The XPU component contains an array of mover function blocks (upper bound set in the <code>Tc3_XTS_Utility</code> library <code>TcIoXtsEnvironmentParameterList.MaxXtsMoversPerXpu</code>).  These must be linked to our NC axes.  Note the array starts at index 0 for internal reasons, but mover 0 is never actually used.  Start at mover 1.</p> <p></p>"},{"location":"SPT_XTS/quickstart.html#ca-group","title":"CA Group","text":"<p>The XPU component also contains the necessary <code>AXES_GROUP_REF</code> which must be linked to our collision avoidance group TcCOM object.</p> <p></p> <p></p>"},{"location":"SPT_XTS/quickstart.html#tracing","title":"Tracing","text":"<p>The XPU component emits a great deal of debug information to the Event Logger, which can be useful for debug.  By default, this messaging is turned off in order to not bog down the development environment.  During the initial commissioning it can be re-enabled through the library parameters:</p> <p></p>"},{"location":"SPT_XTS/quickstart.html#results","title":"Results","text":"<p>At this point we should be able to activate the configuration, restart in Run Mode, and Login to the PLC.  Adding the following variable to the Watch window gives us convenient place to monitor the progress.</p> <p></p> <p><code>ControlSource.MainPMLControl_Simplified.ResetPressed</code>, <code>StartPressed</code>, and <code>StopPressed</code> can be toggled manually to advance through the PackML states.  These can also be tied to buttons on a Visualization or TwinCAT HMI screen, for example.</p>"},{"location":"SPT_XTS/quickstart.html#varying-configurations","title":"Varying Configurations","text":"<p>In this example, Stations 2 &amp; 4 are type <code>FB_XTS_SimpleStation</code>.  This example function block includes a property <code>SimulatedProcessTime</code> which controls a timer which begins counting when all movers have arrived at their stop position(s) and upon expiration signals the station to release all movers to the next neighbor.  A variety of processes can be simulated by varying this time setpoint, as well as defining multiple stop positions using the XTS Configurator.</p> <p>Stations 1 &amp; 3 are type <code>FB_XTS_QueueStation</code>.  This example function block includes a property <code>MaxNumberOfMovers</code> which controls how many movers are allowed into the station's mover buffer at one time.  Note that even though the XTS Configurator allows for multiple stop positions to be defined, <code>FB_XTS_QueueStation</code> will only command movers to move to the first stop position.  Any other stop positions are ignored.</p>"},{"location":"SPT_XTS/quickstart.html#custom-stations","title":"Custom Stations","text":"<p><code>FB_XTS_SimpleStation</code> and <code>FB_XTS_QueueStation</code> are provided for reference only.  They represent the most basic types of station logic that may be part of an XTS system.  Custom station logic can be implemented from scratch, or with help from inheriting <code>FB_XTS_StationBase</code>.  <code>FB_XTS_StationBase</code> is an <code>ABSTRACT</code> function block which contains the basic components that one would use to implement a custom station type.</p>"},{"location":"SPT_XTS/stationprogrammingnotes.html","title":"GetMovers()","text":"<p>InfoStations (internal to XPU component) are responsible for delivering to the Application Station a buffer of interface pointers which the Application Station then uses to command motion.  The template function block <code>FB_XTS_StationBase</code> includes a method <code>GetMovers()</code>, which handles basic mover acquisition and positioning.</p> <p>An explanation of this base logic may be useful to those seeking to develop custom station types.</p>"},{"location":"SPT_XTS/stationprogrammingnotes.html#the-code","title":"The Code","text":"<pre><code>CASE SequenceState OF\n    0:\n        IF (NumberOfAssignedMovers &lt; NumberOfStops) THEN\n            SequenceState := SequenceState + 10;\n        ELSE\n            SequenceState := 40;\n        END_IF\n\n    10:\n        IF ipInfoStation.GetMover() THEN\n            // Ask for a new mover          \n            SequenceState := SequenceState + 10;\n        END_IF\n\n    20:\n        //Make sure we don't page fault\n        IF MoverQueue.LastMover &lt;&gt; 0 THEN\n            // Call new mover to this station--station positions go front-to-back\n            StopPosition := StopPositions[NumberOfStops - (NumberOfAssignedMovers - 1)];\n            StopPosition := GetStopPosition(StopPosition);\n            IF MoverQueue.LastMover.MoveAbsoluteCA(StopPosition, TRUE, FALSE) THEN\n                SequenceState := SequenceState + 10;\n            END_IF\n        END_IF\n\n    30:\n        // Make sure we have the correct number of movers\n        IF NumberOfAssignedMovers = NumberOfStops THEN\n            SequenceState := SequenceState + 10;\n        ELSE\n            SequenceState := 10;\n        END_IF\n\n    40:\n        //Wait for all movers to arrive at their assigned positions\n        MoverTracker.Clear();\n        ipMovers := MoverQueue.Queue;\n        FOR i := 1 TO NumberOfStops DO\n            IF ipMovers[i] &lt;&gt; 0 THEN\n                IF NOT ipMovers[i].Busy THEN\n                    StopPosition := StopPositions[NumberOfStops - (i - 1)];\n                    StopPosition := GetStopPosition(StopPosition);\n                    IF ipMovers[i].IsMoverInPosition(StopPosition) THEN\n                        MoverTracker.Set(i);\n                    END_IF\n                END_IF\n            END_IF\n        END_FOR\n\n        IF MoverTracker.NumberCompleted = NumberOfStops THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    50:\n        SequenceState := 0;\n        GetMovers     := TRUE;\nEND_CASE\n</code></pre>"},{"location":"SPT_XTS/stationprogrammingnotes.html#the-intent","title":"The Intent","text":"<p>A basic <code>CASE</code> state machine is executed, with an inner loop (states 0-30) repeating until the correct number of movers (based on Stop Positions configured for the InfoStation) have been acquired.  The logic waits until all movers have arrived at their assigned positions before returning <code>TRUE</code>, indicating to the caller that all movers have arrived.</p> <ul> <li>State 0 - Check the buffer depth to see if we need another mover</li> <li><code>NumberOfAssignedMovers</code> is a property that returns the number of movers in the buffer <code>MoverQueue</code>.  <code>MoverQueue</code> is actually a pointer to the buffer function block that lives inside the <code>FB_XTS_InfoStation</code> that is assigned to this <code>I_XTS_ApplicationStation</code> (via the <code>InfoStation</code> property).  This pointer is managed automatically.</li> <li><code>NumberOfStops</code> is a property that returns the number of stop positions that have been defined for this InfoStation</li> <li>State 10 - Ask our InfoStation to get another mover</li> <li>The <code>GetMover()</code> method will return <code>TRUE</code> when a new mover has been added to the buffer</li> <li>This logic is handled internally in the XPU component</li> <li>Movers will only be passed from the upstream <code>I_XTS_ApplicationStation</code> if that station has set its <code>CanReleaseMover</code> property to <code>TRUE</code></li> <li>State 20 - Get the next stop position and send our new mover there<ul> <li><code>StopPositions</code> is an array of positions that corresponds to the Stop Positions set for this InfoStation</li> <li>Stop Positions as set using the XTS configurator are relative to the Start Position of the station!</li> <li>They must be transformed according to the Track this <code>I_XTS_ApplicationStation</code> is assigned to</li> <li>Most configurations only include one track</li> <li><code>GetStopPosition()</code> will calculate the position on the track that we will then command our new mover to</li> </ul> </li> <li>State 30 - Check to see if we have the required number of movers</li> <li>State 40 - Wait for all movers to arrive at their assigned position<ul> <li><code>MoverTracker</code> is a simple way of tracking which movers have successfully completed a task so that we don't issue the same command many times</li> <li><code>ipMovers</code> gets a copy of the <code>MoverQueue.Queue</code>.  This is required so that we can index against the array of <code>I_XTS_Mover</code></li> <li>If <code>I_XTS_Mover.Busy</code> is set, a command is still in process</li> <li>We get the track position for each Stop Position and check that the mover's actual position is within an acceptable range</li> <li>This range is defined as Stop Position +/- NC Parameter Target Position Window</li> </ul> </li> </ul> <p>    - State 50 - Dead Scan to return true and clean up the state machine</p>"},{"location":"SPT_XTS/stationprogrammingnotes.html#queue-logic","title":"Queue Logic","text":"<p><code>FB_XTS_QueueStation</code> overrides the above state machine and removes the 'in position' checks.</p> <pre><code>CASE SequenceState OF\n    0:\n        //Don't combine this with state 20 -- there is a dead scan for method cleanup/returns\n        IF CanAcceptMover THEN\n            SequenceState := SequenceState + 10;\n        END_IF\n\n    10:\n        IF ipInfoStation.GetMover() THEN\n            // Ask for a new mover      \n            SequenceState := SequenceState + 10;\n        END_IF\n\n    20:\n        //Make sure we don't page fault\n        IF MoverQueue.LastMover &lt;&gt; 0 THEN\n            // Call new mover to this station--use only stop position 1\n            StopPosition := StopPositions[1];\n            StopPosition := GetStopPosition(StopPosition);\n            IF MoverQueue.LastMover.MoveAbsoluteCA(StopPosition, TRUE, FALSE) THEN\n                SequenceState := 0;\n            END_IF\n        ELSE\n            SequenceState := 0;\n        END_IF\nEND_CASE\n</code></pre>"},{"location":"V4%20Release%20Notes/BreakingChanges.html","title":"Breaking Changes","text":"<p>Naming optimizations were made to the PackML standard which will require changes to the PackML Modes, States, and Commands. The following changes were made:</p>"},{"location":"V4%20Release%20Notes/BreakingChanges.html#e_pmlprotectedunitmode","title":"E_PMLProtectedUnitMode","text":"<p>The enumeration members used within the E_PMLProtectedUnitMode have been given shorter names:</p> PackML V2 PackML V3 E_PMLProtectedUnitMode.ePMLProtectedUnitMode_Invalid E_PMLProtectedUnitMode.Invalid E_PMLProtectedUnitMode.ePMLProtectedUnitMode_Production E_PMLProtectedUnitMode.Production E_PMLProtectedUnitMode.ePMLProtectedUnitMode_Maintenance E_PMLProtectedUnitMode.Maintenance E_PMLProtectedUnitMode.ePMLProtectedUnitMode_Manual E_PMLProtectedUnitMode.Manual"},{"location":"V4%20Release%20Notes/BreakingChanges.html#e_pmlunitmode","title":"E_PMLUnitMode","text":"<p>The enumeration members used within the E_PMLUnitMode of the SPT Base Types library have been given shorter names:</p> SPT V3 SPT V4 E_PMLUnitMode.ePMLUnitMode_Invalid E_PMLUnitMode.Invalid E_PMLUnitMode.ePMLUnitMode_Production E_PMLUnitMode.Production E_PMLUnitMode.ePMLUnitMode_Manual E_PMLUnitMode.Manual E_PMLUnitMode.ePMLUnitMode_Maintenance E_PMLUnitMode.Maintenance E_PMLUnitMode.ePMLUnitMode_UserMode1 E_PMLUnitMode.UserMode1 ... ... E_PMLUnitMode.ePMLUnitMode_UserMode28 E_PMLUnitMode.UserMode28"},{"location":"V4%20Release%20Notes/BreakingChanges.html#e_pmlstate","title":"E_PMLState","text":"<p>The enumeration members used within the E_PMLState have been given shorter names:</p> PackML V2 PackML V3 E_PMLState.ePMLState_Aborting E_PMLState.Aborting E_PMLState.ePMLState_Aborted E_PMLState.Aborted E_PMLState.ePMLState_Clearing E_PMLState.Clearing E_PMLState.ePMLState_Stopping E_PMLState.Stopping E_PMLState.ePMLState_Stopped E_PMLState.Stopped E_PMLState.ePMLState_Resetting E_PMLState.Resetting E_PMLState.ePMLState_Idle E_PMLState.Idle E_PMLState.ePMLState_Starting E_PMLState.Starting E_PMLState.ePMLState_Execute E_PMLState.Execute E_PMLState.ePMLState_Completing E_PMLState.Completing E_PMLState.ePMLState_Complete E_PMLState.Completed E_PMLState.ePMLState_Suspending E_PMLState.Suspending E_PMLState.ePMLState_Suspended E_PMLState.Suspended E_PMLState.ePMLState_Unsuspending E_PMLState.Unsuspending E_PMLState.ePMLState_Holding E_PMLState.Holding E_PMLState.ePMLState_Held E_PMLState.Held E_PMLState.ePMLState_Unholding E_PMLState.Unholding <p>Note</p> <p>The Complete state has been renamed to Completed. This is a change in the PackML standard and not a change in the TwinCAT implementation.</p>"},{"location":"V4%20Release%20Notes/BreakingChanges.html#e_pmlcommand","title":"E_PMLCommand","text":"<p>The enumeration members used within the E_PMLCommand have been given shorter names:</p> PackML V2 PackML V3 E_PMLCommand.ePMLCommand_Abort E_PMLCommand.Abort E_PMLCommand.ePMLCommand_Clear E_PMLCommand.Clear E_PMLCommand.ePMLCommand_Stop E_PMLCommand.Stop E_PMLCommand.ePMLCommand_Reset E_PMLCommand.Reset E_PMLCommand.ePMLCommand_Start E_PMLCommand.Start E_PMLCommand.ePMLCommand_Complete E_PMLCommand.Complete E_PMLCommand.ePMLCommand_Hold E_PMLCommand.Hold E_PMLCommand.ePMLCommand_Unhold E_PMLCommand.Unhold E_PMLCommand.ePMLCommand_Suspend E_PMLCommand.Suspend E_PMLCommand.ePMLCommand_Unsuspend E_PMLCommand.Unsuspend <p>Note</p> <p>The PackML V2 standard did not have a Complete command, but instead used the StateComplete method just as the other acting states. However, the TwinCAT implementation of PackML V2 did have a Complete command that would provide the same functionality. The PackML V3 standard has added the Complete command to the enumeration. The TwinCAT implementation has been updated to match the PackML V3 standard.</p>"},{"location":"V4%20Release%20Notes/BreakingChanges.html#function-names","title":"Function Names:","text":"PackML V2 PackML V3 F_UnitModeToString F_PMLUnitModeToString"},{"location":"V4%20Release%20Notes/BreakingChanges.html#pack-tags","title":"Pack Tags","text":"<p>Here is a short list of some of the Pack Tags that have been renamed. </p> PackML V2 PackML V3 Tc3_PackML_V2.MaxAlarms Tc3_PackML_V3.cMaxAlarms Tc3_PackML_V2.ST_PMLa Tc3_PackML_V3.ST_PMLa Tc3_PackML_V2.ST_Alarm Tc3_PackML_V3.ST_PMLEvent Tc3_PackML_V2.MaxStopReasons No Equivalent Tc3_PackML_V2.MaxWarnings Tc3_PackML_V3.cMaxWarnings Tc3_PackML_V2.MaxHistoryAlarms Tc3_PackML_V3.cMaxHistoryAlarms"},{"location":"V4%20Release%20Notes/KnownIssues.html","title":"Known Issues","text":""},{"location":"V4%20Release%20Notes/KnownIssues.html#spt-base-types","title":"SPT Base Types","text":""},{"location":"V4%20Release%20Notes/KnownIssues.html#visu-v_machinemodule","title":"Visu - V_MachineModule","text":"<p>The V_MachineModule has not been updated to include a button for the new Complete command.</p>"},{"location":"V4%20Release%20Notes/KnownIssues.html#spt-utilities","title":"SPT Utilities","text":""},{"location":"V4%20Release%20Notes/KnownIssues.html#trace-listener","title":"Trace Listener","text":"<p>Due to the change of Tc3_PackML_V2.ST_Alarm to Tc3_PackML_V3.ST_PMLEvent and the structures that previously used an array of ST_Alarm that are now using a single ST_PMLEvent, the Trace Listener has been removed from the SPT Utilities library. There is currently no replacement for this functionality.</p>"},{"location":"V4%20Release%20Notes/NewFeatures.html","title":"New Features","text":""},{"location":"V4%20Release%20Notes/NewFeatures.html#packml-state-machine-update","title":"PackML State Machine Update","text":"<p>PackML V3 provides the ability to change states from Held and/or Suspended without having to pass through the Execute state.</p> <p> </p>"},{"location":"V4%20Release%20Notes/NewFeatures.html#spt-eventlogger","title":"SPT EventLogger","text":"<p>A new Events function block has been added to the SPT Event Logger library. This function block provides a new way to create events as opposed to the existing F_CreateAllEventsInClass. Sample code and implementation documentation coming soon.</p>"},{"location":"V4%20Release%20Notes/PinningLibraries.html","title":"Pinning Libraries","text":"<p>For those with both SPT V3 and V4 libraries installed, the SPT V4 libraries will be used by default. This is indicated by the * in the Library Manager. It is important to pin the libraries used in your projects to a specific version. </p> <p></p> * denoting use of latest version <p>To pin the library version select it in the solution explorer under 'References'.</p> <p></p> <p>In the properties window, use the drop down list to set the Resolution to 3.X </p> <p>Library dependencies will also have to be pinned, if the library is not added and pinned directly. Since SPT Base Types has a reference to SPT Event Logger, it will also need to be pinned. In the Library Manager, select PlaceHolders. Any SPT libraries that are not pinned will be marked with a * in the Library Manager. Pin all SPT libraries to the same version. In this example, we are pinning to 3.9.  </p>"},{"location":"V4%20Release%20Notes/Requirements.html","title":"Requirements","text":"<p>SPT V4 requires the use of TwinCAT 3.1.4026 and PackML V3</p> <p>PackML V3 is currently obtained through the Package Manager CLI, using the following command <pre><code>TcPkg install TwinCAT.XAE.PLC.Lib.Tc3_PackML_V3\n</code></pre></p>"},{"location":"V4%20Release%20Notes/Samples.html","title":"Samples","text":"<p>V4 Samples are available in the V4 Samples repository.</p> <p>A current list of the samples and their descriptions is available in the training documentation Sample Code.</p>"}]}